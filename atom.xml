<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙同生的博客</title>
  
  <subtitle>为美好的世界献上祝福</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://developerdoc.com/"/>
  <updated>2024-06-17T12:40:22.923Z</updated>
  <id>https://developerdoc.com/</id>
  
  <author>
    <name>SunTongSheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ipa包体分析脚本</title>
    <link href="https://developerdoc.com/essay/ios-business/ipaAnylize/"/>
    <id>https://developerdoc.com/essay/ios-business/ipaAnylize/</id>
    <published>2022-06-17T10:24:12.000Z</published>
    <updated>2024-06-17T12:40:22.923Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍一下 <a href="https://github.com/sunyanyan/ipaAnalyze" target="_blank" rel="noopener">https://github.com/sunyanyan/ipaAnalyze</a> 里的脚本。<br>该脚本输入ipa文件以及对应linkmap文件，输入该ipa各类资源的大小、以及各个模块的大小。</p><a id="more"></a><h3 id="ipa内部文件"><a href="#ipa内部文件" class="headerlink" title="ipa内部文件"></a>ipa内部文件</h3><p>iOS打包出来的ipa，本质上是一个压缩包，所以可以将.ipa的后缀改为.zip，然后进行解压缩，之后会得到一个Payload文件夹，里面又一个xxx.app的文件，这个xxx.app就是包含所有文件的包了，选中xxx.app，右键显示包内容，即可看到里面具体包含的东西了，大致如下</p><ul><li>_CodeSignature：  ipa包签名文件</li><li>.lproj：      语言文件</li><li>Frameworks：      第三库、SwiftSupport库</li><li>Plugins：         App创建的扩展，比如：Widget、Push、分享</li><li>Assets.car：      由Assets.xcassets生成的资源文件，里面包含各种分辨率的图片</li><li>embedded.mobileprovision：证书配置文件</li><li>Info.plist：      项目配置</li><li>exec格式的xxx：    可执行包</li><li>其它资源文件<ul><li>.mp3格式的文件</li><li>.html的文件</li><li>.json的文件</li><li>.png或者.jpg的文件</li></ul></li></ul><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p>脚本对于资源分类 简单粗暴根据文件后缀名分类：</p><p><img src="https://github.com/sunyanyan/ipaAnalyze/raw/main/test/test1.png" alt></p><h3 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h3><p>根据linkmap文件分析，Link Map 中的包含的区块内容有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path: Link Map 文件对应的可执行二进制文件</span><br><span class="line">Arch: 编译生成的可执行二进制文件的 CPU 架构</span><br><span class="line">Object files: 每一个源代码文件编译后生成的对象文件列表</span><br><span class="line">Sections: 在最终可执行二进制文件中不同类型代码所在的节列表</span><br><span class="line">Symbols: 所有代码中的函数、变量、字符串等实际生成的符合列表</span><br></pre></td></tr></table></figure><p>我们不用关心 Sections 中的内容，因为它只是对应到不同符号存储的位置，不影响它实际占用的体积。我们需要关注 Object files 和 Symbols 这两块内容，因为它实际包含了在可执行二进制文件中占有体积的部分。</p><p>其中 Object files 包含了每个代码文件编译出来的对象文件路径，以及它的编号。每个对象文件的编号，将在后续符号列表中被引用，从而标识那些符号是由哪个代码文件中的代码生成的。</p><p>例如上面示例中的 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"># Sections:</span><br><span class="line"># Address   Size        Segment Section</span><br><span class="line">0x100002CC0 0x0000CAF2  __TEXT  __text</span><br><span class="line">0x10000F7B2 0x000000C0  __TEXT  __stubs</span><br><span class="line">0x10000F874 0x00000150  __TEXT  __stub_helper</span><br><span class="line">0x10000F9C4 0x00002BD0  __TEXT  __objc_methname</span><br><span class="line">......</span><br><span class="line"># Symbols:</span><br><span class="line"># Address   Size        File  Name</span><br><span class="line">0x100002CC0 0x00000080  [  1] -[LMWindowController windowDidLoad]</span><br><span class="line">0x100002D40 0x00000059  [  1] -[LMWindowController windowShouldClose:]</span><br><span class="line">0x100002DA0 0x00000170  [  2] -[ViewController viewDidLoad]</span><br><span class="line">0x100002F10 0x00000070  [  2] -[ViewController setRepresentedObject:]</span><br><span class="line">0x100002F80 0x00000140  [  2] -[ViewController saveURL:forKey:]</span><br><span class="line">0x1000030C0 0x00000220  [  2] -[ViewController retriveURLForKey:]</span><br><span class="line">0x1000032E0 0x00000120  [  2] -[ViewController chooseLinkMap:]</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>在符号列表中，我们就可以获取到每个类的每个函数的大小，再通过对象文件编号进行关联，就可以将每个代码文件所生成的指令在最终可执行二进制文件所占的体积大小统计出来。</p><p>最终得到如图输出</p><p><img src="https://github.com/sunyanyan/ipaAnalyze/raw/main/test/test4.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍一下 &lt;a href=&quot;https://github.com/sunyanyan/ipaAnalyze&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sunyanyan/ipaAnalyze&lt;/a&gt; 里的脚本。&lt;br&gt;该脚本输入ipa文件以及对应linkmap文件，输入该ipa各类资源的大小、以及各个模块的大小。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发进阶" scheme="https://developerdoc.com/categories/iOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS安装包瘦身</title>
    <link href="https://developerdoc.com/essay/ios-business/ipa_size/"/>
    <id>https://developerdoc.com/essay/ios-business/ipa_size/</id>
    <published>2022-06-07T08:53:25.000Z</published>
    <updated>2024-06-13T03:04:35.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优化指标"><a href="#优化指标" class="headerlink" title="优化指标"></a>优化指标</h3><p>itunes connect上有两种包大小显示：“Download Size”，“Install Size”。“Download Size”即下载包大小，超过150M需要使用无线网下载的限制就是这个大小（现在已经放宽到200M）；“Install Size”即安装后占用的磁盘空间大小，在appstore上显示的也是这个大小，用户往往会误认为这是下载安装包消耗的流量大小。所以一开始我们就将“Install Size”作为了优化指标。“Install Size”减小后，“Download Size”自然也会减小。</p><a id="more"></a><h3 id="Asset-Catalog中的文件大小计算"><a href="#Asset-Catalog中的文件大小计算" class="headerlink" title="Asset Catalog中的文件大小计算"></a>Asset Catalog中的文件大小计算</h3><p>Assest.car 做为 Asset Catalog 的编译产物，我们怎么获取到car文件中的图片大小呢？在以前查iOS9，P3格式图片问题的时候我们用过苹果提供的assetutil工具，使用assetutil就能获取到图片信息描述：</p><p><code>sudo xcrun --sdk iphoneos assetutil --info xxx/Assets.car &gt; xxx/Assets.json</code></p><p>Assets.json 中的图片详细数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;AssetType&quot; : &quot;Image&quot;,</span><br><span class="line">    &quot;BitsPerComponent&quot; : 8,</span><br><span class="line">    &quot;ColorModel&quot; : &quot;RGB&quot;,</span><br><span class="line">    &quot;Colorspace&quot; : &quot;srgb&quot;,</span><br><span class="line">    &quot;Compression&quot; : &quot;lzvn&quot;,</span><br><span class="line">    &quot;Encoding&quot; : &quot;ARGB&quot;,</span><br><span class="line">    &quot;Idiom&quot; : &quot;universal&quot;,</span><br><span class="line">    &quot;Image Type&quot; : &quot;kCoreThemeOnePartScale&quot;,</span><br><span class="line">    &quot;Name&quot; : &quot;1001&quot;, //xxx.imageset 的文件名</span><br><span class="line">    &quot;NameIdentifier&quot; : 11584,</span><br><span class="line">    &quot;Opaque&quot; : false,</span><br><span class="line">    &quot;PixelHeight&quot; : 48,</span><br><span class="line">    &quot;PixelWidth&quot; : 72,</span><br><span class="line">    &quot;RenditionName&quot; : &quot;1001@3x.png&quot;,//工程文件中的实际图片名</span><br><span class="line">    &quot;Scale&quot; : 3,</span><br><span class="line">    &quot;SHA1Digest&quot; : &quot;E34FCAC314E26DE7FF30442AA33E436B242AA4BA&quot;,</span><br><span class="line">    &quot;SizeOnDisk&quot; : 800,//占用的磁盘大小，Asset Catalog中的图片编译后的大小取该值。</span><br><span class="line">    &quot;Template Mode&quot; : &quot;automatic&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>最终我们使用SizeOnDisk 字段来获取图片大小。使用SizeOnDisk计算精度很高（所有图片的SizeOnDisk相加和car文件大小误差在1M以内）。</p><p>一个Asset Catalog的图片在Assets.car中实际上根据不同设备有4张对应的图片，大小不同，但名字相同。而cartool解压出的图片大小为其中某一张，这样大小计算就不太准确了。所以放弃原先使用cartool，改用assetutil。</p><h4 id="App-Slicing"><a href="#App-Slicing" class="headerlink" title="App Slicing"></a>App Slicing</h4><p>比如企业包不经过appslicing：<br><img src="/res/ios-business/assets-img.png" alt><br>App在打包过程中，会将同一张图片采用适合各个不同架构的压缩方式将图片压缩,并存储到asset.car中.</p><p>App Slicing只会对在Asset Catalog的资源文件进行分发，而放在根目录，bundle中的资源文件不会分发，所以在统计模块所使用资源文件之前我们需要注意到这个特性。如果以通用包来统计模块使用的资源文件大小、数量，其实并不能真正反映此模块对整个安装包大小的影响。所以我们决定使用单个设备来衡量资源文件使用情况。目前我们选择iPhone X，iOS11设备做为参考标准。 要统计单个设备的资源文件使用情况，一个方式是使用adhoc包导出支持单个设备的安装包统计，不过这样的方式需要每次集成后都需要单独打包，因为现在ci并不会出支持单个设备的包。后来我们发现assetutil除了可以导出car文件信息之外，还可以从通用包car文件导出指定设备的car文件，入参较多，经过尝试iPhone X的如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xcrun --sdk iphoneos assetutil --idiom phone --subtype 570 --scale 3 --display-gamut srgb --graphicsclass MTL2,2 --graphicsclassfallbacks MTL1,2:GLES2,0 --memory 1 --hostedidioms car,watch xxx/Assets.car -o xxx/thinning_assets.car</span><br></pre></td></tr></table></figure><p>从上文知道car以外的资源文件不会分发，获取指定设备的car文件后我们就可以计算出模块所用资源文件大小，数量。</p><h3 id="其他的资源文件大小计算"><a href="#其他的资源文件大小计算" class="headerlink" title="其他的资源文件大小计算"></a>其他的资源文件大小计算</h3><p>其他的文件大小计算方式相对简单，苹果的APFS文件系统的最小存储单元为4KB，即使只有几十字节大小的文件，占用的空间也是4KB。对于安装包里面的独立文件我们使用4KB对齐的方式进行大小计算，有些大点的文件磁盘占用空间并不是4的整数倍，但大小相近，影响不大： Math.ceil(size/4000.0)4，size为文件实际大小，单位字节; 在 MB、KB、Byte 之间的换也是对齐 Apple 使用的是 1000 而不是 1024（即1MB = 1000 KB = 10001000 Byte）。</p><h3 id="可执行文件优化"><a href="#可执行文件优化" class="headerlink" title="可执行文件优化"></a>可执行文件优化</h3><ul><li>使用strip -x命令处理动态库。</li><li>无用类和无用方法 。结合 linkMap映射出无用的方法和类归属的组件，并且初步量化大小。因为基础组件中的无用方法和类，不能确定是否被非商城的 App 使用，只能对业务组件优化，考虑到涉及组件众多，并且收益和工程量不成正比，并且删除方法风险比较大，将无用方法和类优化的优先级降低。</li><li>内置的ReactNative业务 JDReact提供了预置和后装两种发布方式，而为了用户体验，大部分业务模块都选择使用预置包的方式。时间一长，文件的数量就越来越多。由于文件系统的4K对齐，对包大小的影响也是非常大。对内置的ReactNative业务优化如下：<ul><li>推动流量相对较低的模块（三级及三级以上页面）转后装方式；</li><li>根据资源文件使用规范，推动业务整改； 这部分的工作量主要在和业务方的沟通，经过部分模块转后装后，瘦身效果也是很明显。</li></ul></li><li>extension 在ipa包中我们也注意到了PlugIns目录,这里主要存放一些插件，比如today extension，share extension等，虽然这些插件在整个ipa包中的大小占比不大，但是我们还是决定梳理下有没有优化点。梳理后发现这些插件对于一些基础类库（网络框架，图片加载框架等）的使用都是以拷贝代码的方式加到工程中。我们知道这些类库完全可以和主app共享，因为主app中这些库是以动态库的形式使用的。经过优化后，成功的将today extension的大小减少了0.9M（嗯~蚊子虽小…）。</li></ul><h4 id="去除符号信息"><a href="#去除符号信息" class="headerlink" title="去除符号信息"></a>去除符号信息</h4><ul><li>Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，详细信息见官方文档。</li><li>这些选项目前都是XCode里release的默认选项，但旧版XCode生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.html" target="_blank" rel="noopener">Introduction to Code Size Performance Guidelines</a></li></ul><h4 id="无用类无用方法"><a href="#无用类无用方法" class="headerlink" title="无用类无用方法"></a>无用类无用方法</h4><p>扫描无用代码的基本思路都是查找已经使用的方法/类和所有的类/方法，然后从所有的类/方法当中剔除已经使用的方法/类剩下的基本都是无用的类/方法，但是由于 Objective-C 是动态语言，可以使用字符串来调用类和方法，所以检查结果一般都不是特别准确，需要二次确认。目前市面上的扫描的思路大致可以分为 3 种：</p><ul><li>基于 Clang 扫描</li><li>基于可执行文件扫描</li><li>基于源码扫描</li></ul><blockquote><p>重构重复代码</p></blockquote><p>重复代码堆积太多，不仅意味着 Bad Code Smell，我们的包大小也会受到影响，我们可以使用 PMD 来检查项目中的重复代码，并且做选择性的重构。</p><blockquote><p>jd做法</p></blockquote><p>无用类通过 otool 逆向Mach-O文件 <strong>DATA.</strong>objc_classlist段和<strong>DATA.</strong>objc_classrefs 段获取所有 OC 类和被引用的类，两个集合差值为无用类集合，</p><ul><li>结合 nm -nm 得到地址和对应类名符号化无用类类名；根据商城的限制做过滤，规则如下：</li><li>otool 逆向 <strong>DATA.</strong>objc_nlclslist 获取实现 load 方法的类过滤（RN与原生的桥接类、Swizzle Method 类）；</li><li>通过 otool 逆向 <strong>TEXT.</strong>cstring 获取所有字符串常量，过滤通过 NSClassFromString 调用的；</li><li>子类实例化，父类没有实例化，父类不会出现在中 __objc_classrefs，通过 otool -oV 逆向出类的继承关系，过滤出子类被实例化（NSClassFromString 调用），父类没有实例化（NSClassFromString 调用）的类；</li><li>过滤使用 Plist 文件引用的类；</li></ul><p>无用方法 通过 otool 逆向 <strong>DATA.</strong>objc_selrefs 段获取使用到的方法，通过 otool -oV 获取实现的所有方法取差值。然后过滤掉 setter、getter、系统方法和协议、自定义的协议、sel 调用。</p><h4 id="静态库统计"><a href="#静态库统计" class="headerlink" title="静态库统计"></a>静态库统计</h4><p>项目里会引入很多第三方静态库，如果能知道这些第三方库在可执行文件里占用的大小，就可以评估是否值得去找替代方案去掉这个第三方库。我们可以从linkmap中统计出这个信息，可以通过linkmap统计每个.o目标文件占用的体积和每个.a静态库占用的体积</p><h4 id="ARC转MRC"><a href="#ARC转MRC" class="headerlink" title="ARC转MRC"></a>ARC转MRC</h4><p>有人提出用ARC写的代码编译出来的可执行文件是会比用MRC大的，原因大致是ARC代码会在某些情况多出一些retain和release的指令，例如调用一个方法，它返回的对象会被retain，退出作用域后会被release，MRC就不需要，汇编指令变多，机器码变多，可执行文件就变大了。还有其他细节实现的区别，先不纠结了。</p><p>那用ARC究竟会增大多少体积？我觉得从汇编指令的增多减少去算是很难算准确的，这东西涉及细节太多，还是得从统计的角度计算。做了几个对比试验，统计了几个同时支持ARC/MRC的开源项目在开启/关闭ARC的情况下<strong>TEXT代码段的大小对比。只对比</strong>TEXT代码段是因为：</p><p>ARC对可执行文件大小的影响几乎都是在代码段ARC大概会使代码段增加10%的size，考虑代码段占可执行文件大约有80%，估计对整个可执行文件的影响会是8%。</p><p>可以评估一下8%的体积下降是不是值得把项目里某些模块改成MRC，这样程序的维护成本上升了，一般不到特殊情况不建议这么做。</p><h4 id="类-方法名长度"><a href="#类-方法名长度" class="headerlink" title="类/方法名长度"></a>类/方法名长度</h4><p>观察linkmap可以发现每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来。</p><p>对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩js一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它class-dump出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行hack。不过这样做有个缺点，就是crash堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆-&gt;原名的转换，实现和使用成本有点高。</p><p>实际上这部分占用的长度比较小，中型项目也就几百K，对安全性要求高的情况可以试试。</p><h3 id="资源文件优化"><a href="#资源文件优化" class="headerlink" title="资源文件优化"></a>资源文件优化</h3><p>这也是一期优化通过改造 Assets.car 中的 183 张图片能优化了近 30M 原因，千万不要将大图随意拖到工程中。 结合上文中负优化规律，改造处理方案如下：</p><ul><li>无用文件删除 <ul><li>现在应该没有APP需要支持iPhone4以下的机型了，所以1X的图片可以全部删掉。3X的图片是保留还是删掉看具体情况。</li></ul></li><li>重复文件删除</li><li>大文件压缩 apng<ul><li>不能转下载的使用压缩过的jpg格式图片。</li><li>不能使用jpg的图片经过压缩后( 主要是tinypng有损压缩)后放到 bundle 中使用。</li></ul></li><li>图片管理方式规范<ul><li>优先转网络下载，使用默认图/纯色兜底，如楼层背景图；</li></ul></li><li>资源压缩<ul><li>首先是<em>图片压缩</em>，ImageOptim/TinyPNG/ImageAlapha 工具可以实现无损压缩。<ul><li>其实在我们使用这些图片的时候,我们其实是用的一些图片,但是像图片的创建日期,创建人之类的信息其实在我们项目中是没有用到的.这些信息我们可以通过一些工具进行删除,这里给大家推荐款工具ImageOptim.另外关于图片，建议使用Apple推荐的.xcassets来管理，它会把里边的所有png格式的图片压缩成一个Assets.car文件，压缩比率比其他方式管理图片要高。不过测试发现jpg图片不会在Assets.car文件里。</li></ul></li><li>尽量使用<em>8-bit图片</em><ul><li>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜se图片。例如灰度图片最好使用8-bit。</li></ul></li><li><em>音频的压缩</em><ul><li>参考WWDC中的<a href="https://developer.apple.com/videos/play/wwdc2011/404/" target="_blank" rel="noopener">Audio Development for Games</a>，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</li></ul></li></ul></li></ul><h4 id="无用图片筛查"><a href="#无用图片筛查" class="headerlink" title="无用图片筛查"></a>无用图片筛查</h4><p>通过分析安装包中使用图片可分为三类文件：</p><ul><li>可执行文件；</li><li>可读文件（.plist、.js、.html）；</li><li>不可读文件（.nib、.storyboardc）；</li></ul><p>可执行文件通过 otool -v -s <strong>TEXT </strong>cstring 获取可执行文件中的 <strong>TEXT.</strong>cstring 段。__cstring 包含了可执行文件中的字符串常量（源码中的 @“xxx” 字符串）；</p><h4 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h4><p>即使经过了图片转下载，无用图片删除，但是工程中的图片数量还是极为可观，其中各种各样的icon图标占了不少的数量。为了进一步减少图片数量，我们引入了iconfont方案， iconfont优点：</p><ul><li>矢量，缩放不失真。</li><li>可以设置颜色。</li><li>接入成本低，不需要引入额外的类库。</li></ul><p>iconfont 可以解决因为icon大小，颜色不同而重新切图的窘境。从京东内部的quark平台了解到目前已经可以很好的支持iconfont，我们在一个模块就找到了55个icon并且成功转成了iconfont。不难看出iconfont是一个能减少图片数量的好方案。</p><blockquote><p>注意： Apple 为了在优化 iPhone 设备读取 png 图片速度，将 png 转换成 CgBI 非标准的 png 格式<br>Apple自动优化： • 放在根目录下png格式的图片。 • 放在Asset Catalog中的png，jpg格式的图片，其中jpg会转成png。<br>不会处理： 放在根目录下的jpg， bundle中的png不会被优化</p></blockquote><h3 id="xcode编译参数优化"><a href="#xcode编译参数优化" class="headerlink" title="xcode编译参数优化"></a>xcode编译参数优化</h3><ul><li>Generate Debug Symbols</li><li>Asset Catalog Compiler</li><li>Dead Code Stripping</li><li>Apple Clang - Code Generation - Optimization Level</li><li>Strip Symbol Information</li><li>Exceptions - 去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>无用物品扫描 <a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">https://github.com/tinymind/LSUnusedResources</a></p><p>重复文件：<a href="https://github.com/arsenetar/dupeguru" target="_blank" rel="noopener">https://github.com/arsenetar/dupeguru</a></p><p>图片压缩 : <a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">https://github.com/ImageOptim/ImageOptim</a></p><p>linkmap: <a href="https://github.com/huanxsd/LinkMap" target="_blank" rel="noopener">https://github.com/huanxsd/LinkMap</a></p><p>查找相似代码 <a href="https://github.com/startry/SameCodeFinder" target="_blank" rel="noopener">https://github.com/startry/SameCodeFinder</a></p><p>无用代码 无用imoprt <a href="https://github.com/dblock/fui" target="_blank" rel="noopener">https://github.com/dblock/fui</a> </p><p><a href="http://blog.lessfun.com/blog/2015/09/02/find-unused-resources-in-xcode-project/" target="_blank" rel="noopener">查找XCode工程中没被使用的图片资源</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>干货！京东商城iOS App瘦身实践<br>干货|今日头条iOS端安装包大小优化<br><a href="https://www.jianshu.com/p/c94dedef90b7" target="_blank" rel="noopener">https://www.jianshu.com/p/c94dedef90b7</a><br><a href="https://www.cnblogs.com/wdsunny/p/7486617.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdsunny/p/7486617.html</a><br><a href="https://mp.weixin.qq.com/s/J_XYpIfDeeWJBlk9sRQMAA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/J_XYpIfDeeWJBlk9sRQMAA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;优化指标&quot;&gt;&lt;a href=&quot;#优化指标&quot; class=&quot;headerlink&quot; title=&quot;优化指标&quot;&gt;&lt;/a&gt;优化指标&lt;/h3&gt;&lt;p&gt;itunes connect上有两种包大小显示：“Download Size”，“Install Size”。“Download Size”即下载包大小，超过150M需要使用无线网下载的限制就是这个大小（现在已经放宽到200M）；“Install Size”即安装后占用的磁盘空间大小，在appstore上显示的也是这个大小，用户往往会误认为这是下载安装包消耗的流量大小。所以一开始我们就将“Install Size”作为了优化指标。“Install Size”减小后，“Download Size”自然也会减小。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发进阶" scheme="https://developerdoc.com/categories/iOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS App启动优化</title>
    <link href="https://developerdoc.com/essay/ios-business/App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://developerdoc.com/essay/ios-business/App启动优化/</id>
    <published>2022-06-06T12:57:54.000Z</published>
    <updated>2024-06-11T12:51:28.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>iOS应用的启动可分为pre-main阶段和main()阶段，pre-main阶段为main函数执行之前所做的操作，main阶段为main函数到首页展示阶段。其中系统做的事情为：</p><ul><li>premain<ul><li>加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）</li><li>加载动态链接库加载器dyld（dynamic loader）</li><li>定位内部、外部指针引用，例如字符串、函数等</li><li>加载类扩展（Category）中的方法</li><li>C++静态对象加载、调用ObjC的 +load 函数</li><li>执行声明为<strong>attribute</strong>((constructor))的C函数</li></ul></li><li>main<ul><li>调用main()</li><li>调用UIApplicationMain()</li><li>调用applicationWillFinishLaunching</li></ul></li></ul><a id="more"></a><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ul><li>最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。优化点：<ul><li>减少不必要的framework，因为动态链接比较耗时 | 不要自己使用dlopen方法，让系统来处理模块加载</li><li>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</li><li>删减一些无用的静态变量 | 删减没有被调用到或者已经废弃的方法</li><li>将不必须在+load方法中做的事情延迟</li></ul></li><li>对于main()函数调用之前我们可以优化的点有：<ul><li>不使用xib，直接视用代码加载首页视图 | 首页骨架屏 默认数据</li><li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li><li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li><li>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载</li></ul></li></ul><h3 id="统计启动时的耗时方法"><a href="#统计启动时的耗时方法" class="headerlink" title="统计启动时的耗时方法"></a>统计启动时的耗时方法</h3><p>这一阶段就是需要对启动过程的业务逻辑进行梳理，确认哪些是可以延迟加载的，哪些可以放在子线程加载，以及哪些是可以懒加载处理的。同时对耗时比较严重的方法进行review并提出优化策略进行优化。</p><blockquote><p>DYLD_PRINT_STATISTICS_DETAILS<br>instrument TimeProfile</p></blockquote><p>Instruments的TimeProfile来统计启动时的主要方法耗时，Call Tree-&gt;Hide System Libraries</p><blockquote><p>打印时间的方式来统计各个函数的耗时</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> launchTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">[SDWebImageManager sharedManager];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"launchTime = %f秒"</span>, <span class="built_in">CFAbsoluteTimeGetCurrent</span>() - launchTime);</span><br></pre></td></tr></table></figure><blockquote><p>+load方法统计</p></blockquote><p>同样的我们可以通过Instruments来统计启动时所有的+load方法，以及+load方法所用耗时</p><h3 id="load优化-与-attribute"><a href="#load优化-与-attribute" class="headerlink" title="+load优化 与 attribute"></a>+load优化 与 attribute</h3><p>使用__attribute优化+load方法 由于在我们的工程中存在很多的+load方法，而其中一大部分为cell模板注册的+load方法(我们的每一个cell对应一个模板，然后该模板对应一个字符串，在启动时所有的模板方法都在+load中注册对应的字符串即在字典中存储字符串和对应的cell模板，然后动态下发展示对应的cell)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译器提供了我们一种__attribute__((section(&quot;xxx段，xxx节&quot;)的方式让我们将一个指定的数据储存到我们需要的节当中。</span><br><span class="line"></span><br><span class="line">在BeeHive框架中：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">@class BeeHive; char * kShopModule_mod __attribute((used, section(&quot;__DATA,&quot;&quot;BeehiveMods&quot;&quot;&quot;))) = &quot;&quot;&quot;ShopModule&quot;&quot;&quot;;</span><br></pre></td></tr></table></figure><p>通过使用<strong>attribute</strong>((section(“name”)))来指明哪个段。数据则用<strong>attribute</strong>((used))来标记，防止链接器会优化删除未被使用的段。</p><p>读取section中的值 attribute((constructor))<br>constructor 和 +load 都是在 main 函数执行前调用，但 +load 比 constructor 更加早一丢丢，因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法。所以 constructor 是一个干坏事的绝佳时机：</p><ul><li>所有Class都已经加载完成</li><li>main 函数还未执行</li><li>无需像 +load 还得挂载在一个Class中</li></ul><p>在BeeHive源码中有下面一段代码：</p><p><code>_dyld_register_func_for_add_image</code> :这个函数是用来注册回调，当dyld链接符号时，调用此回调函数。在dyld加载镜像时，会执行注册过的回调函数</p><p>对于每一个已经存在的镜像，当它被动态链接时，都会执行回调void (func)(const struct mach_header mh, intptr_t vmaddr_slide)，传入文件的mach_header以及一个虚拟内存地址 intptr_t。</p><p>通过调用BHReadConfiguration函数，我们就可以拿到之前注册到BeehiveMods特殊段里面的各个Module的类名，该函数返回类名字符串的数组。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="keyword">void</span> initProphet() &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> dyld_callback(<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *mods = BHReadConfiguration(BeehiveModSectName, mhp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *modName <span class="keyword">in</span> mods) &#123;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (modName) &#123;</span><br><span class="line">            cls = <span class="built_in">NSClassFromString</span>(modName);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">                [[BHModuleManager sharedManager] registerDynamicModule:cls];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt;* BHReadConfiguration(<span class="keyword">char</span> *sectionName,<span class="keyword">const</span> <span class="keyword">struct</span> mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *configs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#ifndef __LP64__</span></span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">struct</span> mach_header_64 *mhp64 = (<span class="keyword">const</span> <span class="keyword">struct</span> mach_header_64 *)mhp;</span><br><span class="line">    uintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = size/<span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; counter; ++idx)&#123;</span><br><span class="line">        <span class="keyword">char</span> *string = (<span class="keyword">char</span>*)memory[idx];</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithUTF8String:string];</span><br><span class="line">        <span class="keyword">if</span>(!str)<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        BHLog(<span class="string">@"config = %@"</span>, str);</span><br><span class="line">        <span class="keyword">if</span>(str) [configs addObject:str];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> configs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制重排-静态插桩"><a href="#二进制重排-静态插桩" class="headerlink" title="二进制重排 + 静态插桩"></a>二进制重排 + 静态插桩</h3><p>静态插桩实际上是在编译期就在每一个函数内部二进制源数据添加 hook 代码 ( 我们添加的 __sanitizer_cov_trace_pc_guard 函数 ) 来实现全局的方法 hook 的效果 .</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">    <span class="comment">//它的作用其实就是去读取 x30 中所存储的要返回时下一条指令的地址 . 所以他名称叫做 __builtin_return_address . 换句话说 , 这个地址就是我当前这个函数执行完毕后 , 要返回到哪里去 .</span></span><br><span class="line">    <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(PC, &amp;info);</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n"</span>,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> PcDescr[<span class="number">1024</span>];</span><br><span class="line">    printf(<span class="string">"guard: %p %x PC %s\n"</span>, guard, *guard, PcDescr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题点</p></blockquote><ul><li>多线程问题<ul><li>考虑到这个方法会来特别多次 , 使用锁会影响性能 , 这里使用苹果底层的原子队列 ( 底层实际上是个栈结构 , 利用队列结构 + 原子性来保证顺序 ) 来实现</li></ul></li><li>循环引用<ul><li>Other C Flags 修改为如下 :-fsanitize-coverage=func,trace-pc-guard</li></ul></li><li>swift 工程 / 混编工程<pre><code>* Other Swift Flags , 添加两条配置即可 : -sanitize-coverage=func -sanitize=undefined</code></pre></li></ul><h3 id="压缩资源图片"><a href="#压缩资源图片" class="headerlink" title="压缩资源图片"></a>压缩资源图片</h3><p>压缩图片为什么能加快启动速度呢？因为启动的时候大大小小的图片加载个十来二十个是很正常的，图片小了，IO操作量就小了，启动当然就会快了。</p><p>事实上，Xcode在编译App的时候，已经自动把需要打包到App里的资源图片压缩过一遍了。然而Xcode的压缩会相对比较保守。</p><p>解决各种矛盾的方法就是要找出一种相当靠谱的压缩方法，而且最好是基本无损的，而且压缩率还要特别高，至少要比Xcode自动压缩的效果要更好才有意义。经过各种试验，最后发现唯一可靠的压缩算法是TinyPNG</p><h3 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h3><blockquote><p>在看 [UIImage imageNamed:] 文档时发现一句话<br>In iOS 9 and later, this method is thread safe.</p></blockquote><p>看到它之后立刻想到，能否在进程启动早期通过子线程预先加载首页图片。为什么在早期呢？通过 Instruments 分析可看到在支付宝启动早期，CPU 占用是不那么满的，为了让启动过程中充分利用 CPU，就尽量在早期启动子线程。</p><blockquote><p>问题与解决</p></blockquote><p>在优化之后，也伴随而来一些不稳定的问题：</p><p>App 启动会有小概率的 Crash。</p><p>根据分析，我们决定把这段代码移到 AppDelegate 的 didFinishLaunching 中，并且增加开关。</p><p>iPhone7 不需要预加载</p><p>在 iPhone7 设备出来后，我们发现 iPhone7 的启动性能反而不如 iPhone6S。分析后发现，在性能更好的 iPhone7 上，由于启动很快，导致子线程的 imageNamed 与 主线程的 imageNamed 相互穿插调用，而 imageNamed 内部的线程安全锁的粒度很小，导致锁的消耗过大。</p><h3 id="启动任务分类"><a href="#启动任务分类" class="headerlink" title="启动任务分类"></a>启动任务分类</h3><p>App启动中的任务可以简单分为下面几类：</p><ul><li>必须最早在主线程初始化的任务</li><li>可以子线程执行的任务</li><li>可以与2中的任务并行执行的主线程任务</li><li>可以在首页显示后子线程执行的任务</li></ul><h3 id="Background-Fetch-简介"><a href="#Background-Fetch-简介" class="headerlink" title="Background Fetch 简介"></a>Background Fetch 简介</h3><p>Background Fetch 类似一种智能的轮询机制，系统会根据用户的使用习惯进行适应，在用户真正启动应用之前，触发后台更新，来获取数据并且更新页面。</p><p>针对这样的策略，大家可能会有疑虑，这种频繁的后台启动会不会增加耗电量？ 当然不会，系统会根据设备的电量和数据使用情况来调用频率控制，避免在非活跃时间频繁的获取数据。而且，进程启动后后存活的时间很短，多数情况下会立即 suspend</p><blockquote><p>实践</p></blockquote><ul><li>Info.plist 中 UIBackgroundModes 节点配置 fetch 数值</li><li>didFinishLaunching 时配置[[UIApplication sharedApplication] setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];<br>这一步配置的minimum interval，单位是秒，只是给系统的建议，系统并不会按照给定的时间间隔按规律的唤醒进程。</li><li>实现下面的回调，并调用 completionHandler- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</li></ul><p>由于 Background Fetch 机制是为了让App在后台拉取准备数据，但支付宝只是为了实现”秒起“。调用 completionHandler 后系统将把 App 进程挂起。且系统必须在30秒内调用 completionHandler，否则进程将被杀死。此外根据文档，系统会根据后台调用 completionHandler 的时间来决定后台唤起App的频率。因此，认为可以“伪造“1秒的延迟时间，即1秒后调用 completionHandler。类似下面的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performFetchWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        completionHandler(<span class="built_in">UIBackgroundFetchResultNewData</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进程快速挂起导致 Sync 成功率下降<ul><li>灰度期间，开发同学发现同步服务 Sync 成功率下降很多，找来找去发现原因：由于进程唤醒后，网络长连接线程被激活并马上建立长连接，而1秒后调用completionHandler，进程又被挂起。服务器端的sync消息则发送超时。</li></ul></li><li>进程频繁挂起、唤醒导致网络建连次数增加<ul><li>系统预测用户使用 App 的时间，并在用户实现 App 前唤醒 App，给予 App 后台准备数据的机会。再加上预测的准确性问题，这样进程被唤醒的次数远大于用户使用的次数。进程唤醒后，网络长连接会立即建立。因此导致网络建连次数大增，甚至翻倍。</li></ul></li><li>由于进程挂起，导致定时器、延迟调用等时间“与预想的时间不同”<ul><li>例如，一个间隔间隔时间为 60 秒的定时器，由于进程挂起时间超过 60 秒，则下次进程唤醒时会立刻触发到时。（延迟调用 dispatch_after 等类似）。对于进程自身来说，可能定时器有点不正常，需要排查所有的定时器逻辑，是否会因为挂起导致“业务层面的异常”。</li></ul></li><li>获取时间戳<ul><li>由于进程挂起，导致前后获取的时间戳间隔很大</li></ul></li></ul><p>为解决以上遇到的、以及预测到的问题，经过讨论，决定在 Background Fetch 后台唤醒的时候，不建立长连接。</p><blockquote><p>解决</p></blockquote><ul><li>延后 10 秒调用 completionHandler。<ul><li>后台唤醒存在两种情况：进程从无到有，进程从挂起到恢复。前者需要有充足的时间完成 App 的后台冷启动过程，因此定义了 10 秒的时间。</li></ul></li><li>后台 Background Fetch 的时间内不建立长连接。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;启动过程&quot;&gt;&lt;a href=&quot;#启动过程&quot; class=&quot;headerlink&quot; title=&quot;启动过程&quot;&gt;&lt;/a&gt;启动过程&lt;/h3&gt;&lt;p&gt;iOS应用的启动可分为pre-main阶段和main()阶段，pre-main阶段为main函数执行之前所做的操作，main阶段为main函数到首页展示阶段。其中系统做的事情为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;premain&lt;ul&gt;
&lt;li&gt;加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）&lt;/li&gt;
&lt;li&gt;加载动态链接库加载器dyld（dynamic loader）&lt;/li&gt;
&lt;li&gt;定位内部、外部指针引用，例如字符串、函数等&lt;/li&gt;
&lt;li&gt;加载类扩展（Category）中的方法&lt;/li&gt;
&lt;li&gt;C++静态对象加载、调用ObjC的 +load 函数&lt;/li&gt;
&lt;li&gt;执行声明为&lt;strong&gt;attribute&lt;/strong&gt;((constructor))的C函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;main&lt;ul&gt;
&lt;li&gt;调用main()&lt;/li&gt;
&lt;li&gt;调用UIApplicationMain()&lt;/li&gt;
&lt;li&gt;调用applicationWillFinishLaunching&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="iOS开发进阶" scheme="https://developerdoc.com/categories/iOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>InjectionIII 使用原理介绍</title>
    <link href="https://developerdoc.com/essay/injectIII/"/>
    <id>https://developerdoc.com/essay/injectIII/</id>
    <published>2021-01-04T03:42:18.000Z</published>
    <updated>2021-01-16T08:34:21.473Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 APP来进行的。所以项目代码量越大，编译时间就越长。虽然我们可以将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每次编译都还是需要重启App，需要再走一遍调试流程。</p></blockquote><p>幸运的是，John Holdsworth 开发了一个叫做 InjectionIII 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。</p><a id="more"></a><h3 id="InjectionIII下载使用"><a href="#InjectionIII下载使用" class="headerlink" title="InjectionIII下载使用"></a>InjectionIII下载使用</h3><h4 id="下载InjectionIII"><a href="#下载InjectionIII" class="headerlink" title="下载InjectionIII"></a>下载InjectionIII</h4><p>如果仅用于使用的话在mac appStore下载就可以了：</p><p><img src="/res/InjectionIII/1.png" width="50%"></p><h4 id="在项目中添加代码"><a href="#在项目中添加代码" class="headerlink" title="在项目中添加代码"></a>在项目中添加代码</h4><p>在 - (BOOL)application:(UIApplication <em>)application willFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 方法里添加如下代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    [[<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@"/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle"</span>] load;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//成功时控制台会打印：</span><br><span class="line">💉 Injection connected 👍</span><br><span class="line"></span><br><span class="line">//没有运行InjectionIII 控制台会打印</span><br><span class="line">💉 Injection loaded but could not connect. Is InjectionIII.app running?</span><br></pre></td></tr></table></figure><h4 id="运行InjectionIII-并选择项目目录"><a href="#运行InjectionIII-并选择项目目录" class="headerlink" title="运行InjectionIII 并选择项目目录"></a>运行InjectionIII 并选择项目目录</h4><p>使用的时候会让你选择项目目录，InjectionIII 就是监控的这个目录，里面文件变动会有通知。</p><p><img src="/res/InjectionIII/2.png" width="50%"></p><h4 id="使用InjectionIII-并测试几种场景"><a href="#使用InjectionIII-并测试几种场景" class="headerlink" title="使用InjectionIII 并测试几种场景:"></a>使用InjectionIII 并测试几种场景:</h4><p>你可以在在对应的VC控制器中实现 - (void)injected 编写代码，写完后，command+s 保存切执行代码，Injjection就开始编译修改过的文件为动态库，然后我们在Injected方法内做UI reload工作，即可重绘UI。</p><p>也可以直接修改你想测试的VC代码，然后退出重进即可重载VC。</p><p>测试一下四种场景： </p><ul><li>修改方法</li><li>新增方法</li><li>新增属性</li><li>新增类</li></ul><p>其中 修改方法/新增方法/新增类 都可以动态修改</p><p><img src="/res/InjectionIII/3.gif" alt></p><p>而当动态添加属性时则会报错</p><p><img src="/res/InjectionIII/4.png" width="50%"></p><p>我们很自然的想到因为不能向已有类动态添加属性，但是InjectionIII到底做了什么呢？让我们带着疑问来看看InjectionIII的原理</p><blockquote><p>没有看到效果的问题?</p></blockquote><ul><li>确认 Injection 监听的目录和 Xcode 项目目录是否一致。</li><li>再看下有没有保存成功，也就是针筒的颜色由绿色变成红色。</li><li>确认上面那句话有没有打印，也就是说有没有真的运行这个工具。</li><li>如果修改的是 cell / item 上面的内容，需要上下滚动才能看到效果。</li><li>如果修改的是一个普通页面的内容，最好是退出这个页面，再进入这个页面。</li><li>确认 Xcode 的版本和启动时添加的代码是否匹配，Xcode10 需要 iOSInjection10.bundle 才能生效</li></ul><h3 id="InjectionIII原理"><a href="#InjectionIII原理" class="headerlink" title="InjectionIII原理"></a>InjectionIII原理</h3><h4 id="大致流程梳理"><a href="#大致流程梳理" class="headerlink" title="大致流程梳理"></a>大致流程梳理</h4><p><img src="/res/InjectionIII/8.png" alt></p><ul><li>InjectionIII 分为server 和 client部分，</li><li>client部分在你的项目启动的时候会作为 bundle load 进去，server部分在Mac App那边，server 和 client 都会在后台发送和监听 Socket 消息，实现逻辑分别在 InjectionServer.mm 和 InjectionClient.mm 里的 runInBackground 方法里面。</li><li>InjectionIII 会监听源代码文件的变化，如果文件被改动了，server 就会通过 Socket 通知 client 进行 rebuildClass 重新对该文件进行编译，打包成动态库，也就是 .dylib 文件。</li><li>然后通过 dlopen 把动态库文件载入运行的 App 里，接下来 dlsym 会得到动态库的符号地址，然后就可以处理类的替换工作。</li><li>当类的方法被替换后，我们就可以开始重新绘制界面了。整个过程无需重新编译和重载 App，使用动态库方式极速调试的目的就达成了。</li></ul><p>这里有一点需要说明一下，模拟器下iOS可加载Mac任意文件，而真机设备如果加载动态库，只能加载App.content目录下的，换句话说，这个工具只支持模拟器。</p><h4 id="编译InjectionIII工程"><a href="#编译InjectionIII工程" class="headerlink" title="编译InjectionIII工程"></a>编译InjectionIII工程</h4><p>要了解一个工具，最好的方式当然直接看源码了。InjectionIII 的源代码链接如下：<a href="https://github.com/johnno1962/InjectionIII" target="_blank" rel="noopener">https://github.com/johnno1962/InjectionIII</a>，可以下载下来对着源码分析。</p><p><img src="/res/InjectionIII/5.png" width="50%"></p><p>下载/clone InjectionIII 主工程代码，子工程 remote SwiftTrace XprobePlugin 也一并点进链接下载到对应目录。</p><p>然后解决下证书问题 ，直接勾选 Automatically manage signing，同时选择一下团队，注意 InjectionIII 和 InjectionBundle 两个 target 都要选择好。就可以愉快的编译了~</p><p>最后说一下，如果我们要用源码分析，当然要将源码编译起来，打断点看流程。这样的话就在 willFinishLaunchingWithOptions 里面加载的路径就要相应修改了，我这边是这样的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    [[<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@"/Users/suntongsheng/Library/Developer/Xcode/DerivedData/InjectionIII-aornltecfreqqwezgayglgjnnckg/Build/Products/Debug/InjectionIII.app/Contents/Resources/iOSInjection.bundle"</span>] load];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="一、初始化Server和Client并通过Socket建立链接"><a href="#一、初始化Server和Client并通过Socket建立链接" class="headerlink" title="一、初始化Server和Client并通过Socket建立链接"></a>一、初始化Server和Client并通过Socket建立链接</h5><p><code>Server端 即是InjectionIII工程中的Target-InjectionIII</code> 初始化调用 SimpleSocket 的 startServer 方法并传入端口号 在后台运行开启服务端socket 服务用于和客户端的通讯，并运行 InjectionServer 类的 runInBackground 方法进行初始化操作，弹出选择项目目录对话框，如果之前选择过的话就不会弹出。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ (void)startServer:(<span class="type">NSString</span> *)address &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">" %s %p "</span>,__func__,<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:@selector(runServer:) withObject:address];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)runServer:(<span class="type">NSString</span> *)address &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="class">    [<span class="title">self</span> <span class="title">parseV4Address</span>:<span class="title">address</span> <span class="title">into</span>:&amp;<span class="title">serverAddr</span>];</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">serverSocket</span> = [<span class="title">self</span> <span class="title">newSocket</span>:<span class="title">serverAddr</span>.<span class="title">ss_family</span>];</span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">serverSocket</span> &lt; 0)</span></span><br><span class="line"><span class="class">        <span class="title">return</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">bind</span>(<span class="title">serverSocket</span>, (<span class="title">struct</span> <span class="title">sockaddr</span> *)&amp;<span class="title">serverAddr</span>, <span class="title">serverAddr</span>.<span class="title">ss_len</span>) &lt; 0)</span></span><br><span class="line"><span class="class">        [<span class="title">self</span> <span class="title">error</span>:@"<span class="title">Could</span> <span class="title">not</span> <span class="title">bind</span> <span class="title">service</span> <span class="title">socket</span>: %<span class="title">s</span>"];</span></span><br><span class="line"><span class="class">    <span class="title">else</span> <span class="title">if</span> (<span class="title">listen</span>(<span class="title">serverSocket</span>, 5) &lt; 0)</span></span><br><span class="line"><span class="class">        [<span class="title">self</span> <span class="title">error</span>:@"<span class="title">Service</span> <span class="title">socket</span> <span class="title">would</span> <span class="title">not</span> <span class="title">listen</span>: %<span class="title">s</span>"];</span></span><br><span class="line"><span class="class">    <span class="title">else</span></span></span><br><span class="line"><span class="class">        <span class="title">while</span> (<span class="title">TRUE</span>) </span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class">            <span class="title">socklen_t</span> <span class="title">addrLen</span> = <span class="title">sizeof</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">            <span class="title">int</span> <span class="title">clientSocket</span> = <span class="title">accept</span>(<span class="title">serverSocket</span>, (<span class="title">struct</span> <span class="title">sockaddr</span> *)&amp;<span class="title">clientAddr</span>, &amp;<span class="title">addrLen</span>);</span></span><br><span class="line"><span class="class">            <span class="title">if</span> (<span class="title">clientSocket</span> &gt; 0) </span>&#123;</span><br><span class="line">                @autoreleasepool &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">v4Addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)&amp;<span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class">                    <span class="title">NSLog</span>(@"<span class="title">Connection</span> <span class="title">from</span> %<span class="title">s</span>:%<span class="title">d</span>\<span class="title">n</span>",</span></span><br><span class="line"><span class="class">                          <span class="title">inet_ntoa</span>(<span class="title">v4Addr</span>-&gt;<span class="title">sin_addr</span>), <span class="title">ntohs</span>(<span class="title">v4Addr</span>-&gt;<span class="title">sin_port</span>));</span></span><br><span class="line"><span class="class">                    [[[<span class="title">self</span> <span class="title">alloc</span>] <span class="title">initSocket</span>:<span class="title">clientSocket</span>] <span class="title">run</span>];</span></span><br><span class="line"><span class="class">                &#125;</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            <span class="title">else</span></span></span><br><span class="line"><span class="class">                [<span class="title">NSThread</span> <span class="title">sleepForTimeInterval</span>:.5];</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p><code>Client端 即是InjectionIII工程中的Target-InjectionBundle</code> 会在我们的demo工程中加载，项目启动以后可以在控制台执行 image list -o -f 查看加载的动态库，可以看到 iOSInjection.bundle 确实已经以动态库的形式加载进来了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image list -o -f</span><br><span class="line"></span><br><span class="line">[377] 0x0000000102b13000 /Users/suntongsheng/Library/Developer/Xcode/DerivedData/InjectionIII-aornltecfreqqwezgayglgjnnckg/Build/Products/Debug/InjectionIII.app/Contents/Resources/iOSInjection.bundle/iOSInjection</span><br></pre></td></tr></table></figure><p>其初始化在InjectionClient 类的 +load 方法。在 InjectionClient 类的 +load 方法里会调用其 connectTo 方法传入对应的端口号来连接服务端的 socket 服务用于通讯，并运行其runInBackground 方法进行初始化操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">" %s %p "</span>,__func__,<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// connect to InjectionIII.app using socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">InjectionClient</span> *client = [<span class="keyword">self</span> connectTo:<span class="type">INJECTION_ADDRESS</span>])</span><br><span class="line">        [client run];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">"💉 Injection loaded but could not connect. Is InjectionIII.app running?\n"</span>);</span><br><span class="line">#ifndef __IPHONE_OS_VERSION_MIN_REQUIRED</span><br><span class="line">        printf(<span class="string">"⚠️ For a macOS app you need to turn off the sandbox to connect. ⚠️\n"</span>);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectionIII 运行以后会在后台监听 socket 消息，每隔0.5秒检查一次是否有客户端连接过来，等我们app 启动以后加载了 iOSInjection.bundle，就会启动 client 跟 server 建立连接，然后就可以发送消息了。</p><h5 id="二、监听文件修改"><a href="#二、监听文件修改" class="headerlink" title="二、监听文件修改"></a>二、监听文件修改</h5><p>当我们在调试工程中修改了代码并保存后，FileWatcher 会立即收到文件改变的回调，FileWatcher 使用 Mac OS 上的 FSEvents 框架实现，<code>FileWatcher</code> 中通过 <code>filesChanged</code> 告诉回调方法即<code>InjectionServer</code>中的<code>fileChangeHandler</code>方法</p><p><img src="/res/InjectionIII/6.png" alt></p><p>在<code>InjectionServer</code>方法中会判断是否为自动注入，如果是则执行 injectPending 方法，通过 socket 对客户端下发InjectionInject 代码注入命令并传入需要代码注入的文件名物理路径。如果不是自动注入那么就在控制台输出“xx文件已保存，输入ctrl-=进行注入”告诉我们手动注入的触发方式。</p><h5 id="三、重新编译、打包动态库和签名"><a href="#三、重新编译、打包动态库和签名" class="headerlink" title="三、重新编译、打包动态库和签名"></a>三、重新编译、打包动态库和签名</h5><p>文件修改后若是自动注入<code>injectPending</code>方法会调用 <code>recompileAndInject</code>方法实际上会调用 SwiftEval 单例的 rebuildClass 方法来进行修改文件的重新编译、打包动态库和签名：</p><p>首先根据修改的类文件名在 Injection App 的沙盒路径生成对应的编译脚本，脚本命名为eval+数字，数字以100为基数，每次递增1。脚本生成调用方法如下图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">injectionNumber += <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> tmpfile = <span class="type">URL</span>(fileURLWithPath: tmpDir)</span><br><span class="line">    .appendingPathComponent(<span class="string">"eval\(injectionNumber)"</span>).path</span><br><span class="line"><span class="keyword">let</span> logfile = <span class="string">"\(tmpfile).log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">var</span> (compileCommand, sourceFile) = <span class="keyword">try</span> compileByClass[classNameOrFile] ??</span><br><span class="line">    findCompileCommand(logsDir: logsDir, classNameOrFile: classNameOrFile, tmpfile: tmpfile) ??</span><br><span class="line">    <span class="type">SwiftEval</span>.longTermCache[classNameOrFile].flatMap(&#123; ($<span class="number">0</span> <span class="keyword">as</span>! <span class="type">String</span>, classNameOrFile) &#125;) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> evalError(<span class="string">"""</span></span><br><span class="line"><span class="string">        Could not locate compile command for \(classNameOrFile).</span></span><br><span class="line"><span class="string">        This could be due to one of the following:</span></span><br><span class="line"><span class="string">        1. Injection does not work with Whole Module Optimization.</span></span><br><span class="line"><span class="string">        2. There are restrictions on characters allowed in paths.</span></span><br><span class="line"><span class="string">        3. File paths in the simulator paths are case sensitive.</span></span><br><span class="line"><span class="string">        Try a build clean then rebuild to make logs available or</span></span><br><span class="line"><span class="string">        consult: "\(commandFile)".</span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 findCompileCommand 为生成 sh 脚本的具体方法，主要是针对当前修改类设置对应的编译脚本命令。由于脚本太长，这里就不贴上来了，有兴趣的同学可以自行查看。</p><p>使用改动类的编译脚本可以生成其.o文件，具体如下图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> toolchain = ((<span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: <span class="string">"\\s*(\\S+?\\.xctoolchain)"</span>, options: []))</span><br><span class="line">    .firstMatch(<span class="keyword">in</span>: compileCommand, options: [], range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, compileCommand.utf16.<span class="built_in">count</span>))?</span><br><span class="line">    .range(at: <span class="number">1</span>)).flatMap &#123; compileCommand[$<span class="number">0</span>] &#125; ?? <span class="string">"\(xcodeDev)/Toolchains/XcodeDefault.xctoolchain"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> osSpecific: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> compileCommand.<span class="built_in">contains</span>(<span class="string">"iPhoneSimulator.platform"</span>) &#123;</span><br><span class="line">    osSpecific = <span class="string">"-isysroot \(xcodeDev)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk -mios-simulator-version-min=9.0 -L\(toolchain)/usr/lib/swift/iphonesimulator -undefined dynamic_lookup"</span><span class="comment">// -Xlinker -bundle_loader -Xlinker \"\(Bundle.main.executablePath!)\""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里针对模拟器环境进行脚本配置，配置完成后使用 clang 命令把对应的.o文件生成相同名字的动态库，具体如下图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> shell(command: <span class="string">"""</span></span><br><span class="line"><span class="string">    \(xcodeDev)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch "\(arch)" -bundle \(osSpecific) -dead_strip -Xlinker -objc_abi_version -Xlinker 2 -fobjc-arc -fprofile-instr-generate \"\(tmpfile).o\" -L "\(frameworks)" -F "\(frameworks)" -rpath "\(frameworks)" -o \"\(tmpfile).dylib\" &gt;&gt;\"\(logfile)\" 2&gt;&amp;1</span></span><br><span class="line"><span class="string">    """</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> evalError(<span class="string">"Link failed, check \(commandFile)\n\(try! String(contentsOfFile: logfile))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程中产生的产物如下：</p><p><img src="/res/InjectionIII/7.png" width="50%"></p><p>苹果会对加载的动态库进行签名校验，所以下一步需要对这个动态库签名,由于签名需要使用 Xcode 环境，所以客户端是无法进行的，只能通过 socket 告诉服务端来进行操作。当服务端收到 InjectionSign 签名命令后会调用 SignerService 类的 codesignDylib 来对相应的动态库进行签名操作</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@implementation <span class="type">SignerService</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)codesignDylib:(<span class="type">NSString</span> *)dylib identity:(<span class="type">NSString</span> *)identity &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">NSString</span> *adhocSign = @<span class="string">"-"</span>;</span><br><span class="line">    <span class="type">NSString</span> *command = [<span class="type">NSString</span> stringWithFormat:@<span class="string">""</span></span><br><span class="line">                         <span class="string">"(export CODESIGN_ALLOCATE=/Applications/Xcode.app"</span></span><br><span class="line">                         <span class="string">"/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate; "</span></span><br><span class="line">                         <span class="string">"if /usr/bin/file \"%@\" | grep ' bundle ' &gt;/dev/null;"</span></span><br><span class="line">                         <span class="string">"then /usr/bin/codesign --force -s \"%@\" \"%@\";"</span></span><br><span class="line">                         <span class="string">"else exit 1; fi)"</span>,</span><br><span class="line">                         dylib, identity ?: adhocSign, dylib];</span><br><span class="line">    <span class="keyword">return</span> system(command.<span class="type">UTF8String</span>) &gt;&gt; <span class="number">8</span> == <span class="type">EXIT_SUCCESS</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)runInBackground &#123;</span><br><span class="line">    char __unused skip, buffer[<span class="number">1000</span>];</span><br><span class="line">    buffer[read(clientSocket, buffer, <span class="built_in">sizeof</span> buffer-<span class="number">1</span>)] = '\<span class="number">000</span>';</span><br><span class="line">    <span class="type">NSString</span> *path = [[<span class="type">NSString</span> stringWithUTF8String:buffer] componentsSeparatedByString:@<span class="string">" "</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">codesignDylib</span>:<span class="title">path</span> <span class="title">identity</span>:<span class="title">nil</span>]) </span>&#123;</span><br><span class="line">        snprintf(buffer, <span class="built_in">sizeof</span> buffer, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>);</span><br><span class="line">        write(clientSocket, buffer, strlen(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>至此修改文件的重新编译、打包动态库和签名操作就全部完成了，接下来就是我们最熟悉的加载动态库进行方法替换了。</p><h5 id="四、加载动态库进行方法替换"><a href="#四、加载动态库进行方法替换" class="headerlink" title="四、加载动态库进行方法替换"></a>四、加载动态库进行方法替换</h5><p>在生成动态库后 先使用dlopen方法把对应的动态库加载到当前运行的调试工程的进程中 并拿到返回的指针dl，然后使用dlsym拿到动态库的符号地址。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">loadAndInject</span><span class="params">(tmpfile: String, oldClass: AnyClass? = <span class="literal">nil</span>)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyClass</span>] &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> dl = dlopen(<span class="string">"\(tmpfile).dylib"</span>, <span class="type">RTLD_NOW</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> oldClass != <span class="literal">nil</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// grep out symbols for classes being injected from object file</span></span><br><span class="line">        <span class="comment">//正常流程会走到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> extractClasses(dl: dl, tmpfile: tmpfile)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overridden by SwiftInjectionEval subclass for injection</span></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">extractClasses</span><span class="params">(dl: UnsafeMutableRawPointer,</span></span></span><br><span class="line"><span class="function"><span class="params">                          tmpfile: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyClass</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> shell(command: <span class="string">"""</span></span><br><span class="line"><span class="string">        \(xcodeDev)/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm \(tmpfile).o | grep -E ' S _OBJC_CLASS_\\$_| _(_T0|\\$S|\\$s).*CN$' | awk '&#123;print $3&#125;' &gt;\(tmpfile).classes</span></span><br><span class="line"><span class="string">        """</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> evalError(<span class="string">"Could not list class symbols"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">var</span> classSymbolNames = (<span class="keyword">try</span>? <span class="type">String</span>(contentsOfFile: <span class="string">"\(tmpfile).classes"</span>))?.components(separatedBy: <span class="string">"\n"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> evalError(<span class="string">"Could not load class symbol list"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    classSymbolNames.removeLast()</span><br><span class="line">    <span class="keyword">let</span> result =  <span class="type">Set</span>(classSymbolNames.compactMap &#123;</span><br><span class="line">        dlsym(dl, <span class="type">String</span>($<span class="number">0</span>.<span class="built_in">dropFirst</span>())) &#125;)</span><br><span class="line">        .<span class="built_in">map</span> &#123; <span class="built_in">unsafeBitCast</span>($<span class="number">0</span>, to: <span class="type">AnyClass</span>.<span class="keyword">self</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，dlopen 会把 tmpfile 动态库文件载入运行的 App 里，返回指针 dl。回到测试工程使用 <code>lldb image list -o -f</code> 确实看到eval101.dylib 被加载进来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[408] 0x0000000111bfe000 /var/folders/tw/nl7v5_cd577bbdzfgxjy63bw0000gn/T/com.johnholdsworth.InjectionIII/eval101.dylib</span><br></pre></td></tr></table></figure><p>接下来， dlsym 会得到 tmpfile 动态库的符号地址，然后就可以处理类的替换工作了。在拿到新类的符号地址后，我们把新类里所有的类方法和实例方法都替换到对应的旧类中，使用的是SwiftInjection 的 injection 方法，通过OC runtime 的class_replaceMethod把整个类的实现方法都替换了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">injection</span><span class="params">(swizzle newClass: AnyClass?, onto oldClass: AnyClass?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> methodCount: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> methods = class_copyMethodList(newClass, &amp;methodCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="type">Int</span>(methodCount) &#123;</span><br><span class="line">            <span class="keyword">let</span> method = method_getName(methods[i])</span><br><span class="line">            <span class="keyword">var</span> replacement = method_getImplementation(methods[i])</span><br><span class="line">            <span class="keyword">if</span> traceInjection, <span class="keyword">let</span> tracer = <span class="type">SwiftTrace</span></span><br><span class="line">                .trace(name: injectedPrefix+<span class="type">NSStringFromSelector</span>(method),</span><br><span class="line">                objcMethod: methods[i], objcClass: newClass,</span><br><span class="line">                original: autoBitCast(replacement)) &#123;</span><br><span class="line">                replacement = autoBitCast(tracer)</span><br><span class="line">            &#125;</span><br><span class="line">            class_replaceMethod(oldClass, method, replacement,</span><br><span class="line">                                method_getTypeEncoding(methods[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 APP来进行的。所以项目代码量越大，编译时间就越长。虽然我们可以将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每次编译都还是需要重启App，需要再走一遍调试流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;幸运的是，John Holdsworth 开发了一个叫做 InjectionIII 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发进阶" scheme="https://developerdoc.com/categories/iOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控4 网络监控-NSURLProtocol</title>
    <link href="https://developerdoc.com/essay/APM/iOSAPM4/"/>
    <id>https://developerdoc.com/essay/APM/iOSAPM4/</id>
    <published>2020-10-15T14:36:51.000Z</published>
    <updated>2020-10-20T11:25:37.966Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS中苹果提供了NSURLConnection、NSURLSession等优秀的网路接口供我们来调用，开源社区也有很多的开源库，如之前的ASIHttpRequest 现在的AFNetworking和Alamofire，我们接下来介绍的NSURLProtocol，都可以监控到这些开源库的网络请求。</p><h3 id="NSURLProtocol"><a href="#NSURLProtocol" class="headerlink" title="NSURLProtocol"></a>NSURLProtocol</h3><p>NSURLProtocol是iOS网络加载系统中很强的一部分，它其实是一个抽象类，我们可以通过继承子类化来拦截APP中的网络请求。</p><p>举几个例子：</p><ul><li>我们的APP内的所有请求都需要增加公共的头，像这种我们就可以直接通过NSURLProtocol来实现，当然实现的方式有很多种</li><li>我们需要将APP某个API进行一些访问的统计</li><li>我们需要统计APP内的网络请求失败率</li></ul><p>等等，都可以用到 NSURLProtocol是一个抽象类，我们需要子类化才能实现网络请求拦截。</p><a id="more"></a><h3 id="新建-NSURLProtocol的子类"><a href="#新建-NSURLProtocol的子类" class="headerlink" title="新建 NSURLProtocol的子类"></a>新建 NSURLProtocol的子类</h3><p>新建 NSURLProtocol的子类 并且需要重写一些方法 </p><h3 id="重写-can​Init​With​Request"><a href="#重写-can​Init​With​Request" class="headerlink" title="重写 can​Init​With​Request :"></a>重写 <code>can​Init​With​Request</code> :</h3><p>我们需要告诉它哪些网络请求是需要我们拦截的，这个是通过方法can​Init​With​Request:​来实现的，比如我们现在需要拦截全部的HTTP和HTTPS请求，那么这个逻辑我们就可以在can​Init​With​Request:​中来定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 需要控制的请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param request 此次请求</span></span><br><span class="line"><span class="comment"> @return 是否需要监控</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![request.URL.scheme isEqualToString:@<span class="string">"http"</span>] &amp;&amp;</span><br><span class="line">        ![request.URL.scheme isEqualToString:@<span class="string">"https"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写-canonicalRequestForRequest"><a href="#重写-canonicalRequestForRequest" class="headerlink" title="重写 canonicalRequestForRequest:"></a>重写 <code>canonicalRequestForRequest:</code></h3><p>我们可以自定义当前的请求request，通过重写 canonicalRequestForRequest: 来实现。当然如果不需要自定义，直接返回就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 设置我们自己的自定义请求</span></span><br><span class="line"><span class="comment"> 可以在这里统一加上头之类的</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param request 应用的此次请求</span></span><br><span class="line"><span class="comment"> @return 我们自定义的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们通过这两个方法，就已经能够拦截住iOS的网络请求了 </p><h3 id="can​Init​With​Request-与-canonicalRequestForRequest"><a href="#can​Init​With​Request-与-canonicalRequestForRequest" class="headerlink" title="can​Init​With​Request: 与 canonicalRequestForRequest"></a><code>can​Init​With​Request:</code> 与 <code>canonicalRequestForRequest</code></h3><p>在我们上层业务调用网络请求的时候，首先会调用我们的can​Init​With​Request:方法，询问是否对该请求进行处理，接着会调用我们的canonicalRequestForRequest:来自定义一个request，接着又会去调用can​Init​With​Request:询问自定义的request是否需要处理，我们又返回YES，然后又去调用了canonicalRequestForRequest:，这样，就形成了一个死循环了，这肯定是我们不希望看到的。</p><p>有个处理方法，我们可以对每个处理过的request进行标记，在判断如果这个request已经处理过了，那么我们就不再进行处理，这样就有效避免了死循环</p><p>在我们自定义request的方法中，我们来设置处理标志</p><ul><li><p>(NSURLRequest <em>)canonicalRequestForRequest:(NSURLRequest </em>)request {<br>  NSMutableURLRequest *mutableReqeust = [request mutableCopy];<br>  [NSURLProtocol setProperty:@YES</p><pre><code>   forKey:PPSHTTPinRequest:mutableReqeust];</code></pre><p>  return [mutableReqeust copy];<br>}<br>然后在我们的询问处理方法中，通过判断是否有处理过的标志，来进行拦截</p></li><li><p>(BOOL)canInitWithRequest:(NSURLRequest *)request {</p><p>  if (![request.URL.scheme isEqualToString:@”http”] &amp;&amp;</p><pre><code>![request.URL.scheme isEqualToString:@&quot;https&quot;]) {return NO;</code></pre><p>  }<br>  //如果是已经拦截过的  就放行<br>  if ([NSURLProtocol propertyForKey:PPSHTTP inRequest:request] ) {</p><pre><code>return NO;</code></pre><p>  }<br>  return YES;<br>}<br>这样，我们就避免了死循环</p></li></ul><h3 id="重写-startLoading-和-stopLoading"><a href="#重写-startLoading-和-stopLoading" class="headerlink" title="重写 startLoading 和 stopLoading"></a>重写 <code>startLoading</code> 和 <code>stopLoading</code></h3><p>接下来，就是需要将这个request发送出去了，因为如果我们不处理这个request请求，系统会自动发出这个网络请求，但是当我们处理了这个请求，就需要我们手动来进行发送了。</p><p>我们要手动发送这个网络请求，需要重写startLoading方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    NSURLRequest *request = [[self class] canonicalRequestForRequest:self.request];</span><br><span class="line">    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES];</span><br><span class="line">    self.pps_request = self.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下上面的代码，因为我们拦截的这个请求是一个真实的请求，所以我们需要创建这样一个真实的网络请求，在第二行代码中，将我们自定义创建的request发了出了，第三行是为了保存当前的request，作为我们后面的处理对象。</p><p>当然，有start就有stop，stop就很简单了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [self.connection cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSURLConnectionDelegate-转发"><a href="#NSURLConnectionDelegate-转发" class="headerlink" title="NSURLConnectionDelegate 转发"></a>NSURLConnectionDelegate 转发</h3><p>在startLoading中，我们发起了一个NSURLConnection的请求，因为NSURLProtocol使我们自己定义的，所以我们需要将网络请求的一系列操作全部传递出去，不然上层就不知道当前网络的一个请求状态，那我们怎么将这个网络状态传到上层？每个protocol有一个NSURLProtocolClient实例，我们就通过这个client来传递。</p><p>传递一个网络请求，无外乎就是传递请求的一些过程，数据，结果等等。 发起了发起了一个NSURLConnection的请求，实现它的delegate就能够知道网络请求的一系列操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;</span><br><span class="line">    [self.client URLProtocol:self didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection&#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge&#123;</span><br><span class="line">    [self.client URLProtocol:self didReceiveAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection</span><br><span class="line">didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123;</span><br><span class="line">    [self.client URLProtocol:self didCancelAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDataDelegate</span></span><br><span class="line">-(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != nil) &#123;</span><br><span class="line">        self.pps_response = response;</span><br><span class="line">        [self.client URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</span><br><span class="line">    self.pps_response = response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    [self.client URLProtocol:self didLoadData:data];</span><br><span class="line">    [self.pps_data appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection</span><br><span class="line">                  willCacheResponse:(NSCachedURLResponse *)cachedResponse &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    [[self client] URLProtocolDidFinishLoading:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截网络"><a href="#拦截网络" class="headerlink" title="拦截网络"></a>拦截网络</h3><p>这样，基本的protocol就已经实现完成，那么怎样来拦截网络。我们需要将我们自定义的PPSURLProtocol通过NSURLProtocol注册到我们的网络加载系统中，告诉系统我们的网络请求处理类不再是默认的NSURLProtocol，而是我们自定义的PPSURLProtocol</p><p>。我们需要将我们自定义的PPSURLProtocol通过NSURLProtocol注册到我们的网络加载系统中，告诉系统我们的网络请求处理类不再是默认的NSURLProtocol，而是我们自定义的PPSURLProtocol</p><p>我们在PPSURLProtocol暴露两个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@interface PPSURLProtocol : NSURLProtocol</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)start;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>然后在我们的APP启动的时候，调用start，就可以监听到我们的网络请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    PPSURLSessionConfiguration *sessionConfiguration = [PPSURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    [NSURLProtocol registerClass:[PPSURLProtocol <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end &#123;</span><br><span class="line">    PPSURLSessionConfiguration *sessionConfiguration = [PPSURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    [NSURLProtocol unregisterClass:[PPSURLProtocol <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><p>上面的代码已经能够监控到绝大部分的网络请求，但是呢，有一个却是特殊的。</p><p>对于NSURLSession发起的网络请求，我们发现通过shared得到的session发起的网络请求都能够监听到，但是通过方法<em>sessionWithConfiguration:delegate:delegateQueue:</em>得到的session，我们是不能监听到的，原因就出在NSURLSessionConfiguration上，我们进到NSURLSessionConfiguration里面看一下，他有一个属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, copy) NSArray&lt;Class&gt; *protocolClasses;</span><br></pre></td></tr></table></figure><p>我们能够看出，这是一个NSURLProtocol数组，上面我们提到了，我们监控网络是通过注册NSURLProtocol来进行网络监控的，但是通过<em>sessionWithConfiguration:delegate:delegateQueue:得到的session，他的configuration中已经有一个NSURLProtocol，所以他不会走我们的protocol来，怎么解决这个问题呢？ 其实很简单，我们将NSURLSessionConfiguration的属性protocolClasses的get方法hook掉，通过返回我们自己的protocol，这样，我们就能够监控到通过sessionWithConfiguration:delegate:delegateQueue:</em>得到的session的网络请求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> hook 状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> BOOL isHookWorking = NO;</span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">NSURLSessionConfiguration</span> <span class="params">(FSAPM)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Life Cycle</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> swizzle method</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 避免使用私有 APIm，不过审</span></span><br><span class="line">        Class cls = NSClassFromString([NSString stringWithFormat:@<span class="string">"%@%@%@"</span>, @<span class="string">"__NSCFU"</span>, @<span class="string">"RLSessionCon"</span>, @<span class="string">"figuration"</span>]) ?: NSClassFromString(@<span class="string">"NSURLSessionConfiguration"</span>);</span><br><span class="line">        Method origMethod = class_getInstanceMethod(cls, @selector(protocolClasses));</span><br><span class="line">        Method replMethod = class_getInstanceMethod(self, @selector(fs_protocolClasses));</span><br><span class="line">        <span class="keyword">if</span> (origMethod &amp;&amp; replMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (class_addMethod(cls, @selector(protocolClasses), method_getImplementation(replMethod), method_getTypeEncoding(replMethod))) &#123;</span><br><span class="line">                class_replaceMethod(self, @selector(fs_protocolClasses), method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                method_exchangeImplementations(origMethod, replMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Public Method</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启 hook</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    isHookWorking = YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关闭 hook</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    isHookWorking = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private Method</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将 FSURLProtocol 对象放在首位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return NSArray&lt;NSURLProtocol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSArray&lt;Class&gt; *)fs_protocolClasses &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHookWorking) &#123;</span><br><span class="line">        <span class="keyword">return</span> [self fs_protocolClasses];</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *<span class="built_in">array</span> = [[self fs_protocolClasses] mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> @[[FSURLProtocol class]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">array</span> containsObject:[FSURLProtocol class]]) &#123;</span><br><span class="line">        [<span class="built_in">array</span> insertObject:[FSURLProtocol <span class="class"><span class="keyword">class</span>] <span class="title">atIndex</span>:</span><span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动的时候，将这个方法替换掉，在移除监听的时候，恢复之前的方法</p><p>至此，我们的监听就完成了，如果我们需要将这所有的监听存起来，在protocol的start或者stop中获取到request和response，将他们存储起来就行，需要说明的是，据苹果的官方说明，因为请求参数可能会很大，为了保证性能，请求参数是没有被拦截掉的，就是post的HTTPBody是没有的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS中苹果提供了NSURLConnection、NSURLSession等优秀的网路接口供我们来调用，开源社区也有很多的开源库，如之前的ASIHttpRequest 现在的AFNetworking和Alamofire，我们接下来介绍的NSURLProtocol，都可以监控到这些开源库的网络请求。&lt;/p&gt;
&lt;h3 id=&quot;NSURLProtocol&quot;&gt;&lt;a href=&quot;#NSURLProtocol&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol&quot;&gt;&lt;/a&gt;NSURLProtocol&lt;/h3&gt;&lt;p&gt;NSURLProtocol是iOS网络加载系统中很强的一部分，它其实是一个抽象类，我们可以通过继承子类化来拦截APP中的网络请求。&lt;/p&gt;
&lt;p&gt;举几个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们的APP内的所有请求都需要增加公共的头，像这种我们就可以直接通过NSURLProtocol来实现，当然实现的方式有很多种&lt;/li&gt;
&lt;li&gt;我们需要将APP某个API进行一些访问的统计&lt;/li&gt;
&lt;li&gt;我们需要统计APP内的网络请求失败率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，都可以用到 NSURLProtocol是一个抽象类，我们需要子类化才能实现网络请求拦截。&lt;/p&gt;
    
    </summary>
    
      <category term="APM" scheme="https://developerdoc.com/categories/APM/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控3 FPS与卡顿</title>
    <link href="https://developerdoc.com/essay/APM/iOSAPM3/"/>
    <id>https://developerdoc.com/essay/APM/iOSAPM3/</id>
    <published>2020-10-13T09:09:27.000Z</published>
    <updated>2020-10-13T11:48:49.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>FPS（Frames Per Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持 FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。</p><h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p><code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。</p><p>一旦 CADisplayLink 以特定的模式注册到 runloop 之后，每当屏幕需要刷新时，runloop 就会调用 CADisplayLink 绑定的 target 上的 selector，此时 target 可以读取到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>现阶段，常用的 FPS 监控几乎都是基于 CADisplayLink 实现的。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swift</span></span><br><span class="line">final <span class="class"><span class="keyword">class</span> <span class="title">FPSMonitor</span>:</span> NSObject &#123;</span><br><span class="line">    <span class="keyword">private</span> var timer: Timer?</span><br><span class="line">    <span class="keyword">private</span> var link: CADisplayLink?</span><br><span class="line">    <span class="keyword">private</span> var count: UInt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> var lastTime: TimeInterval = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    func enableMonitor() &#123;</span><br><span class="line">        <span class="keyword">if</span> link == nil &#123;</span><br><span class="line">            link = CADisplayLink(target: self, selector: #selector(fpsInfoCalculate(_:)))</span><br><span class="line">            link?.add(to: RunLoop.main, forMode: .common)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link?.isPaused = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func disableMonitor() &#123;</span><br><span class="line">        <span class="keyword">if</span> let link = link &#123;</span><br><span class="line">            link.isPaused = <span class="literal">true</span></span><br><span class="line">            link.invalidate()</span><br><span class="line">            self.link = nil</span><br><span class="line">            lastTime = <span class="number">0</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc</span><br><span class="line">    func fpsInfoCalculate(_ link: CADisplayLink) &#123;</span><br><span class="line">        <span class="keyword">if</span> lastTime == <span class="number">0</span> &#123;</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        let delta = link.timestamp - lastTime</span><br><span class="line">        <span class="keyword">if</span> delta &gt;= <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 间隔超过 1 秒</span></span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            let fps = Double(count) / delta</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            let intFps = Int(fps + <span class="number">0.5</span>)</span><br><span class="line">            print(<span class="string">"帧率：\(intFps)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CADisplayLink 实现的 FPS 在生产场景中只有指导意义，不能代表真实的 FPS。因为基于 CADisplayLink 实现的 FPS 无法完全检测出当前 Core Animation 的性能情况，只能检测出当前 RunLoop 的帧率。</p><h3 id="如何监控卡顿"><a href="#如何监控卡顿" class="headerlink" title="如何监控卡顿"></a>如何监控卡顿</h3><p>那怎么监控应用的卡顿情况？通常有以下两种方案</p><ul><li>FPS 监控：这是最容易想到的一种方案，如果帧率越高意味着界面越流畅，上文也给出了计算 FPS 的实现方式，通过一段连续的 FPS 计算丢帧率来衡量当前页面绘制的质量。<ul><li>FPS 的刷新频率非常快，并且容易发生抖动，因此直接通过比较 FPS 来侦测卡顿是比较困难的；此外，主线程卡顿监控也会发生抖动，所以微信读书团队给出一种综合方案，结合主线程监控、FPS 监控，以及 CPU 使用率等指标，作为判断卡顿的标准。Bugly 的卡顿检测也是基于这套标准。</li></ul></li><li>线程卡顿监控：这是业内常用的一种检测卡顿的方法，通过开辟一个子线程来监控主线程的 RunLoop，当两个状态区域之间的耗时大于阈值时，就记为发生一次卡顿。美团的移动端性能监控方案 Hertz 采用的就是这种方式</li></ul><p>主线程卡顿监控的实现思路：开辟一个子线程，然后实时计算 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 两个状态区域之间的耗时是否超过某个阀值，来断定主线程的卡顿情况，可以将这个过程想象成操场上跑圈的运动员，我们会每隔一段时间间隔去判断是否跑了一圈，如果发现在指定时间间隔没有跑完一圈，则认为在消息处理的过程中耗时太多，视为主线程卡顿。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以通过 CFRunLoopObserverRef 实时获取 NSRunLoop 的状态。具体使用方法如下：</p><p>首先创建一个 CFRunLoopObserverContext 观察者 observer。然后将观察者 observer 添加到主线程 RunLoop 的 kCFRunLoopCommonModes 模式下进行观察。</p><p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。为了让计算更精确，需要让子线程更及时的获知主线程 RunLoop 状态变化，dispatch_semaphore_t 是一个不错的选择。另外，卡顿需要覆盖多次连续短时间卡顿和单次长时间卡顿两种情景，所以判定条件也需要做适当优化。优化后的代码实现如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runLoopObserverCallBack</span><span class="params">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录状态值</span></span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)self,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            <span class="number">0</span>,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程监控时长</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></span><br><span class="line">            <span class="keyword">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span>*NSEC_PER_MSEC));</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++timeoutCount &lt; <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 检测到卡顿，进行卡顿上报</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;FPS&quot;&gt;&lt;a href=&quot;#FPS&quot; class=&quot;headerlink&quot; title=&quot;FPS&quot;&gt;&lt;/a&gt;FPS&lt;/h3&gt;&lt;p&gt;FPS（Frames Per Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持 FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。&lt;/p&gt;
&lt;h3 id=&quot;相关系统原理&quot;&gt;&lt;a href=&quot;#相关系统原理&quot; class=&quot;headerlink&quot; title=&quot;相关系统原理&quot;&gt;&lt;/a&gt;相关系统原理&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CADisplayLink&lt;/code&gt; 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。&lt;/p&gt;
&lt;p&gt;一旦 CADisplayLink 以特定的模式注册到 runloop 之后，每当屏幕需要刷新时，runloop 就会调用 CADisplayLink 绑定的 target 上的 selector，此时 target 可以读取到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;&lt;a href=&quot;#代码实现&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h3&gt;&lt;p&gt;现阶段，常用的 FPS 监控几乎都是基于 CADisplayLink 实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="APM" scheme="https://developerdoc.com/categories/APM/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控2 Memory信息</title>
    <link href="https://developerdoc.com/essay/APM/iOSAPM2/"/>
    <id>https://developerdoc.com/essay/APM/iOSAPM2/</id>
    <published>2020-10-12T11:55:01.000Z</published>
    <updated>2020-10-13T11:36:53.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>我们可以联想：内存使用情况是否也可以通过类似CPU的方式获取到呢？答案是肯定的。</p><h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅使 App 以及整个系统也都能表现的更好。</p><p>MacOS 和 iOS 都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory Management Unit）维护着由逻辑地址到物理地址的 页面映射表（简称 页表），当程序访问逻辑内存地址时，由 MMU 根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为 4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和 4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了 16KB。</p><p>虚拟内存分页（Virtual Page，VP）有两种类型：</p><ul><li>Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：<ul><li>内存映射文件</li><li>Frameworks 中的 __DATA_CONST 部分</li><li>应用的二进制可执行文件</li></ul></li><li>Dirty：指不能被系统回收的内存占用，包括：<ul><li>所有堆上的对象</li><li>图片解码缓冲数据</li><li>Framework 中的 DATA 和 DATA_DIRTY 部分</li></ul></li></ul><a id="more"></a><p>由于内存容量和读写寿命的限制，iOS 上没有 Disk Swap 机制，取而代之使用 Compressed Memory 技术。 Disk Swap 是指在 macOS 以及一些其他桌面操作系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中的backing store（Swapping out），并且在需要访问时从磁盘中再读入 RAM（Swapping in）。与大多数 UNIX 系统不同的是，macOS 没有预先分配磁盘中的一部分作为 backing store，而是利用引导分区所有可用的磁盘空间。</p><p>苹果最初只是公开了从 OS X Mavericks 开始使用 Compressed Memory 技术，但 iOS 系统也从 iOS 7 开始悄悄地使用。</p><p>Compressed Memory 技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，其特点可以归结为：</p><ul><li>减少了不活跃内存占用</li><li>改善电源效率，通过压缩减少磁盘 IO 带来的损耗</li><li>压缩/解压非常快，能够尽可能减少 CPU 的时间开销</li><li>支持多核操作</li></ul><p>本质上，Compressed Memory 也是 Dirty Memory。因此，memory footprint = dirty size + compressed size，这也是我们需要并且能够尝试去减少的内存占用。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在 /usr/include/mach/task_info.h 中，我们可以看到 mach_task_basic_info 和 task_basic_info 结构体的定义，分别如下所示。事实上，苹果公司已经不建议再使用 task_basic_info 结构体了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_TASK_BASIC_INFO     20         <span class="comment">/* always 64-bit basic info */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_task_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  virtual_size;       <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  resident_size;      <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  resident_size_max;  <span class="comment">/* maximum resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;          <span class="comment">/* total user run time for</span></span><br><span class="line"><span class="comment">                                               terminated threads */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;        <span class="comment">/* total system run time for</span></span><br><span class="line"><span class="comment">                                               terminated threads */</span></span><br><span class="line">        <span class="keyword">policy_t</span>        policy;             <span class="comment">/* default policy for new threads */</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;      <span class="comment">/* suspend count for task */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* localized structure - cannot be safely passed between tasks of differing sizes */</span></span><br><span class="line"><span class="comment">/* Don't use this, use MACH_TASK_BASIC_INFO instead */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;  <span class="comment">/* suspend count for task */</span></span><br><span class="line">        <span class="keyword">vm_size_t</span>       virtual_size;   <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">vm_size_t</span>       resident_size;  <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;      <span class="comment">/* total user run time for</span></span><br><span class="line"><span class="comment">                                           terminated threads */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;    <span class="comment">/* total system run time for</span></span><br><span class="line"><span class="comment">                                           terminated threads */</span></span><br><span class="line"><span class="keyword">policy_t</span>policy;<span class="comment">/* default policy for new threads */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mach_task_basic_info 结构体存储了 Mach task 的内存使用信息，其中 resident_size 是 App 使用的驻留内存大小，virtual_size 是 App 使用的虚拟内存大小。</p><p>如下所示为内存使用情况的代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前 app 内存使用量</span></span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_task_basic_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">kern_return_t</span> kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>) &amp;info, &amp;count);</span><br><span class="line"><span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">return</span> info.resident_size;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，我用 通过此方法获取到的内存信息与 Instruments 中的 Activity Monitor 采集到的内存信息进行比较，发现前者要多出将近 100MB。经过调研发现，苹果使用了上述的 Compressed Memory，我猜测：resident_size 可能是将 Compressed Memory 解压后所统计到的一个数值。<strong>真实的物理内存的值应该是 task_vm_info 结构体中的 pyhs_footprint 成员的值。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_VM_INFO            22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_VM_INFO_PURGEABLE  23</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_vm_info</span> &#123;</span></span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  virtual_size;       <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line"><span class="keyword">integer_t</span>       region_count;       <span class="comment">/* number of memory regions */</span></span><br><span class="line"><span class="keyword">integer_t</span>       page_size;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  resident_size;      <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  resident_size_peak; <span class="comment">/* peak resident size (bytes) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  device;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  device_peak;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  internal;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  internal_peak;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  external;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  external_peak;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  reusable;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  reusable_peak;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  purgeable_volatile_pmap;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  purgeable_volatile_resident;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  purgeable_volatile_virtual;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  compressed;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  compressed_peak;</span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  compressed_lifetime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* added for rev1 */</span></span><br><span class="line"><span class="keyword">mach_vm_size_t</span>  phys_footprint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* added for rev2 */</span></span><br><span class="line"><span class="keyword">mach_vm_address_t</span>       min_address;</span><br><span class="line"><span class="keyword">mach_vm_address_t</span>       max_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，正确的内存使用情况的代码实现应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前 app 内存使用量</span></span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    <span class="keyword">task_vm_info_data_t</span> vmInfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = TASK_VM_INFO_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (<span class="keyword">task_info_t</span>) &amp;vmInfo, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> memoryUsageInByte = (<span class="keyword">int64_t</span>) vmInfo.phys_footprint;</span><br><span class="line">        <span class="keyword">return</span> memoryUsageInByte / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设备所有物理内存大小"><a href="#设备所有物理内存大小" class="headerlink" title="设备所有物理内存大小"></a>设备所有物理内存大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSProcessInfo processInfo].physicalMemory</span><br></pre></td></tr></table></figure><h3 id="设备使用的内存"><a href="#设备使用的内存" class="headerlink" title="设备使用的内存"></a>设备使用的内存</h3><p>获取当前设备的 Memory 使用情况</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int64_t getUsedMemory()</span><br><span class="line">&#123;</span><br><span class="line">    size_t length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    mib[<span class="number">0</span>] = <span class="built_in">CTL_HW</span>;</span><br><span class="line">    mib[<span class="number">1</span>] = HW_PAGESIZE;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;pagesize, &amp;length, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line">    </span><br><span class="line">    vm_statistics_data_t vmstat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wireMem = vmstat.wire_count * pagesize;</span><br><span class="line">    <span class="keyword">int</span> activeMem = vmstat.active_count * pagesize;</span><br><span class="line">    <span class="keyword">return</span> wireMem + activeMem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设备可用的内存"><a href="#设备可用的内存" class="headerlink" title="设备可用的内存"></a>设备可用的内存</h3><p>获取当前设备可用的 Memory</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">uint64_t</span>)availableMemory &#123;</span><br><span class="line">    <span class="keyword">vm_statistics64_data_t</span> vmStats;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> infoCount = HOST_VM_INFO_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kernReturn = host_statistics(mach_host_self(),</span><br><span class="line">                                               HOST_VM_INFO,</span><br><span class="line">                                               (<span class="keyword">host_info_t</span>)&amp;vmStats,</span><br><span class="line">                                               &amp;infoCount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (kernReturn != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NSNotFound;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> vm_page_size * (vmStats.free_count + vmStats.inactive_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可能会看到有些代码会使用 vm_statistics_data_t 结构体，但是这个结构体是32位机器的，随着 Apple 逐渐放弃对32位应用的支持，所以建议读者还是使用 vm_statistics64_data_t 64位的结构体。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Memory&quot;&gt;&lt;a href=&quot;#Memory&quot; class=&quot;headerlink&quot; title=&quot;Memory&quot;&gt;&lt;/a&gt;Memory&lt;/h3&gt;&lt;p&gt;我们可以联想：内存使用情况是否也可以通过类似CPU的方式获取到呢？答案是肯定的。&lt;/p&gt;
&lt;h3 id=&quot;相关系统原理&quot;&gt;&lt;a href=&quot;#相关系统原理&quot; class=&quot;headerlink&quot; title=&quot;相关系统原理&quot;&gt;&lt;/a&gt;相关系统原理&lt;/h3&gt;&lt;p&gt;内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅使 App 以及整个系统也都能表现的更好。&lt;/p&gt;
&lt;p&gt;MacOS 和 iOS 都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory Management Unit）维护着由逻辑地址到物理地址的 页面映射表（简称 页表），当程序访问逻辑内存地址时，由 MMU 根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为 4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和 4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了 16KB。&lt;/p&gt;
&lt;p&gt;虚拟内存分页（Virtual Page，VP）有两种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：&lt;ul&gt;
&lt;li&gt;内存映射文件&lt;/li&gt;
&lt;li&gt;Frameworks 中的 __DATA_CONST 部分&lt;/li&gt;
&lt;li&gt;应用的二进制可执行文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dirty：指不能被系统回收的内存占用，包括：&lt;ul&gt;
&lt;li&gt;所有堆上的对象&lt;/li&gt;
&lt;li&gt;图片解码缓冲数据&lt;/li&gt;
&lt;li&gt;Framework 中的 DATA 和 DATA_DIRTY 部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="APM" scheme="https://developerdoc.com/categories/APM/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 性能监控1 Cpu 和 Memory信息</title>
    <link href="https://developerdoc.com/essay/APM/iOSAPM1/"/>
    <id>https://developerdoc.com/essay/APM/iOSAPM1/</id>
    <published>2020-10-09T01:30:44.000Z</published>
    <updated>2020-10-13T11:37:05.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 占用率的采集原理其实很简单：App 作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的占用率。</p><p>wiki上比较全的iPhone CPU信息 : <a href="https://en.wikipedia.org/wiki/Apple-designed_processors" target="_blank" rel="noopener">Apple-designed_processors</a>)</p><h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由 BSD 层实现。</p><p>事实上，Mach 并不能识别 UNIX 中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：任务（Task）。经典的 UNIX 采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach 则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。</p><ul><li>线程<ul><li>线程定义了 Mach 中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。</li></ul></li><li>任务<ul><li>任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。</li></ul></li></ul><a id="more"></a><p>严格来说，Mach 的任务并不是hi操作系统中所谓的进程，因为 Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。在 BSD 模型中，这两个概念有一对一的简单映射，每个 BSD 进程（即 OS X 进程）都在底层关联了一个 Mach 任务对象。实现这种映射的方法是指定一个透明的指针 bsd_info，Mach 对 bsd_info 完全无知。Mach 将内核也用任务表示（全局范围称为 kernel_task），尽管该任务没有对应的 PID，但可以想象 PID 为 0。</p><p>下图所示为权威著作《OS X Internal: A System Approach》中提供的 Mach OS X 中进程子系统组成的概念图。与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的。</p><p><img src="/res/apm/mach-task-thread-system.png" alt></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述提到线程表示的是底层的机器寄存器状态以及各种给调度统计数据。再来看 Mach 层中的 thread_basic_info 结构体的定义，其成员信息也证实了这一点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;      <span class="comment">// 用户运行时长</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;    <span class="comment">// 系统运行时长</span></span><br><span class="line">        <span class="keyword">integer_t</span>       cpu_usage;      <span class="comment">// CPU 使用率</span></span><br><span class="line">        <span class="keyword">policy_t</span>        policy;         <span class="comment">// 调度策略</span></span><br><span class="line">        <span class="keyword">integer_t</span>       run_state;      <span class="comment">// 运行状态</span></span><br><span class="line">        <span class="keyword">integer_t</span>       flags;          <span class="comment">// 各种标记</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;  <span class="comment">// 暂停线程的计数</span></span><br><span class="line">        <span class="keyword">integer_t</span>       sleep_time;     <span class="comment">// 休眠时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>每个线程都有这个结构体，所以我们只需要定时去遍历每个线程，累加每个线程的 cpu_usage 字段的值，就可以得到当前 App 所在进程的 CPU 使用率。</p><p>如下所示为 CPU 占用率 的代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CPU 使用率</span></span><br><span class="line">+ (CGFloat)appCpuUsage &#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">task_info_data_t</span> tinfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> task_info_count;</span><br><span class="line">    </span><br><span class="line">    task_info_count = TASK_INFO_MAX;</span><br><span class="line">    kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)tinfo, &amp;task_info_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_array_t</span>         thread_list;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> thread_count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_info_data_t</span>     thinfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> thread_info_count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_basic_info_t</span> basic_info_th;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get threads in the task</span></span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> total_time     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_userTime = <span class="number">0</span>;</span><br><span class="line">    CGFloat total_cpu   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for each thread</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)thread_count; j++) &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">                         (<span class="keyword">thread_info_t</span>)thinfo, &amp;thread_info_count);</span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        basic_info_th = (<span class="keyword">thread_basic_info_t</span>)thinfo;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            total_time     = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">            total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">            total_cpu      = total_cpu + basic_info_th-&gt;cpu_usage / (<span class="keyword">float</span>)TH_USAGE_SCALE * kMaxPercent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (<span class="keyword">vm_offset_t</span>)thread_list, thread_count * <span class="keyword">sizeof</span>(<span class="keyword">thread_t</span>));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中使用 task_threads API 调用获取指定的 task 的线程列表。task_threads 将 target_task 任务中的所有线程保存在 act_list 数组中，数组包含 act_listCnt 个条目。上述源码中，在调用 task_threads API 时，target_task 参数传入的是 mach_task_self()，表示获取当前的 Mach task。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span> task_threads</span><br><span class="line">(</span><br><span class="line"><span class="keyword">task_t</span> target_task,</span><br><span class="line"><span class="keyword">thread_act_array_t</span> *act_list,</span><br><span class="line"><span class="keyword">mach_msg_type_number_t</span> *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在获取到线程列表后，代码中使用 thread_info API 调用获取指定线程的线程信息。thread_info 查询 flavor 指定的线程信息，将信息返回到长度为 thread_info_outCnt 字节的 thread_info_out 缓存区中。上述源码，在调用 thread_info API 时，flavor 参数传入的是 THREAD_BASIC_INFO，使用这个类型会返回线程的基本信息，即 thread_basic_info_t 结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span> thread_info</span><br><span class="line">(</span><br><span class="line"><span class="keyword">thread_act_t</span> target_act,</span><br><span class="line"><span class="keyword">thread_flavor_t</span> flavor,</span><br><span class="line"><span class="keyword">thread_info_t</span> thread_info_out,</span><br><span class="line"><span class="keyword">mach_msg_type_number_t</span> *thread_info_outCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述源码的最后，使用 vm_deallocate API 以防止出现内存泄露。</p><h3 id="总的-CPU-占用率"><a href="#总的-CPU-占用率" class="headerlink" title="总的 CPU 占用率"></a>总的 CPU 占用率</h3><p>使用 <code>host_statistics</code> 函数拿到 host_cpu_load_info 的值，这个结构体的成员变量 cpu_ticks 包含了 CPU 运行的时钟脉冲的数量，cpu_ticks 是一个数组，里面分别包含了 CPU_STATE_USER, CPU_STATE_SYSTEM, CPU_STATE_IDLE 和 CPU_STATE_NICE 模式下的时钟脉冲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (CGFloat)cpuUsage &#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">host_cpu_load_info_data_t</span> previous_info = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">host_cpu_load_info_data_t</span> info;</span><br><span class="line">    </span><br><span class="line">    count = HOST_CPU_LOAD_INFO_COUNT;</span><br><span class="line">    </span><br><span class="line">    kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (<span class="keyword">host_info_t</span>)&amp;info, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">natural_t</span> user   = info.cpu_ticks[CPU_STATE_USER] - previous_info.cpu_ticks[CPU_STATE_USER];</span><br><span class="line">    <span class="keyword">natural_t</span> nice   = info.cpu_ticks[CPU_STATE_NICE] - previous_info.cpu_ticks[CPU_STATE_NICE];</span><br><span class="line">    <span class="keyword">natural_t</span> system = info.cpu_ticks[CPU_STATE_SYSTEM] - previous_info.cpu_ticks[CPU_STATE_SYSTEM];</span><br><span class="line">    <span class="keyword">natural_t</span> idle   = info.cpu_ticks[CPU_STATE_IDLE] - previous_info.cpu_ticks[CPU_STATE_IDLE];</span><br><span class="line">    <span class="keyword">natural_t</span> total  = user + nice + system + idle;</span><br><span class="line">    previous_info    = info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (user + nice + system) * <span class="number">100.0</span> / total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过计算 info 和 previous_info 的差值，分别得到在这几个模式下的 cpu_ticks，除 idle 以外都属于 CPU 被占用的情况，最后就能求出 CPU 的占用率。</p><h3 id="CPU-核数"><a href="#CPU-核数" class="headerlink" title="CPU 核数"></a>CPU 核数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSUInteger)cpuNumber &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CPU-频率"><a href="#CPU-频率" class="headerlink" title="CPU 频率"></a>CPU 频率</h3><p>CPU 频率，就是 CPU 的时钟频率， 是 CPU 运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是 Hz，它决定移动设备的运行速度。</p><p>由于安全性考虑，苹果已经禁止访问内核变量来获取 CPU 频率。现实现方法是通过硬编码方式获取 CPU 频率，新机发布需更新。</p><p>我们通过硬编码的方式，建立一张机型和 CPU 主频的映射表，然后根据机型找到对应的 CPU 主频即可。</p><p>可以在其中找到对应机型cpu的对应 : <a href="https://en.wikipedia.org/wiki/Apple-designed_processors" target="_blank" rel="noopener">Apple-designed_processors</a></p><h3 id="CPU-类型"><a href="#CPU-类型" class="headerlink" title="CPU 类型"></a>CPU 类型</h3><p>我们知道 iPhone 使用的处理器架构都是 ARM 的，而 ARM 又分为 ARMV7、ARMV7S 和 ARM64等。而想要获取设备具体的处理器架构则需要使用 NXGetLocalArchInfo() 函数。这个函数的返回值是 NXArchInfo 结构体类型，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">cpu_type_t</span> cputype;</span><br><span class="line">    <span class="keyword">cpu_subtype_t</span> cpusubtype;</span><br><span class="line">    <span class="keyword">enum</span> NXByteOrder byteorder;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *description;</span><br><span class="line">&#125; NXArchInfo;</span><br></pre></td></tr></table></figure><p>NXArchInfo 结构体成员变量中就包含我们需要的信息：cputype 和 cpusubtype，这两个变量类型的定义在 mach/machine.h 头文件中给出，本质上都是 int 类型 typedef 得到的。</p><p>根据 mach/machine.h 头文件给出的 CPU 架构类型的定义，可以很容易建立起各 CPU 架构到其对应描述的映射关系，代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ (NSInteger)cpuType &#123;</span><br><span class="line">    <span class="keyword">return</span> (NSInteger)NXGetLocalArchInfo()-&gt;cputype;</span><br><span class="line">&#125;</span><br><span class="line">+ (NSInteger)cpuSubtype &#123;</span><br><span class="line">    <span class="keyword">return</span> (NSInteger)NXGetLocalArchInfo()-&gt;cpusubtype;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)p_stringFromCpuType:(NSInteger)cpuType &#123;</span><br><span class="line">    <span class="keyword">switch</span> (cpuType) &#123;</span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_VAX:          <span class="keyword">return</span> @<span class="string">"VAX"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC680x0:      <span class="keyword">return</span> @<span class="string">"MC680x0"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_X86:          <span class="keyword">return</span> @<span class="string">"X86"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_X86_64:       <span class="keyword">return</span> @<span class="string">"X86_64"</span>;       </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC98000:      <span class="keyword">return</span> @<span class="string">"MC98000"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_HPPA:         <span class="keyword">return</span> @<span class="string">"HPPA"</span>;         </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_ARM:          <span class="keyword">return</span> @<span class="string">"ARM"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_ARM64:        <span class="keyword">return</span> @<span class="string">"ARM64"</span>;        </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC88000:      <span class="keyword">return</span> @<span class="string">"MC88000"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_SPARC:        <span class="keyword">return</span> @<span class="string">"SPARC"</span>;        </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_I860:         <span class="keyword">return</span> @<span class="string">"I860"</span>;         </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_POWERPC:      <span class="keyword">return</span> @<span class="string">"POWERPC"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_POWERPC64:    <span class="keyword">return</span> @<span class="string">"POWERPC64"</span>;    </span><br><span class="line">        <span class="keyword">default</span>:                    <span class="keyword">return</span> @<span class="string">"Unknown"</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)cpuTypeString &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cpuTypeString) &#123;</span><br><span class="line">        _cpuTypeString = [self p_stringFromCpuType:[[self class] cpuType]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _cpuTypeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)cpuSubtypeString &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cpuSubtypeString) &#123;</span><br><span class="line">        _cpuSubtypeString = [NSString stringWithUTF8String:NXGetLocalArchInfo()-&gt;description];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _cpuSubtypeString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经测试发现 NXArchInfo 结构体成员变量 description 包含的就是 CPU 架构的详尽信息，所以可以用它作为 cpuSubtypeString，当然也可以自己建立 cpuSubtype 的映射关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;p&gt;CPU 占用率的采集原理其实很简单：App 作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的占用率。&lt;/p&gt;
&lt;p&gt;wiki上比较全的iPhone CPU信息 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Apple-designed_processors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apple-designed_processors&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&quot;相关系统原理&quot;&gt;&lt;a href=&quot;#相关系统原理&quot; class=&quot;headerlink&quot; title=&quot;相关系统原理&quot;&gt;&lt;/a&gt;相关系统原理&lt;/h3&gt;&lt;p&gt;iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由 BSD 层实现。&lt;/p&gt;
&lt;p&gt;事实上，Mach 并不能识别 UNIX 中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：任务（Task）。经典的 UNIX 采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach 则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程&lt;ul&gt;
&lt;li&gt;线程定义了 Mach 中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;任务&lt;ul&gt;
&lt;li&gt;任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="APM" scheme="https://developerdoc.com/categories/APM/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片-像素操作</title>
    <link href="https://developerdoc.com/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C/"/>
    <id>https://developerdoc.com/quick-start/图片/iOS图片-像素操作/</id>
    <published>2020-01-13T13:07:46.000Z</published>
    <updated>2020-01-20T08:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍下常见的几种对图片的像素级操作<br>1.修改颜色 2. 颜色空间变化 3.lsb 隐藏信息 4. 颜色混合  5. 马赛克</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 <a href="../iOS图片-位图信息与图片解码/">iOS图片-位图信息与图片解码</a> 中介绍了位图信息中像素 颜色空间等概念。这次来实践一下如何对图片的像素进行操作。位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，我们就知道如何对图片进行像素级操作了。</p><h2 id="将一张图片修改为蓝色"><a href="#将一张图片修改为蓝色" class="headerlink" title="将一张图片修改为蓝色"></a>将一张图片修改为蓝色</h2><p>由于在iOS开发中使用的位图大部分是32位RGBA模式，所以我们先说下这种模式的简单图像处理。<br>首先我们需要知道什么是32位RGBA模式的位图。32位就表示一个这种模式位图的一个像素所占内存为32位，也就是4个字节的长度。R、G、B、A分别代表red，green，blue和alpha，也就是颜色组成的三原色与透明度值。RGBA每一个占用一个字节的内存。<br>知道了上面这些，我们就有了思路：通过改变每一个像素中的RGBA值来进行一些位图图像的处理了。</p> <a id="more"></a><p>示例代码 效果如下: </p><p>将原图片 <img src="/res/iOSImg/Share.png" alt> 转换为蓝色图片<br><img src="/res/iOSImg/sample1ResultImg.png" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1 将一张图片变为蓝色</span></span><br><span class="line"><span class="built_in">UIImage</span>* sampleImg1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"share.png"</span>];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* sample1ResultImg = [<span class="keyword">self</span>.class sample1With:sampleImg1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"示例1 将一张图片变为蓝色 END"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span>*)sample1With:(<span class="built_in">UIImage</span>*)originImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图 像素rgba信息</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"><span class="comment">//            NSLog(@"r %d,g %d,b %d,a %d",thisR,thisG,thisB,thisA);</span></span><br><span class="line">            <span class="keyword">if</span>(thisA)&#123;<span class="comment">//透明不处理 其他变为蓝色</span></span><br><span class="line">                thisR = <span class="number">0</span>;</span><br><span class="line">                thisG = <span class="number">0</span>;</span><br><span class="line">                thisB = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="像素格式色彩空间变为灰色"><a href="#像素格式色彩空间变为灰色" class="headerlink" title="像素格式色彩空间变为灰色"></a>像素格式色彩空间变为灰色</h2><p>iOS 支持的组合不多 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB" target="_blank" rel="noopener">Supported Pixel Formats</a></p><p>这里尝试将像素格式色彩空间变为灰色 示例代码 效果如下: </p><p>将原图片  <img src="/res/iOSImg/rgb_cs.png" style="width:80%"> 转换为灰色颜色空间图片 <img src="/res/iOSImg/grey_cs.png" style="width:80%"></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例2 像素格式 颜色空间变为灰色</span></span><br><span class="line"><span class="built_in">UIImage</span>* sampleImg2 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"channel.png"</span>];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* sample1ResultImg = [<span class="keyword">self</span>.class sample2With:sampleImg2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"示例2 颜色空间变化 END"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...其他同上例</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaOnly);</span><br><span class="line"><span class="comment">//去掉像素处理部分</span></span><br></pre></td></tr></table></figure><h2 id="LSB方式隐藏二维码到一张图片"><a href="#LSB方式隐藏二维码到一张图片" class="headerlink" title="LSB方式隐藏二维码到一张图片"></a>LSB方式隐藏二维码到一张图片</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D" target="_blank" rel="noopener">LSB</a>，最低有效位，英文是Least Significant Bit 。我们知道图像像素一般是由RGB三原色（即红绿蓝）组成的，每一种颜色占用8位，0x00~0xFF，即一共有256种颜色，一共包含了256的3次方的颜色，颜色太多，而人的肉眼能区分的只有其中一小部分，这导致了当我们修改RGB颜色分量中最低的二进制位的时候，我们的肉眼是区分不出来的。</p><p>鉴于LSB想法，一张普通的二维码图片只有黑色和白色。那么对于RGBA的图片 可以修改R的最低位。0表示白色 1表示黑色，这样处理后肉眼看不出原图修改的痕迹。</p><p>示例代码 效果如下: </p><p>左图是原图 右图是经过LSB操作的图，肉眼完全看不出区别</p><p><img src="/res/iOSImg/LSB.png" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例3 在一张图片中使用lsb方式隐藏二维码 。</span></span><br><span class="line"><span class="comment">//例子里简单处理了 原图和二维码大小相同</span></span><br><span class="line"><span class="built_in">UIImage</span>* oriImg = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"channel.png"</span>];</span><br><span class="line"><span class="built_in">UIImage</span>* qrImg = [<span class="keyword">self</span>.class createQRForAlreadySpliceString:<span class="string">@"一些信息"</span> size:<span class="built_in">CGSizeMake</span>(<span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//将二维码图片信息藏入原图 得到result</span></span><br><span class="line">    <span class="built_in">UIImage</span>* result = [<span class="keyword">self</span> handleImage:oriImg hideQrImage:qrImg];</span><br><span class="line">    <span class="comment">//从result中解析得到二维码</span></span><br><span class="line">    <span class="built_in">UIImage</span>* qrResult = [<span class="keyword">self</span> handleHideImage:result];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 图片处理 隐藏二维码图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)handleImage:(<span class="built_in">UIImage</span>*)originImg hideQrImage:(<span class="built_in">UIImage</span>*)qrImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line">    <span class="built_in">UInt32</span> * inputQRPixels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> inputQRCGImage = [qrImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRWidth = <span class="built_in">CGImageGetWidth</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRHeight = <span class="built_in">CGImageGetHeight</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRBytesPerRow = bytesPerPixel * inputQRWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    inputQRPixels = (<span class="built_in">UInt32</span> *)calloc(inputQRHeight * inputQRWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> qrcontext = <span class="built_in">CGBitmapContextCreate</span>(inputQRPixels, inputQRWidth, inputQRHeight,</span><br><span class="line">                                                 bitsPerComponent, inputQRBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(qrcontext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputQRWidth, inputQRHeight), inputQRCGImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"><span class="comment">//            NSLog(@"r %d,g %d,b %d,a %d",thisR,thisG,thisB,thisA);</span></span><br><span class="line">            <span class="comment">//二维码</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentQRPixel = inputQRPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> qrcolor = *currentQRPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> qrthisR,qrthisG,qrthisB,qrthisA;</span><br><span class="line">            qrthisR=R(qrcolor);</span><br><span class="line">            qrthisG=G(qrcolor);</span><br><span class="line">            qrthisB=B(qrcolor);</span><br><span class="line">            qrthisA=A(qrcolor);</span><br><span class="line">            <span class="comment">//透明度0信息会丢失</span></span><br><span class="line">            <span class="keyword">if</span>(thisA == <span class="number">0</span>)&#123;</span><br><span class="line">                thisA = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//像素最低位处理</span></span><br><span class="line">            <span class="keyword">if</span>(qrthisR &lt; <span class="number">128</span>)&#123;<span class="comment">//二维码白色 设置最低位为0</span></span><br><span class="line">                thisR ^= (thisR &amp; ( <span class="number">1</span> &lt;&lt; <span class="number">0</span>) ) ^ (<span class="number">0</span> &lt;&lt; <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//                thisA = 255;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//二维码黑色 设置最低位为1</span></span><br><span class="line">                thisR ^= (thisR &amp; ( <span class="number">1</span> &lt;&lt; <span class="number">0</span>) ) ^ (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(qrcontext);</span><br><span class="line">    free(inputQRPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: 图片处理 解析二维码</span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)handleHideImage:(<span class="built_in">UIImage</span>*)originImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//像素最低位处理</span></span><br><span class="line">            <span class="keyword">int</span> tag = (thisR &gt;&gt; <span class="number">0</span>) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span>)&#123;<span class="comment">//最低位为0 白色</span></span><br><span class="line">                thisR=<span class="number">255</span>;</span><br><span class="line">                thisG=<span class="number">255</span>;</span><br><span class="line">                thisB=<span class="number">255</span>;</span><br><span class="line">                thisA=<span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//最低位为1 黑色</span></span><br><span class="line">                thisR=<span class="number">0</span>;</span><br><span class="line">                thisG=<span class="number">0</span>;</span><br><span class="line">                thisB=<span class="number">0</span>;</span><br><span class="line">                thisA=<span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然LSB的方式也能隐藏文字等其他信息。与之类似的想法还有 可以根据容差进行信息的隐藏。</p><p>若是有两张图片，则对两张图片的每一个像素点进行对比，设置一个容差的阈值α，超出这个阈值的像素点RGB值设置为(255,255,255),若是没超过阈值，则设置该像素点的RGB值为(0,0,0)。因此，通过调整不同的α值，可以使对比生成的图片呈现不同的画面。比如两张图完全一样，设置阈值α为任何值，最后得到的对比图都只会是全黑。若两张图每一个像素点都不同，阈值α设置为1，则对比图将是全白。如果将隐藏信息附加到某些像素点上，这时调整阈值α即可看到隐藏信息。</p><h3 id="JPEG压缩"><a href="#JPEG压缩" class="headerlink" title="JPEG压缩"></a>JPEG压缩</h3><p>目前例子中有个比较大的问题就是，经过LSB操作后的图片是需要无损的才能 解析出数据来。假设图片经过JPEG压缩后 如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将二维码图片信息藏入原图 得到result</span></span><br><span class="line"><span class="built_in">UIImage</span>* result = [<span class="keyword">self</span> handleImage:oriImg hideQrImage:qrImg];</span><br><span class="line"><span class="built_in">NSData</span>* resultData = <span class="built_in">UIImageJPEGRepresentation</span>(result, <span class="number">0.9</span>);</span><br><span class="line">result = [<span class="built_in">UIImage</span> imageWithData:resultData];</span><br><span class="line"><span class="comment">//从result中解析得到二维码</span></span><br><span class="line"><span class="built_in">UIImage</span>* qrResult = [<span class="keyword">self</span> handleHideImage:result];</span><br></pre></td></tr></table></figure><p>则qrResult会得到如下图：</p><p><img src="/res/iOSImg/qrResult_1.png" alt></p><p>这是由于JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，例子中最低位信息其实已经被改变。</p><h2 id="混色模式"><a href="#混色模式" class="headerlink" title="混色模式"></a>混色模式</h2><p>在PS 的混色模式中我们可以看到可以选项，混合模式的基本原理就是取A层任意一个像素a [R1, G1, B1]，与B层对应位置的像素b [R2, G2, B2] 进行数学运算，得到c [R3, G3, B3]。有兴趣可以看下 <a href="https://zhuanlan.zhihu.com/p/23905865" target="_blank" rel="noopener">一篇文章彻底搞清PS混合模式的原理</a></p><p>基于这种想法 我们可以模拟下PS的混合模式：</p><p><img src="/res/iOSImg/colorMix.png" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="built_in">UInt32</span> *currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">                <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">                <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">                <span class="comment">// 这里直接移位获得RBGA的值,以及输出写的非常好！</span></span><br><span class="line">                thisR = R(color);</span><br><span class="line">                thisG = G(color);</span><br><span class="line">                thisB = B(color);</span><br><span class="line">                thisA = A(color);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">UInt32</span> newR,newG,newB;</span><br><span class="line">                newR = [<span class="keyword">self</span> SoftLight:thisR];</span><br><span class="line">                newG = [<span class="keyword">self</span> SoftLight:thisG];</span><br><span class="line">                newB = [<span class="keyword">self</span> SoftLight:thisB];</span><br><span class="line">                </span><br><span class="line">                *currentPixel = RGBAMake(newR,</span><br><span class="line">                                         newG,</span><br><span class="line">                                         newB,</span><br><span class="line">                                         thisA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>Color Burn 颜色加深：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)ColorBurn:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    C=A-(A反相×B反相)/B</span></span><br><span class="line"><span class="comment">//    如果上层越暗，则下层获取的光越少，加深效果越明显。</span></span><br><span class="line"><span class="comment">//    【如果上层为全黑色，则下层颜色值不是255的像素全变成0】，</span></span><br><span class="line"><span class="comment">//    如果上层为全白色，则根本不会影响下层。</span></span><br><span class="line"><span class="comment">//    结果最亮的地方不会高于下层的像素值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    resultValue = originValue - (<span class="number">255</span> - originValue) * (<span class="number">255</span> - bValue) / bValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Color Dodge 颜色减淡：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)ColorDodge:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//C=A+(A×B)/B反相</span></span><br><span class="line"><span class="comment">//该模式和上一个模式刚好相反。</span></span><br><span class="line"><span class="comment">//该模式下，上层的亮度决定了下层的暴露程度。</span></span><br><span class="line"><span class="comment">//如果上层越亮，下层获取的光越多，也就是越亮。</span></span><br><span class="line"><span class="comment">//如果上层是纯黑色，也就是没有亮度，则根本不会影响下层，</span></span><br><span class="line"><span class="comment">//【如果上层是纯白色，则下层颜色值不是0的像素全变成255】。</span></span><br><span class="line"><span class="comment">//结果最黑的地方不会低于下层的像素值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    resultValue = originValue + originValue * bValue / (<span class="number">255</span> - bValue);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hard Light 强光：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)HardLight:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B&lt;=128则 C=(A×B)/128</span></span><br><span class="line"><span class="comment">//B&gt;128则 C=255-(A反相×B反相)/128</span></span><br><span class="line"><span class="comment">//该模式完全相对应于Overlay（叠加）模式下，两个图层进行次序交换的情况。</span></span><br><span class="line"><span class="comment">//如过上层的颜色高于50%灰，则下层越亮，反之越暗。</span></span><br><span class="line"><span class="comment">//【如果将上层图层设为叠加，下层设为强光，则改变图层顺序不影响结果。】</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bValue &lt;= <span class="number">128</span>)&#123;</span><br><span class="line">        resultValue =   originValue * bValue / <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        resultValue = <span class="number">255</span> - (<span class="number">255</span> - originValue) * (<span class="number">255</span> - bValue) / <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一篇文章 <a href="https://juejin.im/post/5cd17612f265da037a3d0183" target="_blank" rel="noopener">iOS——隐形水印的实现和『颜色加深』算法</a> 文中说用 颜色加深来显示隐形水印，但是我换了几张图片实践了一下 效果不理想。有兴趣的同学可以自己实践下。</p><h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>简单马赛克核心算法的大概原理就是把某一个点的颜色赋值给它周围的指定区域，这个区域大小可以我们自己来定义。</p><p>按照这种想法可以做到：</p><p><img src="/res/iOSImg/msk.png" alt></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图 像素rgba信息</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">            <span class="keyword">float</span> markP = <span class="number">10</span>;<span class="comment">//10x10区域</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> centerX = <span class="number">0</span> , centerY = <span class="number">0</span>;</span><br><span class="line">            centerX =  floor(i/markP)*markP + <span class="number">0.5</span>*markP;</span><br><span class="line">            centerX = centerX &gt;= (inputWidth<span class="number">-1</span>) ? (inputWidth<span class="number">-1</span>) : centerX;</span><br><span class="line">            centerY =  floor(j/markP)*markP + <span class="number">0.5</span>*markP;</span><br><span class="line">            centerY = centerY &gt;= (inputHeight<span class="number">-1</span>) ? (inputHeight<span class="number">-1</span>) : centerY;</span><br><span class="line">            <span class="built_in">UInt32</span> * centerPixel = inputPixels + (centerY * inputWidth) + centerX;</span><br><span class="line">            <span class="built_in">UInt32</span> centerColor = *centerPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> centerR,centerG,centerB,centerA;</span><br><span class="line">            centerR=R(centerColor);</span><br><span class="line">            centerG=G(centerColor);</span><br><span class="line">            centerB=B(centerColor);</span><br><span class="line">            centerA=A(centerColor);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            *currentPixel = RGBAMake(centerR, centerG, centerB, centerA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h2 id="提取主色调"><a href="#提取主色调" class="headerlink" title="提取主色调"></a>提取主色调</h2><p>ref:<br><a href="https://github.com/tangdiforx/iOSPalette" target="_blank" rel="noopener">iOS-palette</a><br><a href="https://developer.android.com/reference/android/support/v7/palette/package-summary" target="_blank" rel="noopener">android-palette</a><br><a href="https://github.com/google/palette.js" target="_blank" rel="noopener">js-palette</a></p><p>遍历一遍图片的所有像素信息，然后统计一下哪个RGB值最多，不就是主色调嘛？但是人眼和冷冰冰的数据还是存在差异的。 Palette通过饱和度筛选 颜色区域解决颜色分散来选出主色调。参考<a href="https://www.jianshu.com/p/01df6010dded" target="_blank" rel="noopener">iOS图片精确提取主色调算法iOS-Palette</a></p><p><img src="https://upload-images.jianshu.io/upload_images/5806025-9188b291498651e7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/720/format/webp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍下常见的几种对图片的像素级操作&lt;br&gt;1.修改颜色 2. 颜色空间变化 3.lsb 隐藏信息 4. 颜色混合  5. 马赛克&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;../iOS图片-位图信息与图片解码/&quot;&gt;iOS图片-位图信息与图片解码&lt;/a&gt; 中介绍了位图信息中像素 颜色空间等概念。这次来实践一下如何对图片的像素进行操作。位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，我们就知道如何对图片进行像素级操作了。&lt;/p&gt;
&lt;h2 id=&quot;将一张图片修改为蓝色&quot;&gt;&lt;a href=&quot;#将一张图片修改为蓝色&quot; class=&quot;headerlink&quot; title=&quot;将一张图片修改为蓝色&quot;&gt;&lt;/a&gt;将一张图片修改为蓝色&lt;/h2&gt;&lt;p&gt;由于在iOS开发中使用的位图大部分是32位RGBA模式，所以我们先说下这种模式的简单图像处理。&lt;br&gt;首先我们需要知道什么是32位RGBA模式的位图。32位就表示一个这种模式位图的一个像素所占内存为32位，也就是4个字节的长度。R、G、B、A分别代表red，green，blue和alpha，也就是颜色组成的三原色与透明度值。RGBA每一个占用一个字节的内存。&lt;br&gt;知道了上面这些，我们就有了思路：通过改变每一个像素中的RGBA值来进行一些位图图像的处理了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS图片" scheme="https://developerdoc.com/categories/iOS%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="图片" scheme="https://developerdoc.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片-位图信息与图片解码</title>
    <link href="https://developerdoc.com/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E4%BD%8D%E5%9B%BE%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81/"/>
    <id>https://developerdoc.com/quick-start/图片/iOS图片-位图信息与图片解码/</id>
    <published>2019-12-10T08:35:28.000Z</published>
    <updated>2020-01-15T09:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍下几种iOS中位图信息 与相关解压缩<br>ref <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="noopener">谈谈 iOS 中图片的解压缩</a><br>ref <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007533-SW1" target="_blank" rel="noopener">Quartz 2D Programming Guide</a></p></blockquote><p>我们从网络下载或者从本地磁盘加载一张图片到屏幕上显示，要经过图片的解码过程，为什么呢？因为我们一般的图片格式例如 JPEG，PNG都是经过压缩后的图片，而显示在屏幕上的图片叫做位图(bitmap)，所谓的解码就是把压缩后的图片变成位图。</p><p>为什么非要解码成位图才能显示呢？因为位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，就可以在屏幕上渲染整张图片了。</p><p>那我们为什么还需要不同格式的各种图片呢？直接全部用位图不就好了？那不就不需要每次解码了？那些JPEG以及PNG等其实都是图像的压缩格式，我们都知道压缩的意思就是减小空间，所以我们可以想到，使用这些格式的原因就是位图实在太大了。</p><h2 id="图片解压后的数据变化"><a href="#图片解压后的数据变化" class="headerlink" title="图片解压后的数据变化"></a>图片解压后的数据变化</h2><a id="more"></a><p>我们来使用这张图片和以下代码做例子：</p><p><img src="/res/iOSImg/testImg2.png" style="background-color: rgba(0,0,300,.5)"><br>该图片的二进制信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452  .PNG........IHDR</span><br><span class="line">00000010: 0000 0022 0000 0022 0803 0000 000d 99fb  ...&quot;...&quot;........</span><br><span class="line">00000020: f000 0000 5d50 4c54 4500 0000 ffff ffff  ....]PLTE.......</span><br><span class="line">00000030: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000040: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000050: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000060: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000070: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000080: ffff ffff ffff 512a fbe5 0000 001e 7452  ......Q*......tR</span><br><span class="line">00000090: 4e53 001c b890 7103 faa9 580d f7c8 09f0  NS....q...X.....</span><br><span class="line">000000a0: be42 1685 78e2 d4c5 b1a1 604d 492d 1e0f  .B..x.....`MI-..</span><br><span class="line">000000b0: 5dbe 24b2 0000 0084 4944 4154 38cb edcf  ].$.....IDAT8...</span><br><span class="line">000000c0: cb0a c240 1044 d1d2 38ad 8e19 4de2 fb55  ...@.D..8...M..U</span><br><span class="line">000000d0: ffff 99d2 4d70 971a 5097 de5d c381 a630  ....Mp..P..]...0</span><br><span class="line">000000e0: d113 952e 7b96 be55 a2a1 b76d b538 981b  ....&#123;..U...m.8..</span><br><span class="line">000000f0: 2516 d865 374a 6034 428c a611 228c 3127  %..e7J`4B...&quot;.1&apos;</span><br><span class="line">00000100: 21bc 23f9 d062 4596 a485 9143 552c d35f  !.#..bE....CU,._</span><br><span class="line">00000110: 7c27 faaa 4856 1358 939b f7d1 e510 9298  |&apos;..HV.X........</span><br><span class="line">00000120: 0b49 70bf 2548 127d 4aca 7cba d335 46cb  .Ip.%H.&#125;J.|..5F.</span><br><span class="line">00000130: 0a80 4193 73bc 9a89 3afc a817 5dd5 1a7c  ..A.s...:...]..|</span><br><span class="line">00000140: 84ac 48f9 0000 0000 4945 4e44 ae42 6082  ..H.....IEND.B`.</span><br></pre></td></tr></table></figure><p>获取图片解压信息的代码为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * path = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"testImg2"</span> ofType:<span class="string">@"png"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> fileURLWithPath:path];</span><br><span class="line"><span class="built_in">CGImageSourceRef</span> myImageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((<span class="built_in">CFURLRef</span>)url, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CGImageRef</span> myImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(myImageSource,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CFRelease</span>(myImageSource);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDataRef</span> rawData = <span class="built_in">CGDataProviderCopyData</span>(<span class="built_in">CGImageGetDataProvider</span>(myImage));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"rawData %@"</span>,rawData);</span><br></pre></td></tr></table></figure><p>这张图片像素尺寸为34x34,文件大小为 336Byte ；而获取到图片原始像素数据rawData，大小为4624byte。以下为rawData信息 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">00000000 ffffff90 ffffffff ffffffff ffffffff ffffff71 00000000 ffffff42 fffffff7 </span><br><span class="line">ffffffff ffffffff ffffffbe ffffff09 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 ffffff90 ffffffff </span><br><span class="line">ffffffff ffffffff ffffff71 00000000 00000000 00000000 ffffff42 fffffff7 ffffffff </span><br><span class="line">ffffffff ffffffbe ffffff09 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 ffffff90 ffffffff ffffffff ffffffff ffffff71 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 ffffff42 fffffff7 ffffffff ffffffff </span><br><span class="line">ffffff90 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也就是说，这张PNG 图片解压缩后的大小是 4624byte ，是原始文件大小的 4.27 倍。那么这个4624byte是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p><p><strong><em>解压缩后的图片大小 = 图片的像素宽 34 </em> 图片的像素高 34 <em> 每个像素所占的字节数 4</em></strong></p><p>我们常见接触到的图片格式， JPEG 还是 PNG 图片，都是一种压缩的<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html" target="_blank" rel="noopener">位图图形格式</a>。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作。</p><h2 id="位图信息"><a href="#位图信息" class="headerlink" title="位图信息"></a>位图信息</h2><p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html" target="_blank" rel="noopener">Bitmap Images and Image Masks</a>中是这么定义的：</p><blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.<br>Each sample in a bitmap contains one or more color components in a specified color space, plus one additional component that specifies the alpha value to indicate transparency. Each component can be from 1 to as many as 32 bits. In Mac OS X, Quartz also provides support for floating-point components. The supported formats in Mac OS X and iOS are described in “Pixel formats supported for bitmap graphics contexts”. ColorSync provides color space support for bitmap images.</p></blockquote><p>Quartz在创建位图图像（CGImageRef）时使用以下信息：</p><ul><li><em>data source</em> 位图数据源，可以是Quartz数据提供程序或Quartz图像源。</li><li><em>Pixel Format</em> 像素格式，包括每个组件的位数，每个像素的位数和每行的字节数。</li><li><em>Color Spaces and Bitmap Layout</em> 对于图像，颜色空间和位图布局（颜色空间和位图布局）信息用于描述alpha的位置以及位图是否使用浮点值。</li><li><em>Decode Array</em> 可选的解码数组。</li><li>插值设置，它是一个布尔值，它指定在调整图像大小时，Quartz是否应应用插值算法。</li><li>一个渲染意图，指定如何映射位于图形上下文的目标颜色空间内的颜色。</li><li>图像尺寸。</li></ul><h3 id="解码数组-Decode-Array"><a href="#解码数组-Decode-Array" class="headerlink" title="解码数组 Decode Array"></a>解码数组 Decode Array</h3><p>解码数组将图像颜色值映射到其他颜色值，这对于诸如使图像去饱和或反转颜色之类的任务很有用。该数组包含每个颜色分量的一对数字。Quartz渲染图像时，它将应用线性变换将原始分量值映射到适合目标色彩空间的指定范围内的相对数字。例如，RGB颜色空间中图像的解码数组包含六个条目，每个红色，绿色和蓝色分量一对。</p><h3 id="像素格式Pixel-Format"><a href="#像素格式Pixel-Format" class="headerlink" title="像素格式Pixel Format"></a>像素格式Pixel Format</h3><p>像素格式包含以下信息：</p><ul><li><em>Bits per component</em>每个分量的位数，即像素中每个单独颜色分量的位数。对于图像掩模，此值是源像素中有效掩模位的数量。例如，如果源图像是8位掩码，则每个组件指定8位。</li><li><em>Bits per pixel</em>每个像素的位数，即源像素的位数。该值必须至少是每个组件的位数乘以每个像素的组件数。</li><li><em>Bytes per row</em>每行字节数。图像中每水平行的字节数。</li></ul><h3 id="颜色与颜色空间-Color-and-Color-Spaces"><a href="#颜色与颜色空间-Color-and-Color-Spaces" class="headerlink" title="颜色与颜色空间 Color and Color Spaces"></a>颜色与颜色空间 Color and Color Spaces</h3><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101" target="_blank" rel="noopener">Color and Color Spaces</a>中说明了Quartz中的颜色由一组值表示。如果没有颜色空间指示如何解释颜色信息，则这些值将毫无意义。例如，表4-1中的值全部代表全强度的蓝色。但是，如果不知道颜色空间或每种颜色空间的允许值范围，就无法知道每组值代表哪种颜色。</p><p>表4-1   不同颜色空间中的颜色值</p><table><thead><tr><th style="text-align:left">values</th><th style="text-align:center">color space</th><th style="text-align:right">compoents</th></tr></thead><tbody><tr><td style="text-align:left">240 degrees, 100%, 100%</td><td style="text-align:center">HSB</td><td style="text-align:right">Hue, saturation, brightness</td></tr><tr><td style="text-align:left">0, 0, 1</td><td style="text-align:center">RGB</td><td style="text-align:right">Red, green, blue</td></tr><tr><td style="text-align:left">1, 1, 0, 0</td><td style="text-align:center">CMYK</td><td style="text-align:right">Cyan, magenta, yellow, black</td></tr><tr><td style="text-align:left">1, 0, 0</td><td style="text-align:center">BGR</td><td style="text-align:right">Blue, green, red</td></tr></tbody></table><p>如果提供错误的色彩空间，则可能会出现很大的差异，如图4-1所示。尽管绿色在BGR和RGB颜色空间中的解释相同，但是红色和蓝色值却被翻转了。</p><p><img src="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/color_profiles.gif" alt></p><h3 id="位图布局-Bitmap-Layout"><a href="#位图布局-Bitmap-Layout" class="headerlink" title="位图布局 Bitmap Layout"></a>位图布局 Bitmap Layout</h3><p>想确保 Quartz 能够正确地解析像素格式中各个bit所代表的含义，我们还需要提供位图的布局信息 <code>CGBitmapInfo</code> ：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, <span class="built_in">CGBitmapInfo</span>) &#123;</span><br><span class="line">    kCGBitmapAlphaInfoMask = <span class="number">0x1F</span>,</span><br><span class="line"></span><br><span class="line">    kCGBitmapFloatInfoMask = <span class="number">0xF00</span>,</span><br><span class="line">    kCGBitmapFloatComponents = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    kCGBitmapByteOrderMask     = kCGImageByteOrderMask,</span><br><span class="line">    kCGBitmapByteOrderDefault  = kCGImageByteOrderDefault,</span><br><span class="line">    kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,</span><br><span class="line">    kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,</span><br><span class="line">    kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,</span><br><span class="line">    kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big</span><br><span class="line">&#125; <span class="built_in">CG_AVAILABLE_STARTING</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><p>它主要提供了三个方面的布局信息：</p><ul><li>alpha 的信息 CGImageAlphaInfo；</li><li>颜色分量是否为浮点数；</li><li>像素格式的字节顺序 Byte Ordering。</li></ul><h4 id="透明信息-CGImageAlphaInfo"><a href="#透明信息-CGImageAlphaInfo" class="headerlink" title="透明信息 CGImageAlphaInfo"></a>透明信息 CGImageAlphaInfo</h4><p>其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageAlphaInfo</span>) &#123;</span><br><span class="line">    kCGImageAlphaNone,               <span class="comment">/* For example, RGB. */</span></span><br><span class="line">    kCGImageAlphaPremultipliedLast,  <span class="comment">/* For example, premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaPremultipliedFirst, <span class="comment">/* For example, premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaLast,               <span class="comment">/* For example, non-premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaFirst,              <span class="comment">/* For example, non-premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaNoneSkipLast,       <span class="comment">/* For example, RBGX. */</span></span><br><span class="line">    kCGImageAlphaNoneSkipFirst,      <span class="comment">/* For example, XRGB. */</span></span><br><span class="line">    kCGImageAlphaOnly                <span class="comment">/* No color data, alpha data only */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：</p><ul><li>是否包含 alpha ；</li><li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB ；</li><li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。</li></ul><h4 id="字节顺序-CGImageByteOrderInfo"><a href="#字节顺序-CGImageByteOrderInfo" class="headerlink" title="字节顺序 CGImageByteOrderInfo"></a>字节顺序 CGImageByteOrderInfo</h4><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。</p><p><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH" target="_blank" rel="noopener">字节顺序</a>的信息由枚举值 CGImageByteOrderInfo 来表示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageByteOrderInfo</span>) &#123;</span><br><span class="line">    kCGImageByteOrderMask     = <span class="number">0x7000</span>,</span><br><span class="line">    kCGImageByteOrder16Little = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Little = (<span class="number">2</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder16Big    = (<span class="number">3</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Big    = (<span class="number">4</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">&#125; <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_12, __IPHONE_10_0);</span><br></pre></td></tr></table></figure><p>它主要提供了两个方面的字节顺序信息：</p><ul><li>小端序还是大端序；</li><li>数据以 16 位还是 32 位为单位。</li></ul><p>下图表示了 Quartz 2D中CMYK和RGB颜色空间的32位和16位像素格式<br><img src="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif" alt></p><h3 id="支持的像素格式"><a href="#支持的像素格式" class="headerlink" title="支持的像素格式"></a>支持的像素格式</h3><p>下表表示了位图图形上下文支持的像素格式，关联的色彩空间 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB" target="_blank" rel="noopener">Supported Pixel Formats</a>：</p><table><thead><tr><th style="text-align:left">cs</th><th style="text-align:center">Pixel format and bitmap information constant</th><th style="text-align:right">Availability</th></tr></thead><tbody><tr><td style="text-align:left">Null</td><td style="text-align:center">8 bpp, 8 bpc, kCGImageAlphaOnly</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">Gray</td><td style="text-align:center">8 bpp, 8 bpc,kCGImageAlphaNone</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">Gray</td><td style="text-align:center">8 bpp, 8 bpc,kCGImageAlphaOnly</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">Gray</td><td style="text-align:center">16 bpp, 16 bpc, kCGImageAlphaNone</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">Gray</td><td style="text-align:center">32 bpp, 32 bpc, kCGImageAlphaNone或kCGBitmapFloatComponents`</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">16 bpp, 5 bpc, kCGImageAlphaNoneSkipFirst</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNoneSkipFirst</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNoneSkipLast</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaPremultipliedFirst</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaPremultipliedLast</td><td style="text-align:right">Mac OS X, iOS</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaPremultipliedLast</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaNoneSkipLast</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaNoneSkipLast 或kCGBitmapFloatComponents</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">RGB</td><td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaPremultipliedLast 或kCGBitmapFloatComponents</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">CMYK</td><td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNone</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">CMYK</td><td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaNone</td><td style="text-align:right">Mac OS X</td></tr><tr><td style="text-align:left">CMYK</td><td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaNone 或kCGBitmapFloatComponents</td><td style="text-align:right">Mac OS X</td></tr></tbody></table><p>对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间</p><h2 id="CGBitmapContextCreate"><a href="#CGBitmapContextCreate" class="headerlink" title="CGBitmapContextCreate"></a>CGBitmapContextCreate</h2><p>上面说了这么多参数，那么那个函数会用到呢？答案是 <code>CGBitmapContextCreate</code> :</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a bitmap context. The context draws into a bitmap which is `width'</span></span><br><span class="line"><span class="comment">   pixels wide and `height' pixels high. The number of components for each</span></span><br><span class="line"><span class="comment">   pixel is specified by `space', which may also specify a destination color</span></span><br><span class="line"><span class="comment">   profile. The number of bits for each component of a pixel is specified by</span></span><br><span class="line"><span class="comment">   `bitsPerComponent'. The number of bytes per pixel is equal to</span></span><br><span class="line"><span class="comment">   `(bitsPerComponent * number of components + 7)/8'. Each row of the bitmap</span></span><br><span class="line"><span class="comment">   consists of `bytesPerRow' bytes, which must be at least `width * bytes</span></span><br><span class="line"><span class="comment">   per pixel' bytes; in addition, `bytesPerRow' must be an integer multiple</span></span><br><span class="line"><span class="comment">   of the number of bytes per pixel. `data', if non-NULL, points to a block</span></span><br><span class="line"><span class="comment">   of memory at least `bytesPerRow * height' bytes. If `data' is NULL, the</span></span><br><span class="line"><span class="comment">   data for context is allocated automatically and freed when the context is</span></span><br><span class="line"><span class="comment">   deallocated. `bitmapInfo' specifies whether the bitmap should contain an</span></span><br><span class="line"><span class="comment">   alpha channel and how it's to be generated, along with whether the</span></span><br><span class="line"><span class="comment">   components are floating-point or integer. */</span></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(<span class="keyword">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。各参数使用如下：</p><ul><li>data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</li><li>width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li><li>bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li><li>bytesPerPixel：表示一个像素点有多少个字节组成，上面的方法注释中提到了一个公式 <code>(bitsPerComponent * number of components + 7)/8</code>，即一个像素点的字节数量与表示当前图像的颜色的颜色分量数量和每个分量的位数有关</li><li>bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化</li><li>space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li><li>bitmapInfo ：就是我们前面提到的位图的布局信息。</li></ul><p>文章开头说 <code>解压缩后的图片大小 = 图片的像素宽 34 * 图片的像素高 34 * 每个像素所占的字节数4</code> ; 我们的手机一般支持 RGB 颜色空间，现在就是知道了 RGB 颜色空间中，实际上是有 4 个分量，所以我们可以算出 bytesPerPixel = (8 * 4 + 7)/8 = 4B。所以我们现在知道为什么最开始的时候我们计算位图的大小的时候，每个像素的大小我们使用的值是 4B 了。事实上不同的颜色空间下，上面这些值都是不同的，但是一般在手机上，我们使用 RGB 颜色空间，所以差不多就是上面的值。</p><h3 id="YYImage中使用"><a href="#YYImage中使用" class="headerlink" title="YYImage中使用"></a>YYImage中使用</h3><p>现在来看下YYImage中的解码代码 ，先使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；再用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；最后使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="built_in">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">        <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(context);</span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SDWebImage中使用"><a href="#SDWebImage中使用" class="headerlink" title="SDWebImage中使用"></a>SDWebImage中使用</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">UIImage</span> shouldDecodeImage:image]) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</span></span><br><span class="line">    <span class="comment">// on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = [<span class="built_in">UIImage</span> colorSpaceForImageRef:imageRef];</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">        size_t bytesPerRow = kBytesPerPixel * width;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></span><br><span class="line">        <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></span><br><span class="line">        <span class="comment">// to create bitmap graphics contexts without alpha info.</span></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     bytesPerRow,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Draw the image into the context and retrieve the new bitmap image without alpha</span></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithoutAlpha</span><br><span class="line">                                                         scale:image.scale</span><br><span class="line">                                                   orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// Prevent "CGBitmapContextCreateImage: invalid context 0x0" error</span></span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not decode animated images</span></span><br><span class="line">    <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">    <span class="built_in">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                     alpha == kCGImageAlphaLast ||</span><br><span class="line">                     alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                     alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="comment">// do not decode images with alpha</span></span><br><span class="line">    <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDWebImage 中和其他不一样的地方，就是如果一张图片有 alpha 分量，那就直接返回原始图片，不再进行解码操作。我猜测作者这样写，是不是因为觉得对于有 alpha 分量的图片，因为上下文创建中那些参数的缘故，解码之后可能会与原始图像有偏差，干脆就不解码了。</p><p>SDWebImage 在解码操作外面包了 autoreleasepool，这样在大量图片需要解码的时候，可以使得局部变量尽早释放掉，不会造成内存峰值过高。其他创建上下文，然后调用 CGContextDrawImage，再调用CGBitmapContextCreateImage获取创建后的位图，和 YYImage 基本一样，就是个别参数设置不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍下几种iOS中位图信息 与相关解压缩&lt;br&gt;ref &lt;a href=&quot;http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;谈谈 iOS 中图片的解压缩&lt;/a&gt;&lt;br&gt;ref &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007533-SW1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Quartz 2D Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们从网络下载或者从本地磁盘加载一张图片到屏幕上显示，要经过图片的解码过程，为什么呢？因为我们一般的图片格式例如 JPEG，PNG都是经过压缩后的图片，而显示在屏幕上的图片叫做位图(bitmap)，所谓的解码就是把压缩后的图片变成位图。&lt;/p&gt;
&lt;p&gt;为什么非要解码成位图才能显示呢？因为位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，就可以在屏幕上渲染整张图片了。&lt;/p&gt;
&lt;p&gt;那我们为什么还需要不同格式的各种图片呢？直接全部用位图不就好了？那不就不需要每次解码了？那些JPEG以及PNG等其实都是图像的压缩格式，我们都知道压缩的意思就是减小空间，所以我们可以想到，使用这些格式的原因就是位图实在太大了。&lt;/p&gt;
&lt;h2 id=&quot;图片解压后的数据变化&quot;&gt;&lt;a href=&quot;#图片解压后的数据变化&quot; class=&quot;headerlink&quot; title=&quot;图片解压后的数据变化&quot;&gt;&lt;/a&gt;图片解压后的数据变化&lt;/h2&gt;
    
    </summary>
    
      <category term="iOS图片" scheme="https://developerdoc.com/categories/iOS%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="图片" scheme="https://developerdoc.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片-最佳实践</title>
    <link href="https://developerdoc.com/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://developerdoc.com/quick-start/图片/iOS图片-最佳实践/</id>
    <published>2019-12-09T08:00:37.000Z</published>
    <updated>2020-01-15T09:30:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍下 wwdc 2018 Image and Graphics Best Practices 中图片处理解压相关知识点<br>ref: <a href="https://developer.apple.com/videos/play/wwdc2018/219" target="_blank" rel="noopener">Image and Graphics Best Practices</a></p></blockquote><h2 id="图片处理过程"><a href="#图片处理过程" class="headerlink" title="图片处理过程"></a>图片处理过程</h2><p>一张图片从磁盘中显示到屏幕上过程大致如下：从磁盘加载原始压缩的图片信息、解码二进制图片数据为位图、渲染图片最终绘制到屏幕上。</p><!-- ![](/res/imgBestP/imgBestP1.png) --><p><img src="/res/imgBestP/imgBestP1.png" width="80%"></p><p>在实际的渲染过程中，UIImage负责解压Data Buffer内容并申请buffer（Image Buffer）存储解压后的图片信息，然后UIImageView负责将Image Buffer 拷贝至 framebuffer，用于给显示硬件提供颜色信息。</p><p>解压过程是一个大量占用CPU资源的工作，因此UIImage 会retain存储解压后信息的Image Buffer以便给重复的渲染工作提供信息，Image Buffer与图片的实际尺寸有关（理论值为height <em> width </em> 4 bytes），与图片文件大小无关。若是在TableView等列表中连续加载多张图片，便会引发连续的大块内存分配，这将对Memory和CPU带来沉重的负担。</p><a id="more"></a><h3 id="Data-Buffer-Image-Buffer-Frame-Buffer"><a href="#Data-Buffer-Image-Buffer-Frame-Buffer" class="headerlink" title="Data Buffer / Image Buffer / Frame Buffer"></a>Data Buffer / Image Buffer / Frame Buffer</h3><p>图片处理过程中会产生三种buffer</p><h4 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h4><!-- ![](/res/imgBestP/imgBestP2.png) --><p><img src="/res/imgBestP/imgBestP2.png" width="80%"><br>Data Buffer存储了图片的元数据，我们常见的图片格式，jpeg，png等都是压缩图片格式。Data Buffer的内存大小就是源图片在磁盘中的大小。</p><h4 id="Image-Buffer"><a href="#Image-Buffer" class="headerlink" title="Image Buffer"></a>Image Buffer</h4><!-- ![](/res/imgBestP/imgBestP3.png) --><p><img src="/res/imgBestP/imgBestP3.png" width="80%"><br>Image Buffer存储的就是图片解码后的像素数据，也就是我们常说的位图。 Buffer中每一个元素描述的一个像素的颜色信息，buffer的size和图片的size成正相关关系。</p><h4 id="Frame-Buffer"><a href="#Frame-Buffer" class="headerlink" title="Frame Buffer"></a>Frame Buffer</h4><!-- ![](/res/imgBestP/imgBestP4.png) --><p><img src="/res/imgBestP/imgBestP3.png" width="80%"></p><p>Frame Buffer 存储了app每帧的实际输出。在应用程序更新图层时，UIKit将window及其subviews渲染至framebuffer，这个framebuffer提供每个像素的信息以供显示硬件定时读取，读取的频率一般为60Hz，但在ipad上可提升至120Hz。</p><h3 id="加载和解压"><a href="#加载和解压" class="headerlink" title="加载和解压"></a>加载和解压</h3><p><img src="/res/imgBestP/imgBestP5.png" alt></p><p>一般使用imageNamed:或者imageWithData:从内存中加载图片生成UIImage的实例，此刻图片并不会解压，当 RunLoop 准备处理图片显示的事务（CATransaction）时，才进行解压，而这个解压过程是在主线程中的，这是导致卡顿的重要因素。</p><p>解码后的图片内存占用会比原图大小大很多。ImageBuffer按照每个像素RGBA四个字节大小，一张1080p的图片解码后的位图大小是1920 <em> 1080 </em> 4 / 1024 / 1024，约7.9mb，而原图假设是jpg，压缩比1比20，大约350kb，可见解码后的内存占用是相当大的</p><h4 id="imageNamed-方法"><a href="#imageNamed-方法" class="headerlink" title="imageNamed: 方法"></a>imageNamed: 方法</h4><p>通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。</p><p>值得注意的是，这些缓存都是全局的，并不会因为当前UIImage实例的释放而清除，在收到内存警告或者 APP 第一次进入后台才有可能会清除，而这个清除的时机和内容是系统决定的，我们无法干涉。</p><h4 id="imageWithData-方法"><a href="#imageWithData-方法" class="headerlink" title="imageWithData: 方法"></a>imageWithData: 方法</h4><p>通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 CGImageSourceCreateWithData() 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p><p><strong>两种加载方式的区别</strong> 从上面的分析可知，imageNamed:使用时会产生全局的内存占用，但是第二次使用同一张图片时性能很好；imageWithData:不会有全局的内存占用，但对于同一张图片每次加载和解压都会“从头开始”。由此可见，imageNamed:适合“小”且“使用频繁”的图片，imageWithData:适合“大”且“低频使用”的图片。</p><h4 id="怎么能避免缓存呢？"><a href="#怎么能避免缓存呢？" class="headerlink" title="怎么能避免缓存呢？"></a>怎么能避免缓存呢？</h4><ol><li>手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。</li><li>把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="大图使用缩略图"><a href="#大图使用缩略图" class="headerlink" title="大图使用缩略图"></a>大图使用缩略图</h3><p>值得注意的是，可能业务中需要载入一张很大的图片。这时，若还使用常规的方式加载会占用过多的内存；况且，若图片的像素过大（目前主流 iOS 设备最高支持 4096 x 4096 纹理尺寸），在显示的时候 CPU 和 GPU 都会消耗额外的资源来处理图片。可以采用imageIO api来生成缩略图</p><p><img src="/res/imgBestP/imgBestP6.png" alt></p><p>具体代码如下，指定显示区域大小</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func downsample(imageAt imageURL:URL,to pointSize:<span class="built_in">CGSize</span>,scale:<span class="built_in">CGFloat</span>)-&gt;<span class="built_in">UIImage</span>&#123;</span><br><span class="line"><span class="comment">//设置kCGImageSourceShouldCache为false，避免缓存解码后的数据，64位设置上默认是开启缓存的</span></span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSouce = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    </span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width,pointSize.height) * scale</span><br><span class="line"><span class="comment">//设置kCGImageSourceShouldCacheImmediately为true，避免在需要渲染的时候才做解码，默认选项是false    </span></span><br><span class="line">    let downsampleOptions =</span><br><span class="line">     [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize:maxDimensionInPixels</span><br><span class="line">     ] as <span class="built_in">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    let downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSouce, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他缩略方法可以看<a href="../iOS图片-图片缩略方法">iOS图片-图片缩略方法</a></p><h3 id="大图使用CATiledLayer"><a href="#大图使用CATiledLayer" class="headerlink" title="大图使用CATiledLayer"></a>大图使用CATiledLayer</h3><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p><p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是20482048，或40964096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p><p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//add the tiled layer</span></span><br><span class="line">    <span class="built_in">CATiledLayer</span> *tileLayer = [<span class="built_in">CATiledLayer</span> layer];￼</span><br><span class="line">    tileLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">    tileLayer.delegate = <span class="keyword">self</span>; [<span class="keyword">self</span>.scrollView.layer addSublayer:tileLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//configure the scroll view</span></span><br><span class="line">    <span class="keyword">self</span>.scrollView.contentSize = tileLayer.frame.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw layer</span></span><br><span class="line">    [tileLayer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CATiledLayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//determine tile coordinate</span></span><br><span class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</span><br><span class="line">    <span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width);</span><br><span class="line">    <span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//load tile image</span></span><br><span class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@"Snowman_%02i_%02i"</span>, x, y];</span><br><span class="line">    <span class="built_in">NSString</span> *imagePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@"jpg"</span>];</span><br><span class="line">    <span class="built_in">UIImage</span> *tileImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw tile</span></span><br><span class="line">    <span class="built_in">UIGraphicsPushContext</span>(ctx);</span><br><span class="line">    [tileImage drawInRect:bounds];</span><br><span class="line">    <span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="异步加载解压"><a href="#异步加载解压" class="headerlink" title="异步加载解压"></a>异步加载解压</h3><p>对于加载过程，若文件过大或加载频繁影响了帧率（比如列表展示大图），可以使用异步方式加载图片，减少主线程的压力,解压是耗时的，而系统默认是在主线程执行，所以业界通常有一种做法是，异步强制解压，也就是在异步线程主动将二进制图片数据解压成位图数据，使用CGBitmapContextCreate(…)系列方法就能实现。代码大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let serialQueue = DispatchQueue(label: &quot;Decode queue&quot;)</span><br><span class="line">func collectionView(_ collectionView:UICollectionView,prefetcgItemAt indexPaths:[IndexPath])&#123;</span><br><span class="line">    //异步解压 生成缩略图</span><br><span class="line">    for indexPath in indexPaths&#123;</span><br><span class="line">        serialQueue.async &#123;</span><br><span class="line">            let downsampledImage = downsample(images[IndexPath])</span><br><span class="line">            DispatchQueue.main.async &#123;self.update(at:IndexPath.with:downsampledImage)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合理使用draw方法"><a href="#合理使用draw方法" class="headerlink" title="合理使用draw方法"></a>合理使用<code>draw</code>方法</h3><p>重载<code>draw</code>方法会导致内存爆涨。原因如下：</p><p><img src="/res/imgBestP/imgBestP7.png" alt></p><p>一旦你实现了<em>CALayerDelegate</em>协议中的<code>-drawLayer:inContext:</code>方法或者UIView中的<code>-drawRect:</code>方法（其实就是前者的包装方法），CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境(Backing Store)，为绘制寄宿图做准备，它作为ctx参数传入。图层就创建了一个绘制上下文(Backing Store)，这个上下文需要的内存可从这个公式得出：图层宽 <em> 图层高</em> 4 字节，宽高的单位均为像素。以iphone6为例，750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 。</p><p>总结下这种使用drawRect绘制方案的问题</p><ol><li>Backing Store的创建造成了不必要的内存开销</li><li>UIImage先绘制到Backing Store，再渲染到frameBuffer，中间多了一层内存拷贝</li><li>背景颜色不需要绘制到Backing Store，直接使用BackGroundColor绘制到FrameBuffer</li></ol><p>所以，正确的实现姿势是将这个大的view拆分成小的subview逐个实现。</p><h3 id="推荐使用Image-Assets"><a href="#推荐使用Image-Assets" class="headerlink" title="推荐使用Image Assets"></a>推荐使用Image Assets</h3><p>基于名称和特效优化了查找效率，更快的查找图片<br>运行时，对内存的管理也有优化<br>App Slicing，app安装包瘦身。iOS 9 后会从 Image Assets 中保留设备支持的图片 （2x 或者 3x）<br>iOS 11 后的 Preserve Vector Data。支持矢量图的功能，放大也不会失真</p><h3 id="Advanced-Image-Effects"><a href="#Advanced-Image-Effects" class="headerlink" title="Advanced Image Effects"></a>Advanced Image Effects</h3><p>对于图片的实时处理推荐使用CoreImage框架。<br>例如将一张图片的灰度值进行调整这样的操作，有滴小伙伴可能使用CoreGraphics获取图像的每个像素点数据，然后改变灰度值，最终生成目标图标，这种做法将大量gpu擅长的工作放在了cpu上处理，合理的做法是: 使用CoreImage的滤镜filter或者metal，OpenGL的shader，让图像处理的工作交给GPU去做。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let sharedContext = <span class="built_in">CIContext</span>(options: [.useSoftwareRenderer : <span class="literal">false</span>])</span><br><span class="line">func coreImage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    let scale = (Double)(size.width) / (Double)(oriImg.size.width)</span><br><span class="line">    let image = <span class="built_in">CIImage</span>(cgImage: cgImage)</span><br><span class="line">    </span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</span><br><span class="line">    filter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">    filter?.setValue(<span class="built_in">NSNumber</span>(value:scale), forKey: kCIInputScaleKey)</span><br><span class="line">    filter?.setValue(<span class="number">1.0</span>, forKey:kCIInputAspectRatioKey)</span><br><span class="line">    </span><br><span class="line">    guard let outputCIImage = filter?.outputImage,</span><br><span class="line">        let outputCGImage = sharedContext.createCGImage(outputCIImage,</span><br><span class="line">                                                        from: outputCIImage.extent)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Drawing-Off-Screen"><a href="#Drawing-Off-Screen" class="headerlink" title="Drawing Off-Screen"></a>Drawing Off-Screen</h3><p>对于需要离屏渲染的场景推荐使用UIGraphicsImageRenderer替代UIGraphicsBeginImageContext，性能更好，并且支持广色域。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func uikit_resize(oriImg:<span class="built_in">UIImage</span>?,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    let hasAlpha = <span class="literal">false</span></span><br><span class="line">    let scale: <span class="built_in">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</span><br><span class="line">    oriImg!.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    let resizedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    <span class="keyword">return</span> resizedImage!</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in iOS 10 UIGraphicsImageRenderer</span></span><br><span class="line"><span class="comment">//    let render  = UIGraphicsImageRenderer(size: size)</span></span><br><span class="line"><span class="comment">//    return render.image(actions: &#123; (context) in</span></span><br><span class="line"><span class="comment">//        oriImg?.draw(in: CGRect(origin: .zero, size: size))</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍下 wwdc 2018 Image and Graphics Best Practices 中图片处理解压相关知识点&lt;br&gt;ref: &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2018/219&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Image and Graphics Best Practices&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;图片处理过程&quot;&gt;&lt;a href=&quot;#图片处理过程&quot; class=&quot;headerlink&quot; title=&quot;图片处理过程&quot;&gt;&lt;/a&gt;图片处理过程&lt;/h2&gt;&lt;p&gt;一张图片从磁盘中显示到屏幕上过程大致如下：从磁盘加载原始压缩的图片信息、解码二进制图片数据为位图、渲染图片最终绘制到屏幕上。&lt;/p&gt;
&lt;!-- ![](/res/imgBestP/imgBestP1.png) --&gt;
&lt;p&gt;&lt;img src=&quot;/res/imgBestP/imgBestP1.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;在实际的渲染过程中，UIImage负责解压Data Buffer内容并申请buffer（Image Buffer）存储解压后的图片信息，然后UIImageView负责将Image Buffer 拷贝至 framebuffer，用于给显示硬件提供颜色信息。&lt;/p&gt;
&lt;p&gt;解压过程是一个大量占用CPU资源的工作，因此UIImage 会retain存储解压后信息的Image Buffer以便给重复的渲染工作提供信息，Image Buffer与图片的实际尺寸有关（理论值为height &lt;em&gt; width &lt;/em&gt; 4 bytes），与图片文件大小无关。若是在TableView等列表中连续加载多张图片，便会引发连续的大块内存分配，这将对Memory和CPU带来沉重的负担。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS图片" scheme="https://developerdoc.com/categories/iOS%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="图片" scheme="https://developerdoc.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片-ImageIO介绍</title>
    <link href="https://developerdoc.com/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-ImageIO%E4%BB%8B%E7%BB%8D/"/>
    <id>https://developerdoc.com/quick-start/图片/iOS图片-ImageIO介绍/</id>
    <published>2019-12-06T07:40:01.000Z</published>
    <updated>2020-01-15T09:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍下iOS中ImageIO的概览与应用<br><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462-CH201-TPXREF101" target="_blank" rel="noopener">Image I/O Programming Guide</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> ImageIO框架提供了读取与写入图片数据的基本方法，使用它可以直接获取到图片文件的内容数据，ImageIO具有很多特性 <code>Mac平台上最快的图像解码器和编码器</code> <code>逐步加载图像的能力`</code>支持图像元数据<code></code>有效缓存` ImageIO框架中包含6个头文件:</p><ol><li>ImageIO.CGImageAnimation</li><li>ImageIO.CGImageDestination 负责写入图片数据。</li><li>ImageIO.CGImageMetadata 图片文件元数据类</li><li>ImageIO.CGImageProperties 定义了框架中使用的字符串常量和宏。</li><li>ImageIO.CGImageSource 负责读取图片数据。</li><li><p>ImageIO.ImageIOBase 预处理逻辑</p><a id="more"></a></li></ol><h2 id="获取支持的图片格式"><a href="#获取支持的图片格式" class="headerlink" title="获取支持的图片格式"></a>获取支持的图片格式</h2><p>ImageIO 框架了解大多数常见的图像文件格式，例如JPEG，JPEG2000，RAW，TIFF，BMP和PNG。并非每个平台都支持所有格式<br>通过 CGImageSourceCopyTypeIdentifiers 和 CGImageDestinationCopyTypeIdentifiers 可以看到支持的图片格式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回Image IO 支持的统一类型标识符（UTI）数组作为图像源。</span></span><br><span class="line">let mySourceTypes = <span class="built_in">CGImageSourceCopyTypeIdentifiers</span>()</span><br><span class="line"><span class="comment">//返回Image IO 支持的统一类型标识符（UTI）的数组作为图像目标。</span></span><br><span class="line">let myDestTypes = <span class="built_in">CGImageDestinationCopyTypeIdentifiers</span>()</span><br></pre></td></tr></table></figure><h2 id="基本使用-获取图片-缩略图"><a href="#基本使用-获取图片-缩略图" class="headerlink" title="基本使用|获取图片 缩略图"></a>基本使用|获取图片 缩略图</h2><p>在平时开发中，我们通常使用UIImage来读取图片，UIImage支持的图片包括png与jpg等，但是类似ico图标，UIImage默认是无法显示的，<br>可以通过ImageIO框架来在iOS系统中使用ico图标，示例如下</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func getImage() -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    guard let url = Bundle.main.url(forResource: <span class="string">"image.ico"</span>, withExtension: <span class="literal">nil</span>) <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//从URL创建图像源。</span></span><br><span class="line">    guard let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    guard let cgImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123; <span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//获取缩略图</span></span><br><span class="line">    let thumb = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: cgImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取缩略图"><a href="#获取缩略图" class="headerlink" title="获取缩略图"></a>获取缩略图</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func downsample(imageAt imageURL:URL,to pointSize:<span class="built_in">CGSize</span>,scale:<span class="built_in">CGFloat</span>)-&gt;<span class="built_in">UIImage</span>&#123;</span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSouce = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    </span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width,pointSize.height) * scale</span><br><span class="line">    let downsampleOptions =</span><br><span class="line">     [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize:maxDimensionInPixels</span><br><span class="line">     ] as <span class="built_in">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    let downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSouce, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="渐进渲染大图"><a href="#渐进渲染大图" class="headerlink" title="渐进渲染大图"></a>渐进渲染大图</h2><p>渐进式解码（Progressive Decoding），即不需要完整的图像流数据，允许解码部分帧（大部分情况下，会是图像的部分区域），对部分使用了渐进式编码的格式（参考：<a href="https://en.wikipedia.org/wiki/Interlacing_(bitmaps" target="_blank" rel="noopener">渐进式编码</a>)），则更可以解码出相对模糊但完整的图像。比如说，JPEG支持三种方式的渐进式编码，包括Baseline，interlaced，以及progressive</p><p>使用ImageIO框架可以实现大图渐进渲染的效果，一般在对大图片进行网络请求时，可以获取一部分数据就加载一部分数据<br>创建一个空的CGImageSource，然后在每次收到数据的时候调用CGImageSourceUpdateData更新imageSource的数据，接着调用CGImageSourceCreateImageAtIndex获取最新的图片即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo使用计时器模拟</span></span><br><span class="line"><span class="keyword">class</span> ProgressiveLoadViewController : <span class="built_in">UIViewController</span>&#123;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        incrementTimer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private var data = Data()</span><br><span class="line">    private var progress: Int = <span class="number">0</span></span><br><span class="line">    private var incrementTimer: Timer? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            oldValue?.invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var cgImageSource = <span class="built_in">CGImageSourceCreateIncremental</span>(<span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        guard let data = try? Data(contentsOf: URL(string: <span class="string">"some url"</span>)!) <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">"failed to load image source"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.data = data</span><br><span class="line">        <span class="keyword">self</span>.progress = <span class="number">0</span></span><br><span class="line">        <span class="comment">//要渐进显示的图片</span></span><br><span class="line">        guard let cgImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(<span class="keyword">self</span>.cgImageSource, <span class="number">0</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let uiImage = <span class="built_in">UIImage</span>(cgImage: cgImage)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.incrementTimer = Timer.scheduledTimer(timeInterval: <span class="number">0.25</span>, target: <span class="keyword">self</span>,</span><br><span class="line">                                                   selector: <span class="meta">#selector(self.incrementImage), userInfo: nil, repeats: true)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc func incrementImage()&#123;</span><br><span class="line">        <span class="keyword">self</span>.progress += <span class="number">500</span></span><br><span class="line">        let chunk = <span class="keyword">self</span>.data.prefix(<span class="keyword">self</span>.progress)</span><br><span class="line">        <span class="keyword">if</span> chunk.count == <span class="keyword">self</span>.data.count &#123;</span><br><span class="line">            <span class="keyword">self</span>.incrementTimer = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageSourceUpdateData</span>(<span class="keyword">self</span>.cgImageSource, Data(chunk) as <span class="built_in">CFData</span>, chunk.count == <span class="keyword">self</span>.data.count)</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取图像格式元数据"><a href="#读取图像格式元数据" class="headerlink" title="读取图像格式元数据"></a>读取图像格式元数据</h2><p>创建好CGImageSource之后，我们是可以立即解码。但是很多情况下，我们需要获取一些相关的图像信息，包括图像的格式，图像数量，EXIF元数据等。在真正解码之前，我们可以拿到这些数据，进行一些处理，之后再开始解码过程。</p><p>其中，这些信息可以直接在CGImageSource上获取：</p><ul><li>图像格式：CGImageSourceGetType</li><li>图像数量（动图）：CGImageSourceGetCount</li></ul><p>其他的，需要通过获取属性列表来查询。对于图像容器的属性（EXIF等），我们需要使用CGImageSourceCopyProperties即可，然后根据不同的Key去获取对应的信息。</p><p>其实苹果还有一套CGImageSourceCopyMetadataAtIndex，对应的数据不是字典，而是一个CGImageMetadata，再通过其他方法去取。这套API使用起来也是可以的，读取数据和前者是完全兼容一致的，优点是能够进行自定义扩展（比如说你有非标准的图像信息想自己添加和删除）。一般来说使用前者就足够了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>方法都会返回一个字典，字典中可能包含如下有意义的键：</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIFF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyTIFFDictionary;</span><br><span class="line">/GIF信息字典</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyGIFDictionary;</span><br><span class="line"><span class="comment">//JFIF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyJFIFDictionary;</span><br><span class="line"><span class="comment">//EXif信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyExifDictionary;</span><br><span class="line"><span class="comment">//PNG信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyPNGDictionary;</span><br><span class="line"><span class="comment">//IPTC信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyIPTCDictionary;</span><br><span class="line"><span class="comment">//GPS信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyGPSDictionary;</span><br><span class="line"><span class="comment">//原始信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyRawDictionary;</span><br><span class="line"><span class="comment">//CIFF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyCIFFDictionary;</span><br><span class="line"><span class="comment">//佳能相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerCanonDictionary;</span><br><span class="line"><span class="comment">//尼康相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerNikonDictionary;</span><br><span class="line"><span class="comment">//柯尼卡相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerMinoltaDictionary;</span><br><span class="line"><span class="comment">//富士相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerFujiDictionary;</span><br><span class="line"><span class="comment">//奥林巴斯相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerOlympusDictionary;</span><br><span class="line"><span class="comment">//宾得相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerPentaxDictionary;</span><br><span class="line"><span class="comment">//对应Photoshop相片的信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImageProperty8BIMDictionary;</span><br><span class="line"><span class="comment">//NDG信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyDNGDictionary ;</span><br><span class="line"><span class="comment">//ExifAux信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyExifAuxDictionary;</span><br><span class="line"><span class="comment">//OpenEXR信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyOpenEXRDictionary;</span><br><span class="line"><span class="comment">//Apple相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerAppleDictionary ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="显示GIF"><a href="#显示GIF" class="headerlink" title="显示GIF"></a>显示GIF</h2><ol><li>首先使用ImageIO库中的CGImageSource加载Gif文件。</li><li>通过CGImageSource获取到Gif文件中的总的帧数，以及每一帧的显示时间。</li><li>通过CAKeyframeAnimation来完成Gif动画的播放。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func getGif(url:URL)&#123;</span><br><span class="line">    guard let source = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>) <span class="keyword">else</span> &#123;<span class="keyword">return</span>;&#125;;</span><br><span class="line">    <span class="comment">//获取gif中图片的个数</span></span><br><span class="line">    let count = <span class="built_in">CGImageSourceGetCount</span>(source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0.</span>..count &#123;</span><br><span class="line">        let image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, index, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">//获取图片信息</span></span><br><span class="line">        let info = <span class="built_in">CGImageSourceCopyProperties</span>(source, <span class="literal">nil</span>) as! <span class="built_in">NSDictionary</span></span><br><span class="line">        let width = info[kCGImagePropertyWidth]</span><br><span class="line">        let height = info[kCGImagePropertyHeight]</span><br><span class="line">        let timeDic = info[kCGImagePropertyGIFDictionary]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建动画图片"><a href="#创建动画图片" class="headerlink" title="创建动画图片"></a>创建动画图片</h2><ol><li>首先，它创建一对字典来保存动画属性。第一个字典指定动画PNG在停止到最后一帧之前应重复其动画的时间。第二个字典指定序列中每个帧使用的帧延迟。</li><li>创建图像目标之后，代码将设置目标图像的文件属性，然后一次添加一个帧。</li><li>最后，CGImageDestinationFinalize调用该方法以完成动画PNG。</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func createAnimatePng(fileURL:<span class="built_in">CFURL</span>,kUTTypePNG:<span class="built_in">CFString</span>,imageForFrame)&#123;</span><br><span class="line">    let loopCount = <span class="number">1</span></span><br><span class="line">    let frameCount = <span class="number">60</span></span><br><span class="line">     </span><br><span class="line">    var fileProperties = <span class="built_in">NSMutableDictionary</span>()</span><br><span class="line">    fileProperties.setObject(kCGImagePropertyPNGDictionary, forKey: <span class="built_in">NSDictionary</span>(dictionary: [kCGImagePropertyAPNGLoopCount: frameCount]))</span><br><span class="line">     </span><br><span class="line">    var frameProperties = <span class="built_in">NSMutableDictionary</span>()</span><br><span class="line">    frameProperties.setObject(kCGImagePropertyPNGDictionary, forKey: <span class="built_in">NSDictionary</span>(dictionary: [kCGImagePropertyAPNGDelayTime: <span class="number">1.0</span> / Double(frameCount)]))</span><br><span class="line">     </span><br><span class="line">    guard let destination = <span class="built_in">CGImageDestinationCreateWithURL</span>(fileURL, kUTTypePNG, frameCount, <span class="literal">nil</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Provide error handling here.</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">CGImageDestinationSetProperties</span>(destination, fileProperties.copy() as? <span class="built_in">NSDictionary</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;frameCount &#123;</span><br><span class="line">        autoreleasepool &#123;</span><br><span class="line">            let radians = M_PI * <span class="number">2.0</span> * Double(i) / Double(frameCount)</span><br><span class="line">            guard let image = imageForFrame(size: <span class="built_in">CGSize</span>(width: <span class="number">300</span>, height: <span class="number">300</span>)) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageDestinationAddImage</span>(destination, image, frameProperties)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">CGImageDestinationFinalize</span>(destination) &#123;</span><br><span class="line">        <span class="comment">// Provide error handling here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片编码-CGImageDestination"><a href="#图片编码-CGImageDestination" class="headerlink" title="图片编码 | CGImageDestination"></a>图片编码 | CGImageDestination</h2><p>imageIO中使用CGImageDestination对静态图的编码，基本可以分为以下步骤：</p><ul><li>创建CGImageDestination</li><li>添加图像格式元数据（可选）和CGImage</li><li>编码得到NSData，清理</li></ul><h3 id="1-创建CGImageDestination"><a href="#1-创建CGImageDestination" class="headerlink" title="1. 创建CGImageDestination"></a>1. 创建CGImageDestination</h3><p>CGImageDestination的创建也有三个接口，你需要提供一个输出的目标来输出解码后的数据。同时，由于编码需要提供文件格式，你需要指明对应编码的文件格式，用的是UTI Type。对于静态图来说，第三个参数的数量都写1即可。</p><ul><li>CGImageDestinationCreateWithData：指定一个可变二进制数据作为输出</li><li>CGImageDestinationCreateWithURL：指定一个文件路径作为输出</li><li>CGImageDestinationCreateWithDataConsumer：指定一个DataConsumer作为输出</li></ul><h3 id="2-添加图像格式元数据（可选）和CGImage"><a href="#2-添加图像格式元数据（可选）和CGImage" class="headerlink" title="2. 添加图像格式元数据（可选）和CGImage"></a>2. 添加图像格式元数据（可选）和CGImage</h3><p>接下来就是添加图像了，由于CGImage只是包含基本的图像信息，很多额外信息比如说EXIF都已经丢失了，如果我们需要，可以添加对应的元信息。不像解码那样提供了两个API分别获取元信息和图像。使用的接口是CGImageDestinationAddImage。</p><p>当然，如果有自定义的元信息，可以通过另外的CGImageDestinationAddImageAndMetadata来添加CGImageMetadata，这个上面解码也说到过，这里就不解释了。</p><p>此外，还有一个ImageIO最强大的功能，叫做CGImageDestinationAddImageFromSource（这个东西可以媲美vImageConvert_AnyToAny，后续教程会谈到），这个能够从一个任意的CGImageSource，添加一个图像帧到任意一个CGImageDestination。这个一般的用途，就是专门给图像转换器用的，比如说从图像格式A，转换到图像格式B。我们不需要先解码到A的UIImage，再通过编码到B的NSData，直接在中间就进行了转换。能够极大地提升转换效率（Image/IO底层就是通过vImage，传的是Bitmap的引用，没有额外的消耗）。不过这篇教程侧重于Image/IO的编码和解码，转换可以自行参考处理，不再详细说明了。</p><h3 id="3-编码得到NSData，清理"><a href="#3-编码得到NSData，清理" class="headerlink" title="3. 编码得到NSData，清理"></a>3. 编码得到NSData，清理</h3><p>当添加完成所有需要编码的CGImage之后，最后一步，就是进行编码，得到图像格式的数据。这里直接用一个方法CGImageDestinationFinalize即可，编码得到的数据，会写入最早初始化时提供的Data或者DataConsumer。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍下iOS中ImageIO的概览与应用&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462-CH201-TPXREF101&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Image I/O Programming Guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt; ImageIO框架提供了读取与写入图片数据的基本方法，使用它可以直接获取到图片文件的内容数据，ImageIO具有很多特性 &lt;code&gt;Mac平台上最快的图像解码器和编码器&lt;/code&gt; &lt;code&gt;逐步加载图像的能力`&lt;/code&gt;支持图像元数据&lt;code&gt;&lt;/code&gt;有效缓存` ImageIO框架中包含6个头文件:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ImageIO.CGImageAnimation&lt;/li&gt;
&lt;li&gt;ImageIO.CGImageDestination 负责写入图片数据。&lt;/li&gt;
&lt;li&gt;ImageIO.CGImageMetadata 图片文件元数据类&lt;/li&gt;
&lt;li&gt;ImageIO.CGImageProperties 定义了框架中使用的字符串常量和宏。&lt;/li&gt;
&lt;li&gt;ImageIO.CGImageSource 负责读取图片数据。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ImageIO.ImageIOBase 预处理逻辑&lt;/p&gt;
    
    </summary>
    
      <category term="iOS图片" scheme="https://developerdoc.com/categories/iOS%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="图片" scheme="https://developerdoc.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>iOS图片-图片缩略方法</title>
    <link href="https://developerdoc.com/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E5%9B%BE%E7%89%87%E7%BC%A9%E7%95%A5%E6%96%B9%E6%B3%95/"/>
    <id>https://developerdoc.com/quick-start/图片/iOS图片-图片缩略方法/</id>
    <published>2019-12-04T13:14:37.000Z</published>
    <updated>2020-01-15T09:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>介绍下在iOS中的多种图片缩略方式<br>ref <a href="https://nshipster.com/image-resizing/" target="_blank" rel="noopener">https://nshipster.com/image-resizing/</a></p></blockquote><p>在<code>UIKit CoreGraphics ImageIO CoreImage vImage</code>多种缩略方法中 Core Image表现最差。Core Graphics 和 Image I/O最好。</p><p>实际上，在苹果官方在 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1" target="_blank" rel="noopener">Performance Best Practices section of the Core Image Programming Guide</a> 部分中特别推荐使用Core Graphics或Image I / O功能预先裁剪或缩小图像。</p><a id="more"></a><h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p>UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:</p><p>用于图像大小调整的最高级API可以在UIKit框架中找到。给定一个UIImage，可以使用临时图形上下文来渲染缩放版本。这种方式最简</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func uikit_resize(oriImg:<span class="built_in">UIImage</span>?,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    let hasAlpha = <span class="literal">false</span></span><br><span class="line">    let scale: <span class="built_in">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个图片类型的上下文。调用UIGraphicsBeginImageContextWithOptions函数就可获得用来处理图片的图形上下文。利用该上下文，你就可以在其上进行绘图，并生成图片</span></span><br><span class="line"><span class="comment">     size：表示所要创建的图片的尺寸</span></span><br><span class="line"><span class="comment">     opaque：表示这个图层是否完全透明，如果图形完全不用透明最好设置为YES以优化位图的存储，这样可以让图层在渲染的时候效率更高</span></span><br><span class="line"><span class="comment">     scale：指定生成图片的缩放因子，这个缩放因子与UIImage的scale属性所指的含义是一致的。传入0则表示让图片的缩放因子根据屏幕的分辨率而变化，所以我们得到的图片不管是在单分辨率还是视网膜屏上看起来都会很好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</span><br><span class="line">    oriImg!.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    let resizedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    <span class="keyword">return</span> resizedImage!</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in iOS 10 UIGraphicsImageRenderer</span></span><br><span class="line"><span class="comment">//    let render  = UIGraphicsImageRenderer(size: size)</span></span><br><span class="line"><span class="comment">//    return render.image(actions: &#123; (context) in</span></span><br><span class="line"><span class="comment">//        oriImg?.draw(in: CGRect(origin: .zero, size: size))</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CoreGraphics"><a href="#CoreGraphics" class="headerlink" title="CoreGraphics"></a>CoreGraphics</h3><p> CGBitmapContextCreate &amp; CGContextDrawImage</p><p> CoreGraphics / Quartz 2D提供了一套较低级别的API，允许进行更高级的配置。 给定一个CGImage，使用临时位图上下文来渲染缩放后的图像。<br> 使用CoreGraphics图像的质量与UIKit图像相同。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func coreGraphics_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>)-&gt;<span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    let bitsPerComponent = cgImage.bitsPerComponent</span><br><span class="line">    let bytesPerRow = cgImage.bytesPerRow</span><br><span class="line">    let colorSpace = cgImage.colorSpace</span><br><span class="line">    let bitmapInfo = cgImage.bitmapInfo</span><br><span class="line">    </span><br><span class="line">    let context = <span class="built_in">CGContext</span>(data: <span class="literal">nil</span>,</span><br><span class="line">                                  width: Int(size.width),</span><br><span class="line">                                  height: Int(size.height),</span><br><span class="line">                                  bitsPerComponent: bitsPerComponent,</span><br><span class="line">                                  bytesPerRow: bytesPerRow,</span><br><span class="line">                                  space: colorSpace!,</span><br><span class="line">                                  bitmapInfo: bitmapInfo.rawValue)</span><br><span class="line">    </span><br><span class="line">    context?.interpolationQuality = .high</span><br><span class="line">    </span><br><span class="line">    context?.draw(cgImage, <span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    guard let resizedImage = context?.makeImage() <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: resizedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ImageIO"><a href="#ImageIO" class="headerlink" title="ImageIO"></a>ImageIO</h3><p> CGImageSourceCreateThumbnailAtIndex</p><p> Image I / O是一个功能强大但鲜为人知的用于处理图像的框架。 独立于Core Graphics，它可以在许多不同格式之间读取和写入，访问照片元数据以及执行常见的图像处理操作。 这个库提供了该平台上最快的图像编码器和解码器，具有先进的缓存机制，甚至可以逐步加载图像</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func imageIO_resize(url:URL,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    let options: [<span class="built_in">CFString</span>: Any] = [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageIfAbsent: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height)</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    guard let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>),</span><br><span class="line">        let image = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options as <span class="built_in">CFDictionary</span>)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CoreImage"><a href="#CoreImage" class="headerlink" title="CoreImage"></a>CoreImage</h3><p> 里面提供了强大高效的图像处理功能，用来对基于像素的图像进行操作与分析。IOS提供了很多强大的滤镜(Filter)，这些Filter提供了各种各样的效果，并且还可以通过滤镜链将各种效果的Filter叠加起来，形成强大的自定义效果，如果你对该效果不满意，还可以子类化滤镜。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">let sharedContext = <span class="built_in">CIContext</span>(options: [.useSoftwareRenderer : <span class="literal">false</span>])</span><br><span class="line">func coreImage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    let scale = (Double)(size.width) / (Double)(oriImg.size.width)</span><br><span class="line">    </span><br><span class="line">    let image = <span class="built_in">CIImage</span>(cgImage: cgImage)</span><br><span class="line">    </span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</span><br><span class="line">    filter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">    filter?.setValue(<span class="built_in">NSNumber</span>(value:scale), forKey: kCIInputScaleKey)</span><br><span class="line">    filter?.setValue(<span class="number">1.0</span>, forKey:kCIInputAspectRatioKey)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    guard let outputCIImage = filter?.outputImage,</span><br><span class="line">        let outputCGImage = sharedContext.createCGImage(outputCIImage,</span><br><span class="line">                                                        from: outputCIImage.extent)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vImage"><a href="#vImage" class="headerlink" title="vImage"></a>vImage</h3><p> 使用CPU的矢量处理器处理大图像。 强大的图像处理功能，包括Core Graphics和Core Video互操作，格式转换和图像处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func vimage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    var format = vImage_CGImageFormat(bitsPerComponent: <span class="number">8</span>, bitsPerPixel: <span class="number">32</span>, colorSpace: <span class="literal">nil</span>,</span><br><span class="line">                                      bitmapInfo: <span class="built_in">CGBitmapInfo</span>(rawValue: <span class="built_in">CGImageAlphaInfo</span>.first.rawValue),</span><br><span class="line">                                      version: <span class="number">0</span>, decode: <span class="literal">nil</span>, renderingIntent: .defaultIntent)</span><br><span class="line">    </span><br><span class="line">    var sourceBuffer = vImage_Buffer()</span><br><span class="line">    defer &#123;</span><br><span class="line">        free(sourceBuffer.data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer, &amp;format, <span class="literal">nil</span>, cgImage, numericCast(kvImageNoFlags))</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a destination buffer</span></span><br><span class="line">    let scale = oriImg.scale</span><br><span class="line">    let destWidth = Int(size.width)</span><br><span class="line">    let destHeight = Int(size.height)</span><br><span class="line">    let bytesPerPixel = cgImage.bitsPerPixel / <span class="number">8</span></span><br><span class="line">    let destBytesPerRow = destWidth * bytesPerPixel</span><br><span class="line">    </span><br><span class="line">    let destData = UnsafeMutablePointer&lt;<span class="built_in">UInt8</span>&gt;.allocate(capacity: destHeight * destBytesPerRow)</span><br><span class="line">    defer &#123;        </span><br><span class="line">        destData.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    var destBuffer = vImage_Buffer(data: destData, height: vImagePixelCount(destHeight), width: vImagePixelCount(destWidth), rowBytes: destBytesPerRow)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// scale the image</span></span><br><span class="line">    error = vImageScale_ARGB8888(&amp;sourceBuffer, &amp;destBuffer, <span class="literal">nil</span>, numericCast(kvImageHighQualityResampling))</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a CGImage from vImage_Buffer</span></span><br><span class="line">    var destCGImage = vImageCreateCGImageFromBuffer(&amp;destBuffer, &amp;format, <span class="literal">nil</span>, <span class="literal">nil</span>, numericCast(kvImageNoFlags), &amp;error)?.takeRetainedValue()</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a UIImage</span></span><br><span class="line">    let resizedImage = destCGImage.flatMap &#123;</span><br><span class="line">        <span class="built_in">UIImage</span>(cgImage: $<span class="number">0</span>, scale: <span class="number">0.0</span>, orientation: oriImg.imageOrientation)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    destCGImage = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> resizedImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;介绍下在iOS中的多种图片缩略方式&lt;br&gt;ref &lt;a href=&quot;https://nshipster.com/image-resizing/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nshipster.com/image-resizing/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;UIKit CoreGraphics ImageIO CoreImage vImage&lt;/code&gt;多种缩略方法中 Core Image表现最差。Core Graphics 和 Image I/O最好。&lt;/p&gt;
&lt;p&gt;实际上，在苹果官方在 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Performance Best Practices section of the Core Image Programming Guide&lt;/a&gt; 部分中特别推荐使用Core Graphics或Image I / O功能预先裁剪或缩小图像。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS图片" scheme="https://developerdoc.com/categories/iOS%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="图片" scheme="https://developerdoc.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>fishhook源码学习</title>
    <link href="https://developerdoc.com/essay/LLDB/fishhook_code_analyze/"/>
    <id>https://developerdoc.com/essay/LLDB/fishhook_code_analyze/</id>
    <published>2019-05-08T02:29:22.000Z</published>
    <updated>2019-05-08T02:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇 <a href="/essay/LLDB/Mach-O_fishhook/">Mach-O应用 fishhook动态修改C函数</a> 了解了fishhook的原理，现在来看一下它的代码，看它是如何一步一步替换原有函数实现的。</p><a id="more"></a><p>我们再来看看rebind_symbols这个对外的接口，其中应用到的C函数作用如下：</p><ul><li><code>_dyld_image_count(void)</code> 当前dyld装载的image数量</li><li><code>_dyld_get_image_header(unit32_t image_index)</code> 返回image对应的Mach Header地址</li><li><code>_dyld_get_image_vmaddr_slide(unit32_t image_index)</code> 虚拟内存中的地址偏移量</li></ul><p>对实现的分析会 rebind_symbols 函数为入口，首先看一下函数的调用栈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line">└── <span class="keyword">extern</span> <span class="keyword">void</span> _dyld_register_func_for_add_image(<span class="keyword">void</span> (*func)(<span class="keyword">const</span> struct mach_header* mh, <span class="keyword">intptr_t</span> vmaddr_slide));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span><br><span class="line">└── <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span></span></span><br><span class="line">└── static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab)</span><br></pre></td></tr></table></figure><p>其实函数调用栈非常简单，因为整个库中也没有几个函数，rebind_symbols 作为接口，其主要作用就是注册一个函数并在镜像加载时回调：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>) <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">_dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">_rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 rebind_symbols 最开始执行时，会先调用一个 prepend_rebindings 的函数，将整个 rebindings 数组添加到 _rebindings_head 这个私有数据结构的头部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(struct rebindings_entry **rebindings_head,</span></span></span><br><span class="line"><span class="function"><span class="params">  struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> nel)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">new_entry</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rebindings_entry</span>));</span></span><br><span class="line"><span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">new_entry-&gt;rebindings = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line"><span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line"><span class="built_in">free</span>(new_entry);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line">new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">new_entry-&gt;next = *rebindings_head;</span><br><span class="line">*rebindings_head = new_entry;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说每次调用的 rebind_symbols 方法传入的 rebindings 数组以及数组的长度都会以 rebindings_entry 的形式添加到 _rebindings_head 这个私有链表的首部：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line"><span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *_<span class="title">rebindings_head</span>;</span></span><br></pre></td></tr></table></figure><p>这样可以通过判断 _rebindings_head-&gt;next 的值来判断是否为第一次调用，然后使用 _dyld_register_func_for_add_image 将 _rebind_symbols_for_image 注册为回调或者为所有存在的镜像单独调用 _rebind_symbols_for_image：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_rebind_symbols_for_image 只是对另一个名字非常相似的函数 rebind_symbols_for_image 的封装，从这个函数开始，就到了重绑定符号的过程；不过由于这个方法的实现比较长，具体分析会分成三个部分并省略一些不影响理解的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line"><span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line"><span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line"><span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">linkedit_segment = cur_seg_cmd;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的代码主要功能是从镜像中查找 linkedit_segment symtab_command 和 dysymtab_command；在开始查找之前，要先跳过 mach_header_t 长度的位置，然后将当前指针强转成 segment_command_t，通过对比 cmd 的值，来找到需要的 segment_command_t。</p><p>在查找了几个关键的 segment 之后，我们可以根据几个 segment 获取对应表的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line"><span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line"><span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 linkedit_segment 结构体中获得其虚拟地址以及文件偏移量，然后通过一下公式来计算当前 __LINKEDIT 段的位置：</p><p><code>slide + vmaffr - fileoff</code></p><p>类似地，在 symtab_command 中获取符号表偏移量和字符串表偏移量，从 dysymtab_command 中获取间接符号表（indirect symbol table）偏移量，就能够获得<em>符号表</em>、<em>字符串表</em>以及<em>间接符号表</em>的引用了。</p><ul><li>间接符号表中的元素都是 uint32_t *，指针的值是对应条目 n_list 在符号表中的位置</li><li><p>符号表中的元素都是 nlist_t 结构体，其中包含了当前符号在字符串表中的下标</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">&#125; n_un;</span><br><span class="line"><span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line"><span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line"><span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line"><span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>字符串表中的元素是 char 字符</p></li></ul><p>该函数的最后一部分就开启了遍历模式，查找整个镜像中的 SECTION_TYPE 为 S_LAZY_SYMBOL_POINTERS 或者 S_NON_LAZY_SYMBOL_POINTERS 的 section，然后调用下一个函数 perform_rebinding_with_section 来对 section 中的符号进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">section_t</span> *section, <span class="keyword">intptr_t</span> slide, <span class="keyword">nlist_t</span> *symtab, <span class="keyword">char</span> *strtab, <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line"><span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line"><span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line"><span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line"><span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">&#125;</span><br><span class="line">indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line"><span class="keyword">goto</span> symbol_loop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">symbol_loop:;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的实现的核心内容就是将符号表中的 symbol_name 与 rebinding 中的名字 name 进行比较，如果出现了匹配，就会将原函数的实现传入 origian_open 函数指针的地址，并使用新的函数实现 new_open 代替原实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; <span class="comment">// 将原函数的实现传入 original_open 函数指针的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; // 使用新的函数实现 new_open 替换原实现<br>如果你理解了上面的实现代码，该函数的其它代码就很好理解了：</p><ol><li>通过 indirect_symtab + section-&gt;reserved1 获取 indirect_symbol_indices *，也就是符号表的数组</li><li>通过 (void **)((uintptr_t)slide + section-&gt;addr) 获取函数指针列表 indirect_symbol_bindings</li><li>遍历符号表数组 indirect_symbol_indices * 中的所有符号表中，获取其中的符号表索引 symtab_index</li><li>通过符号表索引 symtab_index 获取符号表中某一个 n_list 结构体，得到字符串表中的索引 symtab[symtab_index].n_un.n_strx</li><li>最后在字符串表中获得符号的名字 char *symbol_name</li></ol><p>到这里比较前的准备工作就完成了，剩下的代码会遍历整个 rebindings_entry 数组，在其中查找匹配的符号，完成函数实现的替换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">&#125;</span><br><span class="line">indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line"><span class="keyword">goto</span> symbol_loop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之后对某一函数的调用（例如 open），当查找其函数实现时，都会查找到 new_open 的函数指针；在 new_open 调用 origianl_open 时，同样也会执行原有的函数实现，因为我们通过 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i] 将原函数实现绑定到了新的函数指针上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇 &lt;a href=&quot;/essay/LLDB/Mach-O_fishhook/&quot;&gt;Mach-O应用 fishhook动态修改C函数&lt;/a&gt; 了解了fishhook的原理，现在来看一下它的代码，看它是如何一步一步替换原有函数实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="重学iOS" scheme="https://developerdoc.com/categories/%E9%87%8D%E5%AD%A6iOS/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="fishhook" scheme="https://developerdoc.com/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O应用 fishhook动态修改C函数</title>
    <link href="https://developerdoc.com/essay/LLDB/Mach-O_fishhook/"/>
    <id>https://developerdoc.com/essay/LLDB/Mach-O_fishhook/</id>
    <published>2019-04-29T12:10:20.000Z</published>
    <updated>2019-05-08T02:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fishhook简介"><a href="#fishhook简介" class="headerlink" title="fishhook简介"></a>fishhook简介</h2><p>C 语言往往会给我们留下不可修改的这一印象,而 <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> 是一个由 facebook 开源的第三方框架，其主要作用就是<strong>动态修改 C 语言函数实现</strong>。</p><p>这个框架的代码其实非常的简单，只包含两个文件：fishhook.c 以及 fishhook.h；两个文件所有的代码加起来也不超过 300 行。不过它的实现原理是非常有意思并且精妙的</p><p>fishhook 提供非常简单的两个接口以及一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">void</span> *replacement;</span><br><span class="line"><span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,<span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以从 fishhook 提供的demo中上手实践一下,这里的demo对 <code>close</code> 进行修改:</p><a id="more"></a><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"dlfcn.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个与原函数签名相同的函数指针,用保存原始的函数的地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> (*orig_close)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的close</span></span><br><span class="line"><span class="keyword">int</span> my_close(<span class="keyword">int</span> fd) &#123;</span><br><span class="line">    printf(<span class="string">"做一些额外操作\n"</span>);</span><br><span class="line">    printf(<span class="string">"调用原 close(%d)\n"</span>, fd);</span><br><span class="line">    <span class="comment">//调用的 orig_close 其实相当于执行原 close</span></span><br><span class="line">    <span class="keyword">return</span> orig_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> rebinding closeBind;</span><br><span class="line">        <span class="comment">//函数的名称</span></span><br><span class="line">        closeBind.name = <span class="string">"close"</span>;</span><br><span class="line">        <span class="comment">//新的函数地址</span></span><br><span class="line">        closeBind.replacement = my_close;</span><br><span class="line">        <span class="comment">//保存原始函数地址的变量的指针</span></span><br><span class="line">        closeBind.replaced = (<span class="keyword">void</span> *)&amp;orig_close;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="keyword">struct</span> rebinding rebs[] = &#123;closeBind&#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         对符号进行重绑定 arg1 : 存放rebinding结构体的数组 arg2 : 数组的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rebind_symbols(rebs, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始测试:</span></span><br><span class="line">        <span class="keyword">int</span> fd = open(argv[<span class="number">0</span>], O_RDONLY);</span><br><span class="line">        uint32_t magic_number = <span class="number">0</span>;</span><br><span class="line">        read(fd, &amp;magic_number, <span class="number">4</span>);</span><br><span class="line">        printf(<span class="string">"Mach-O Magic Number: %x \n"</span>, magic_number);</span><br><span class="line">        close(fd);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后查看输出的信息可以看到 在对符号进行重绑定之后，所有调用 <code>close</code> 函数的地方实际上都会执行 <code>my_close</code> 的实现，也就完成了对 <code>close</code> 的修改。</p><p>那么 fishhook 是如何做到的呢？</p><h2 id="fishhook-原理"><a href="#fishhook-原理" class="headerlink" title="fishhook 原理"></a>fishhook 原理</h2><p>fishhook 是 FaceBook 开源的可以动态修改 MachO 符号表的工具。fishhook 的强大之处在于它可以 HOOK 系统的静态 C 函数。</p><p>大家都知道 OC 的方法之所以可以 HOOK 是因为它的运行时特性，OC 的方法调用在底层都是 msg_send（id,SEL）的形式，这为我们提供了交换方法实现（IMP）的机会，但 C 函数在编译链接时就确定了函数指针的地址偏移量（Offset），这个偏移量在编译好的可执行文件中是固定的。既然 C 函数的指针地址是相对固定且不可修改的，那么 fishhook 又是怎么实现 对 C 函数的 HOOK 呢？<strong>其实内部/自定义的 C 函数 fishhook 也 HOOK 不了，它只能HOOK Mach-O 外部（共享缓存库中）的函数</strong>。</p><p>现在先来看一下以下这几个知识点:</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接就是负责将各种各样程序需要的镜像加载到程序运行的内存空间中，这个过程发生的时间非常早： <em>在 objc 运行时初始化之前</em> 。</p><p>先来看一个简单的demo为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helloFishhook.m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如我们在 <a href="/essay/LLDB/iOS_Compiler/">iOS编译过程</a> 中实践的一样 ，先用clang编译一下，再用<code>nm</code>命令查看符号:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#clang helloFishhook.m</span></span><br><span class="line"><span class="comment">#nm -nm a.out </span></span><br><span class="line">                 (undefined) external _printf (from libSystem)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000f30 (__TEXT,__text) external _hello_world</span><br><span class="line">0000000100000f50 (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure><p>可以看到自己写的方法 <code>_hello_world</code> ,它包含一个内存地址以及 __TEXT 段。也就是说手写的一些函数，在编译之后，其地址并不是未定义的</p><p>与之对比的是看到 <code>_printf</code> 这个符号是未定义的(undefined),<code>dyld_stub_binder</code> 会在目标符号（例如 printf）被调用时，将其链接到指定的动态链接库 libSystem，再执行 printf 的实现</p><p>每一个镜像中的 <strong>DATA 端都包含两个与动态链接有关的表，其中一个是 </strong>nl_symbol_ptr，另一个是 <code>__la_symbol_ptr</code>：</p><ul><li><code>__nl_symbol_ptr</code> 中的 non-lazy 符号是在动态链接库绑定的时候进行加载的</li><li><code>__la_symbol_ptr</code> 中的符号会在该符号被第一次调用时，通过 dyld 中的 dyld_stub_binder 过程来进行加载</li></ul><p>了解这两点的区别，你也大概可以猜出 fishhook 为什么能替换原C函数了。</p><h3 id="PIC（Position-independent-code"><a href="#PIC（Position-independent-code" class="headerlink" title="PIC（Position-independent code)"></a>PIC（Position-independent code)</h3><p>为什么 printf 是未定义的？</p><p>ASLR技术：是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度。对于我们APP而言，它保证每次MachO文件加载的时候是随机地址  <strong>这个我们可以通过LLDB指令的image list去查看</strong></p><p>苹果采用了PIC（Position-independent code）技术成功让 C 的底层也能有动态的表现：</p><ul><li>编译时在 Mach-O 文件 _DATA 段的符号表中为每一个被引用的系统 C 函数建立一个指针（8字节的数据，放的全是0），这个指针用于动态绑定时重定位到共享库中的函数实现。</li><li>在运行时当系统 C 函数被第一次调用时会动态绑定一次，然后将 Mach-O 中的 _DATA 段符号表中对应的指针，指向外部函数（其在共享库中的实际内存地址）。</li></ul><p>fishhook 正是利用了 PIC 技术做了这么两个操作：</p><ul><li>将指向系统方法（外部函数）的指针重新进行绑定指向内部函数/自定义 C 函数。</li><li>将内部函数的指针在动态链接时指向系统方法的地址。</li></ul><p>这样就把系统方法与自己定义的方法进行了交换，达到 HOOK 系统 C 函数（共享库中的）的目的。</p><h3 id="dyld-加载回调"><a href="#dyld-加载回调" class="headerlink" title="dyld 加载回调"></a>dyld 加载回调</h3><p>在 dyld 加载镜像时，会执行注册过的回调函数; 对于每一个已经存在的镜像，当它被动态链接时，都会执行回调 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">const</span> struct mach_header* mh, <span class="keyword">intptr_t</span> vmaddr_slide)</span><br></pre></td></tr></table></figure><p>传入文件的 <code>mach_header</code> 以及一个虚拟内存地址 <code>intptr_t</code>。</p><p>dyld 通过更新 Mach-O 二进制文件 __DATA 段中的一些指针来绑定 lazy 和 non-lazy 的符号；</p><p>而 fishhook 先确定某一个符号在 __DATA 段中的位置，<strong>然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</strong></p><h2 id="fishhook-是如何根据字符串找到对应指针在符号表中的偏移值的"><a href="#fishhook-是如何根据字符串找到对应指针在符号表中的偏移值的" class="headerlink" title="fishhook 是如何根据字符串找到对应指针在符号表中的偏移值的"></a>fishhook 是如何根据字符串找到对应指针在符号表中的偏移值的</h2><p>直接上fishhook 的 README 中的流程图：</p><p><img src="/res/MachO/fishhook1.png" width="60%"></p><p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p><ol><li>从 __DATA 段中的 lazy 符号指针表中查找某个符号，获得这个符号的偏移量 1061，然后在每一个 section_64 中查找 reserved1，通过这两个值找到 Indirect Symbol Table 中符号对应的条目</li><li>在 Indirect Symbol Table 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</li><li>然后通过符号表中的偏移量，获取字符串表中的符号 <code>_close</code></li></ol><p>图示中，1061 是间接符号表的偏移量，*（偏移量+间接符号地址）=16343，即符号表偏移量。符号表中每一个结构都是一个 nlist 结构体，其中包含字符表偏移量。通过字符表偏移量最终确定函数指针。</p><p>fishhook 就是对间接符号表的偏移量动的手脚，提供一个假的 nlist 结构体，从而达到 hook 的目的。</p><p>上面的流程图其实已经显示的很清楚了，这里我们重新来走一遍，一步步找到其在 MachO 文件里对应指针的偏移值，大致步骤如下：</p><p><strong>1.在 String Table 中找到该字符串在 Symbols Table -&gt; Symbols 中的位置：</strong></p><p><img src="/res/MachO/fishhook2.png" alt></p><p>用 0x9832 - 0x9780 = 0xB2</p><p><strong>2.在 Symbols Table -&gt; Symbols 中找到Data = 0xB2 的符号，其对应的 offset 值 0x16F 就是该符号在 Dynamic Symbols Table -&gt; Indirect Symbols 表中的 Data 值</strong></p><p><img src="/res/MachO/fishhook3.png" alt></p><p><strong>3.在 Dynamic Symbols Table -&gt; Indirect Symbols 表中找到 Data 值为 0x16F 的符号，其位于该表中的位置（第一个）就是它在懒加载表中对应的位置。</strong></p><p><img src="/res/MachO/fishhook4.png" alt></p><p><strong>4.懒加载表中对应位置的 Offset 值就是该指针最终的偏移量：</strong></p><p><img src="/res/MachO/fishhook5.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;fishhook简介&quot;&gt;&lt;a href=&quot;#fishhook简介&quot; class=&quot;headerlink&quot; title=&quot;fishhook简介&quot;&gt;&lt;/a&gt;fishhook简介&lt;/h2&gt;&lt;p&gt;C 语言往往会给我们留下不可修改的这一印象,而 &lt;a href=&quot;https://github.com/facebook/fishhook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;fishhook&lt;/a&gt; 是一个由 facebook 开源的第三方框架，其主要作用就是&lt;strong&gt;动态修改 C 语言函数实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个框架的代码其实非常的简单，只包含两个文件：fishhook.c 以及 fishhook.h；两个文件所有的代码加起来也不超过 300 行。不过它的实现原理是非常有意思并且精妙的&lt;/p&gt;
&lt;p&gt;fishhook 提供非常简单的两个接口以及一个结构体：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rebinding&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *replacement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; **replaced;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rebind_symbols&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(struct rebinding rebindings[], &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; rebindings_nel)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;rebind_symbols_image&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *header,&lt;span class=&quot;keyword&quot;&gt;intptr_t&lt;/span&gt; slide,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;struct rebinding rebindings[],&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; rebindings_nel)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以从 fishhook 提供的demo中上手实践一下,这里的demo对 &lt;code&gt;close&lt;/code&gt; 进行修改:&lt;/p&gt;
    
    </summary>
    
      <category term="重学iOS" scheme="https://developerdoc.com/categories/%E9%87%8D%E5%AD%A6iOS/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="fishhook" scheme="https://developerdoc.com/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>Mach-O文件格式字段简介</title>
    <link href="https://developerdoc.com/essay/LLDB/Mach-O_file/"/>
    <id>https://developerdoc.com/essay/LLDB/Mach-O_file/</id>
    <published>2019-04-18T06:36:20.000Z</published>
    <updated>2020-02-07T08:45:35.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本次来学习下Mach-O文件的格式,Mach-O（Mach Object File Format） 是针对不同运行时可执行文件的文件类型。</p><p>文件类型：</p><p>Executable： 应用的主要二进制<br>Dylib： 动态链接库（又称 DSO 或 DLL）<br>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。</p><p>Mach-O 文件格式如下:</p><p><img src="/res/MachO/macho_struct.png" width="70%"><br><a id="more"></a></p><p><strong>如何查看文件格式:</strong></p><p>我们可以通过file指令查看文件的具体格式:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file asdasd</span><br><span class="line">asdasd: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure><p>目前已知的架构分为armv7,armv7s,arm64,i386,x86_64等等，MachO中其实也是这些架构的集合。MachO可以是多架构的二进制文件，称之为「通用二进制文件」</p><p><strong>拆分、重组MachO</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用lipo -info 可以查看MachO文件包含的架构</span></span><br><span class="line">$ lipo -info MachO文件</span><br><span class="line"><span class="comment">#  使用lipo –thin 拆分某种架构</span></span><br><span class="line">$ lipo MachO文件 –thin 架构 –output 输出文件路径</span><br><span class="line"><span class="comment">#  使用lipo -create  合并多种架构</span></span><br><span class="line">$ lipo -create MachO1  MachO2  -output 输出文件路径</span><br></pre></td></tr></table></figure><h2 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a>Mach-O文件格式</h2><p>新建一个单页面工程 使用 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView</a> 来查看.app包内的mach-o文件:</p><p><img src="/res/MachO/macho1.png" alt></p><p>结合可知 Mach-O 文件包含了三部分内容：</p><ul><li>Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息</li><li>Load Commands（加载命令)，正如官方的图所示，描述了怎样加载每个 Segment 的信息。在 Mach-O 文件中可以有多个 Segment，每个 Segment 可能包含一个或多个 Section。</li><li>Data（数据区），Segment 的具体数据，包含了代码和数据等。</li></ul><p><em>需要注意的是，不仅仅是可执行文件是Macho-O，目标文件(.o)以及动态库，静态库都是Mach-O格式。</em></p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Mach-O 文件的头部定义如下 <a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="noopener">loader.h</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>magic;<span class="comment">/* 标志符 0xfeedface 是 32 位， 0xfeedfacf 是 64 位。*/</span></span><br><span class="line"><span class="keyword">cpu_type_t</span>cputype;<span class="comment">/* cpu 类型、平台 */</span></span><br><span class="line"><span class="keyword">cpu_subtype_t</span>cpusubtype;<span class="comment">/* cpu 类型、平台 */</span></span><br><span class="line"><span class="keyword">uint32_t</span>filetype;<span class="comment">/* 文件类型，可执行文件、符号文件（DSYM）、内核扩展等 */</span></span><br><span class="line"><span class="keyword">uint32_t</span>ncmds;<span class="comment">/* 加载 Load Commands 的数量 */</span></span><br><span class="line"><span class="keyword">uint32_t</span>sizeofcmds;<span class="comment">/* 加载 Load Commands 的大小 */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* dyld 动态链接器 加载的标志*/</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved;<span class="comment">/* 64 位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上图中看出<code>asdasd</code>这个文件header对应的是 <code>MH_MAGIC_64</code> 、<code>CPU_TYPE_X86_64_ALL</code> 、<code>MH_EXECUTE</code>…等</p><p>filetype的定义有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_OBJECT    0x1        <span class="comment">/* Target 文件：编译器对源码编译后得到的中间结果 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_EXECUTE    0x2        <span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_FVMLIB    0x3        <span class="comment">/* VM 共享库文件（还不清楚是什么东西） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_CORE        0x4        <span class="comment">/* Core 文件，一般在 App Crash 产生 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_PRELOAD    0x5        <span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLIB    0x6        <span class="comment">/* 动态库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLINKER    0x7        <span class="comment">/* 动态连接器 /usr/lib/dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_BUNDLE    0x8        <span class="comment">/* 非独立的二进制文件，往往通过 gcc-bundle 生成 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLIB_STUB    0x9        <span class="comment">/* 静态链接文件（还不清楚是什么东西） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DSYM        0xa        <span class="comment">/* 符号文件以及调试信息，在解析堆栈符号中常用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_KEXT_BUNDLE    0xb        <span class="comment">/* x86_64 内核扩展 */</span></span></span><br></pre></td></tr></table></figure><p>和部分flags定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_NOUNDEFS    0x1        <span class="comment">/* Target 文件中没有带未定义的符号，常为静态二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS    0x20  <span class="comment">/* Target 文件中的只读 Segment 和可读写 Segment 分开  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL    0x80        <span class="comment">/* 该 Image 使用二级命名空间(two name space binding)绑定方案 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT    0x100 <span class="comment">/* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES    0x8000 <span class="comment">/* 二进制文件使用了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000 <span class="comment">/* 二进制文件链接了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* 允许 Stack 可执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_PIE 0x200000  <span class="comment">/* 对可执行的文件类型启用地址空间 layout 随机化 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000 <span class="comment">/* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Mach-O 文件头主要目的是为加载命令提供信息。加载命令过程紧跟在头之后，并且 ncmds 和 sizeofcmds 来能个字段将会用在加载命令的过程中。</p><h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Headers之后就是Load Commands,其占用的内存和加载命令总数已经在Header中 ncmds/sizeofcmds 中指出。</p><p><img src="/res/MachO/loadcommand1.png" alt></p><p>load commands的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> cmd;<span class="comment">/*  load command 类型*/</span></span><br><span class="line"><span class="keyword">uint32_t</span> cmdsize;<span class="comment">/* command大小 用于计算出到下一个 command 的偏移量*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>cmd 字段指出了 command 类型,主要有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line">LC_SEGMENT、LC_SEGMENT_64 将 segment 映射到进程的内存空间，</span><br><span class="line">LC_UUID 二进制文件 id，与符号表 uuid 对应，可用作符号表匹配，</span><br><span class="line">LC_LOAD_DYLINKER 启动动态加载器，</span><br><span class="line">LC_SYMTAB 描述在 __LINKEDIT 段的哪找字符串表、符号表，</span><br><span class="line">LC_CODE_SIGNATURE 代码签名等</span><br></pre></td></tr></table></figure><p>LC_SEGMENT_64和LC_SEGMENT是加载的主要命令，它负责指导内核来设置进程的内存空间。一般Mach-O文件有多个段(Segement)，段每个段有不同的功能，一般包括：</p><ol><li>__PAGEZERO: 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用；</li><li>__TEXT: 包含了执行代码以及其他只读数据。该段数据的保护级别为：VM_PROT_READ（读）、VM_PROT_EXECUTE(执行)，防止在内存中被修改；</li><li>__DATA: 包含了程序数据，该段可写；</li><li>__LINKEDIT: 链接器使用的符号以及其他表</li></ol><h3 id="Segment-amp-Section"><a href="#Segment-amp-Section" class="headerlink" title="Segment &amp; Section"></a>Segment &amp; Section</h3><p>Segment定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* section_64 结构体所需要的空间 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment 名字，上述宏中的定义 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;        <span class="comment">/* 所描述段的虚拟内存地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;        <span class="comment">/* 为当前段分配的虚拟内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;    <span class="comment">/* 当前段在文件中的偏移量 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;    <span class="comment">/* 当前段在文件中占用的字节 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    maxprot;    <span class="comment">/* 段所在页所需要的最高内存保护，用八进制表示 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    initprot;    <span class="comment">/* 段所在页原始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;        <span class="comment">/* 段中 Section 数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 标识符 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 segname 在源码中定义的宏，有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_PAGEZERO    <span class="meta-string">"__PAGEZERO"</span> <span class="comment">/* 当时 MH_EXECUTE 文件时，捕获到空指针 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_TEXT    <span class="meta-string">"__TEXT"</span> <span class="comment">/* 代码/只读数据段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_DATA    <span class="meta-string">"__DATA"</span> <span class="comment">/* 数据段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_OBJC    <span class="meta-string">"__OBJC"</span> <span class="comment">/* Objective-C runtime 段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_LINKEDIT    <span class="meta-string">"__LINKEDIT"</span> <span class="comment">/* 包含需要被动态链接器使用的符号和其他表，包括符号表、字符串表等 */</span></span></span><br></pre></td></tr></table></figure><p>部分的 Segment （主要指的 <code>__TEXT</code> 和 <code>__DATA</code>）可以进一步分解为 Section。之所以按照 Segment -&gt; Section 的结构组织方式，是因为在同一个 Segment 下的 Section，可以控制相同的权限，也可以不完全按照 Page 的大小进行内存对其，节省内存的空间。而 Segment 对外整体暴露，在程序载入阶段映射成一个完整的虚拟内存，更好的做到内存对齐（可以继续参考 OS X &amp; iOS Kernel Programming 一书的第一章内容)</p><p>Section定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];    <span class="comment">/* Section 名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;        <span class="comment">/* Section 所在的内存地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;        <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;        <span class="comment">/* Section 所在的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;        <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;        <span class="comment">/* 重定位信息的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;        <span class="comment">/* 重定位条目的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;    <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;    <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;    <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面列举一些常见的 Section。</p><table><thead><tr><th style="text-align:left">Section</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>__TEXT.__text</code></td><td style="text-align:center">主程序代码</td></tr><tr><td style="text-align:left"><code>__TEXT.__cstring</code></td><td style="text-align:center">C 语言字符串</td></tr><tr><td style="text-align:left"><code>__TEXT.__const</code></td><td style="text-align:center">const 关键字修饰的常量</td></tr><tr><td style="text-align:left"><code>__TEXT.__stubs</code></td><td style="text-align:center">用于 Stub 的占位代码，很多地方称之为桩代码。</td></tr><tr><td style="text-align:left"><code>__TEXT.__stubs_helper</code></td><td style="text-align:center">当 Stub 无法找到真正的符号地址后的最终指向</td></tr><tr><td style="text-align:left"><code>__TEXT.__objc_methname</code></td><td style="text-align:center">Objective-C 方法名称</td></tr><tr><td style="text-align:left"><code>__TEXT.__objc_methtype</code></td><td style="text-align:center">Objective-C 方法类型</td></tr><tr><td style="text-align:left"><code>__TEXT.__objc_classname</code></td><td style="text-align:center">Objective-C 类名称</td></tr><tr><td style="text-align:left"><code>__DATA.__data</code></td><td style="text-align:center">初始化过的可变数据</td></tr><tr><td style="text-align:left"><code>__DATA.__la_symbol_ptr</code></td><td style="text-align:center">lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td></tr><tr><td style="text-align:left"><code>__DATA.__nl_symbol_ptr</code></td><td style="text-align:center">非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td></tr><tr><td style="text-align:left"><code>__DATA.__const</code></td><td style="text-align:center">没有初始化过的常量</td></tr><tr><td style="text-align:left"><code>__DATA.__cfstring</code></td><td style="text-align:center">程序中使用的 Core Foundation 字符串（CFStringRefs）</td></tr><tr><td style="text-align:left"><code>__DATA.__bss</code></td><td style="text-align:center">BSS，存放为初始化的全局变量，即常说的静态内存分配</td></tr><tr><td style="text-align:left"><code>__DATA.__common</code></td><td style="text-align:center">没有初始化过的符号声明</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_classlist</code></td><td style="text-align:center">Objective-C 类列表</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_protolist</code></td><td style="text-align:center">Objective-C 原型</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_imginfo</code></td><td style="text-align:center">Objective-C 镜像信息</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_selfrefs</code></td><td style="text-align:center">Objective-C self 引用</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_protorefs</code></td><td style="text-align:center">Objective-C 原型引用</td></tr><tr><td style="text-align:left"><code>__DATA.__objc_superrefs</code></td><td style="text-align:center">Objective-C 超类引用</td></tr></tbody></table><p><code>__TEXT.__text</code> 这里存放的是汇编后的代码，当我们进行编译时，每个.m文件会经过预编译-&gt;编译-&gt;汇编形成.o文件，称之为目标文件。汇编后，所有的代码会形成汇编指令存储在.o文件的(<strong>TEXT,</strong>text)区（（<strong>DATA,</strong>data）也是类似）。链接后，所有的.o文件会合并成一个文件，所有.o文件的(<strong>TEXT,</strong>text)数据都会按链接顺序存放到应用文件的(<strong>TEXT,</strong>text)中。</p><p><code>__DATA.__data</code> 存储数据的section，static在进行非零赋值后会存储在这里，如果static 变量没有赋值或者赋值为0，那么它会存储在<code>__DATA.__bss</code>中。</p><p>另外还有 <code>Symbol Table</code>符号表，这个是重点中的重点，符号表是将地址和符号联系起来的桥梁。符号表并不能直接存储符号，而是存储符号位于字符串表的位置。</p><p><code>String Table</code>字符串表所有的变量名、函数名等，都以字符串的形式存储在字符串表中。</p><h3 id="实践：关联类的方法名"><a href="#实践：关联类的方法名" class="headerlink" title="实践：关联类的方法名"></a>实践：关联类的方法名</h3><p>上面说了一大堆定义，来查看使用Mach-O文件呢。这里来看一下如何用 MachO 文件关联类的方法名。</p><p>先来看看 <code>Load Commands</code>里的表示类名的 <code>__objc_classname</code> :</p><p><img src="/res/MachO/macho-find.png" alt></p><p>根据 offset字段 <code>0000425F</code> 值可以找到 section中对应的 <code>__TEXT,__objc_classname</code> 信息:</p><p><img src="/res/MachO/macho-find2.png" alt></p><p>同理可以找到对应方法名的 <code>__objc_methname</code> 和 表示类虚拟地址的 <code>__objc_classlist</code> :</p><p><img src="/res/MachO/macho-find3.png" alt></p><p>其中我们需要查看类的方法名信息就在<code>__objc_classlist</code>中，根据上图中 <code>_OBJC_CLASS_$_ViewController</code> 对应的data : <code>00000001000060E8</code>,可以在<code>__DATA,__objc_data</code>中找到类结构信息：</p><p><img src="/res/MachO/macho-find4.png" alt></p><p>其中data 是我们感兴趣的，它指向 class_ro_t， class_ro_t 存储了类在编译器就确定的属性、方法、协议等。根据data的值 <code>0x100005370</code>就找到了<code>__DATA,__objc_const</code>中：</p><p><img src="/res/MachO/macho-find5.png" alt></p><p>其中baseMethods <code>0x100005350</code> 指向了第一个方法。这样我们就就找到了类的方法名。</p><h2 id="使用命令查看Mach-O信息"><a href="#使用命令查看Mach-O信息" class="headerlink" title="使用命令查看Mach-O信息"></a>使用命令查看Mach-O信息</h2><p>上文是借助 MachOView 这个工具 和 <code>loader.h</code> 来了解Mach-O文件的大概定义，现在我们来使用<code>size</code>和<code>otool</code> 查看一下Mach-O文件。</p><p>如下这样一个 hello.c文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用clang生成Mach-O文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成 hello.out 的 Mach-O 二进制文件</span></span><br><span class="line">xcrun clang hello.c -o hello.out</span><br></pre></td></tr></table></figure><p>可以通过 <code>file</code> 命令来查看简要的架构信息:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file hello.out </span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">hello.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure><h3 id="一、-Section"><a href="#一、-Section" class="headerlink" title="一、 Section"></a>一、 Section</h3><p>就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。</p><p>我们来看看 hello.out 二进制中的 section。我们可以使用 size 工具来观察</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">size -x -l -m hello.out </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</span><br><span class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</span><br><span class="line">Section __text: 0x2a (addr 0x100000f60 offset 3936)</span><br><span class="line">Section __stubs: 0x6 (addr 0x100000f8a offset 3978)</span><br><span class="line">Section __stub_helper: 0x1a (addr 0x100000f90 offset 3984)</span><br><span class="line">Section __cstring: 0xd (addr 0x100000faa offset 4010)</span><br><span class="line">Section __unwind_info: 0x48 (addr 0x100000fb8 offset 4024)</span><br><span class="line">total 0x9f</span><br><span class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</span><br><span class="line">Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</span><br><span class="line">Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</span><br><span class="line">total 0x18</span><br><span class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</span><br><span class="line">total 0x100003000</span><br></pre></td></tr></table></figure><p>如上代码所示，我们的 <code>hello.out</code> 文件有 4 个 segment。有些 segment 中有多个 section。</p><p>当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 – 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。</p><p>当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。</p><p>上面的代码中，__TEXT segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</p><p>__DATA segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</p><p>第一个 segment 是 __PAGEZERO。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 NULL 指针或更小的值时会得到一个 EXC_BAD_ACCESS 错误。这是操作系统在尝试防止引起系统崩溃。</p><p>在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 <strong>TEXT segment 中，</strong>text section 包含了编译所得到的机器码。<strong>stubs 和 </strong>stub_helper 是给动态链接器 (dyld) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。<strong>const (在我们的代码中没有) 是常量，不可变的，就像 </strong>cstring (包含了可执行文件中的字符串常量 – 在源码中被双引号包含的字符串) 常量一样。</p><p><strong>DATA segment 中包含了可读写数据。在我们的程序中只有 </strong>nl_symbol_ptr 和 __la_symbol_ptr，它们分别是 non-lazy 和 lazy 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。</p><p>在 _DATA segment 中的其它常见 section 包括 <strong>const，在这里面会包含一些需要重定向的常量数据。例如 char * const p = “foo”; – p 指针指向的数据是可变的。</strong>bss section 没有被初始化的静态变量，例如 static int a; – ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。<strong>common section 包含未初始化的外部全局变量，跟 static 变量类似。例如在函数外面定义的 int a;。最后，</strong>dyld 是一个 section 占位符，被用于动态链接器。</p><h3 id="二、Section-中的内容"><a href="#二、Section-中的内容" class="headerlink" title="二、Section 中的内容"></a>二、Section 中的内容</h3><p>可以通过 <code>otool</code> 来了解section中的内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">otool -s  __TEXT __text  hello.out </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">hello.out:</span><br><span class="line">Contents of (__TEXT,__text) section</span><br><span class="line">0000000100000f6055 48 89 e5 48 83 ec 10 c7 45 <span class="built_in">fc</span> 00 00 00 00 48 </span><br><span class="line">0000000100000f708d 3d 34 00 00 00 b0 00 e8 0d 00 00 00 31 c9 89 </span><br><span class="line">0000000100000f8045 f8 89 c8 48 83 c4 10 5d c3</span><br></pre></td></tr></table></figure><p>我们还可以通过添加 -v 来查看反汇编代码 , 由于 -s <strong>TEXT </strong>text 很常见，otool 对其设置了一个缩写 -t ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">otool -v -t  hello.out</span><br><span class="line"><span class="comment">#输出 </span></span><br><span class="line">hello.out:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_main:</span><br><span class="line">0000000100000f60pushq%rbp</span><br><span class="line">0000000100000f61movq%rsp, %rbp</span><br><span class="line">0000000100000f64subq<span class="variable">$0x10</span>, %rsp</span><br><span class="line">0000000100000f68movl<span class="variable">$0x0</span>, -0x4(%rbp)</span><br><span class="line">0000000100000f6fleaq0x34(%rip), %rdi</span><br><span class="line">0000000100000f76movb<span class="variable">$0x0</span>, %al</span><br><span class="line">0000000100000f78callq0x100000f8a</span><br><span class="line">0000000100000f7dxorl%ecx, %ecx</span><br><span class="line">0000000100000f7fmovl%eax, -0x8(%rbp)</span><br><span class="line">0000000100000f82movl%ecx, %eax</span><br><span class="line">0000000100000f84addq<span class="variable">$0x10</span>, %rsp</span><br><span class="line">0000000100000f88popq%rbp</span><br><span class="line">0000000100000f89retq</span><br></pre></td></tr></table></figure><p>上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。</p><!-- ## 应用了解Mach-O文件的主要应用之一是代码大小性能优化。### 可执行文件瘦身__objc_classlist 和 __objc_classrefs### 获取调用堆栈 -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;本次来学习下Mach-O文件的格式,Mach-O（Mach Object File Format） 是针对不同运行时可执行文件的文件类型。&lt;/p&gt;
&lt;p&gt;文件类型：&lt;/p&gt;
&lt;p&gt;Executable： 应用的主要二进制&lt;br&gt;Dylib： 动态链接库（又称 DSO 或 DLL）&lt;br&gt;Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。&lt;/p&gt;
&lt;p&gt;Mach-O 文件格式如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/MachO/macho_struct.png&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="重学iOS" scheme="https://developerdoc.com/categories/%E9%87%8D%E5%AD%A6iOS/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="Mach-O" scheme="https://developerdoc.com/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>iOS编译过程</title>
    <link href="https://developerdoc.com/essay/LLDB/iOS_Compiler/"/>
    <id>https://developerdoc.com/essay/LLDB/iOS_Compiler/</id>
    <published>2019-04-10T02:54:52.000Z</published>
    <updated>2019-04-23T02:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><blockquote><p>把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器</p></blockquote><p>大多数编译器由两部分组成：前端和后端。</p><ul><li>前端负责词法分析，语法分析，生成中间代码；</li><li>后端以中间代码作为输入，进行行架构无关的代码优化，接着针对不同架构生成不同的机器码。</li></ul><p>Objective C/C/C++使用的编译器前端是clang，swift是swift，后端都是LLVM。</p><h3 id="llvm介绍"><a href="#llvm介绍" class="headerlink" title="llvm介绍"></a>llvm介绍</h3><p>LLVM是什么，是low level virtual machine的简称，其实是一个编译器框架。LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。编译器前端主要进行语法分析，语义分析，生成中间代码。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。</p><p><img src="/res/LLVM/LLVMCompiler1.png" alt></p><p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。而Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。Clang项目包括Clang前端和Clang静态分析器等。</p><p>下图是iOS编译过程：<br><img src="/res/LLVM/iOSCompiler.png" alt></p><a id="more"></a><h2 id="使用llvm命令"><a href="#使用llvm命令" class="headerlink" title="使用llvm命令"></a>使用llvm命令</h2><p><strong><em>一、使用xcode自带</em></strong></p><p>使用xcrun来调用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -v</span><br><span class="line"><span class="comment">#Apple LLVM version 10.0.0 (clang-1000.11.45.5)</span></span><br><span class="line"><span class="comment">#Target: x86_64-apple-darwin17.7.0</span></span><br><span class="line"><span class="comment">#Thread model: posix</span></span><br><span class="line"><span class="comment">#InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span></span><br></pre></td></tr></table></figure><p><strong><em>二、使用HomeBrew安装</em></strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.使用以下命令安装llvm</span></span><br><span class="line">brew install --with-toolchain llvm</span><br><span class="line"><span class="comment"># 若安装遇到问题 可以先升级brew试试</span></span><br><span class="line"><span class="comment">#   brew update 这会更新 Homebrew 自己</span></span><br><span class="line"><span class="comment">#   brew upgrade 升级所有可以升级的软件们</span></span><br></pre></td></tr></table></figure><p>安装后可以使用 <code>brew info llvm</code> 检查信息。brew安装llvm后，不会直接添加命令的快捷引用，需要自己手动来完成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看llvm的安装路径</span></span><br><span class="line">brew --prefix llvm</span><br><span class="line"><span class="comment"># 添加引用示例：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/llvm/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><!-- https://embeddedartistry.com/blog/2017/2/20/installing-clangllvm-on-osx --><p>这样之后就可以直接调用自己安装的llvm了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang -v</span><br><span class="line"><span class="comment">#clang version 8.0.0 (tags/RELEASE_800/final)</span></span><br><span class="line"><span class="comment">#Target: x86_64-apple-darwin17.7.0</span></span><br><span class="line"><span class="comment">#Thread model: posix</span></span><br><span class="line"><span class="comment">#InstalledDir: /usr/local/opt/llvm/bin</span></span><br></pre></td></tr></table></figure><h2 id="编译器处理过程"><a href="#编译器处理过程" class="headerlink" title="编译器处理过程"></a>编译器处理过程</h2><p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 hello.m 源文件需要几个不同的阶段，上文中安装llvm后，我们可以让通过 clang 命令观察：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sunTongShengdeMacBook-Pro:asdasd suntongsheng$ clang -ccc-print-phases ViewController.m</span><br><span class="line">0: input, &quot;ViewController.m&quot;, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</span><br></pre></td></tr></table></figure><p>可以看到clang将其分为 input、preprocessor 、compiler、backend、assembler、linker、bind-arch几个阶段。</p><ul><li>预处理阶段：符号化、宏定义展开头文件展开</li><li>语法和语义分析阶段：将符号化后的内容转化为一棵解析树、解析树做语义分析 输出一棵抽象语法树</li><li>生成代码和优化阶段：将 AST 转换为更低级的中间码 (LLVM IR)、对生成的中间码做优化、生成特定目标代码、输出汇编代码</li><li>汇编器阶段：将汇编代码转换为目标对象文件。</li><li>链接器：将多个目标对象文件合并为一个可执行文件 (或者一个动态库)</li></ul><h3 id="preprocessor-预处理"><a href="#preprocessor-预处理" class="headerlink" title="preprocessor 预处理"></a>preprocessor 预处理</h3><p>每当编源译文件的时候，编译器首先做的是一些预处理工作。具体表现为import头文件替换、macro宏展开、其他预编译指令，`#这个符号是编译器预处理的标志。</p><p><strong><em>一. 对头文件的处理：</em></strong></p><p>例如，如果在源文件中出现下述代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多</p><p><strong>示例</strong>：假设我们写了一个简单的 C 程序 hello.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello llvm\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后给上面的代码执行以下预处理命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  -E  Only run the preprocessor</span></span><br><span class="line">clang -E hello.c &gt;&gt; hello.o</span><br></pre></td></tr></table></figure><p>打开 hello.o ，发现有542行。但是如果在上述代码上加上 <code>#import &lt;Foundation/Foundation.h&gt;</code> ，hello.o 的行数暴增到9万多行。（当然对于这种情况引入了<a href="http://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">模块 - modules</a>功能）</p><p>打开模块功能再试试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-fmodules 允许modules的语言特性</span></span><br><span class="line">clang  -fmodules -E  hello.c &gt;&gt; hello.1o</span><br><span class="line"></span><br><span class="line"><span class="comment">#hello.1o的内容：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 "hello.c"</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 1</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 3</span></span><br><span class="line"><span class="comment"># 361 "&lt;built-in&gt;" 3</span></span><br><span class="line"><span class="comment"># 1 "&lt;command line&gt;" 1</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 2</span></span><br><span class="line"><span class="comment"># 1 "hello.c" 2</span></span><br><span class="line"><span class="comment">#pragma clang module import Darwin.C.stdio /* clang -E: implicit import for #include &lt;stdio.h&gt; */</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello llvm\n"</span>);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>二、对于宏的处理</em></strong></p><p>假设一段这样的代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"largest: %d\n"</span>, MAX(i++,<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i: %d\n"</span>, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>clang -E hello.c</code> 进行宏展开的预处理结果是如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"largest: %d\n"</span>, i++ &gt; <span class="number">100</span> ? i++ : <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i: %d\n"</span>, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>i++</code>被替换到了<code>a</code>中，而不是预想的 i++的值。</p><h3 id="compiler-词法分析解析标记"><a href="#compiler-词法分析解析标记" class="headerlink" title="compiler 词法分析解析标记"></a>compiler 词法分析解析标记</h3><h4 id="一、词法分析-Lexical-Analysis"><a href="#一、词法分析-Lexical-Analysis" class="headerlink" title="一、词法分析-Lexical Analysis"></a>一、词法分析-Lexical Analysis</h4><p>在compiler阶段，首先代码文本都会从 string 转化成特殊的标记流。将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 例如，下面这段程序：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"hello, %@"</span>, <span class="string">@"world"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 clang 命令 clang -Xclang -dump-tokens hello.m 来将上面代码的标记流导出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#clang -Xclang -dump-tokens hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出：</span></span><br><span class="line">int <span class="string">'int'</span> [StartOfLine]Loc=&lt;hello.c:1:1&gt;</span><br><span class="line">identifier <span class="string">'main'</span> [LeadingSpace]Loc=&lt;hello.c:1:5&gt;</span><br><span class="line">l_paren <span class="string">'('</span>Loc=&lt;hello.c:1:9&gt;</span><br><span class="line">r_paren <span class="string">')'</span>Loc=&lt;hello.c:1:10&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span> [LeadingSpace]Loc=&lt;hello.c:1:12&gt;</span><br><span class="line">identifier <span class="string">'NSLog'</span> [StartOfLine] [LeadingSpace]Loc=&lt;hello.c:2:3&gt;</span><br><span class="line">l_paren <span class="string">'('</span>Loc=&lt;hello.c:2:8&gt;</span><br><span class="line">unknown <span class="string">'@'</span>Loc=&lt;hello.c:2:9&gt;</span><br><span class="line">string_literal <span class="string">'"hello, %@"'</span>Loc=&lt;hello.c:2:10&gt;</span><br><span class="line">comma <span class="string">','</span>Loc=&lt;hello.c:2:21&gt;</span><br><span class="line">unknown <span class="string">'@'</span> [LeadingSpace]Loc=&lt;hello.c:2:23&gt;</span><br><span class="line">string_literal <span class="string">'"world"'</span>Loc=&lt;hello.c:2:24&gt;</span><br><span class="line">r_paren <span class="string">')'</span>Loc=&lt;hello.c:2:31&gt;</span><br><span class="line">semi <span class="string">';'</span>Loc=&lt;hello.c:2:32&gt;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'return'</span> [StartOfLine] [LeadingSpace]Loc=&lt;hello.c:3:3&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span> [LeadingSpace]Loc=&lt;hello.c:3:10&gt;</span><br><span class="line">semi <span class="string">';'</span>Loc=&lt;hello.c:3:11&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span> [StartOfLine]Loc=&lt;hello.c:4:1&gt;</span><br><span class="line">eof <span class="string">''</span>Loc=&lt;hello.c:4:2&gt;</span><br></pre></td></tr></table></figure><p>每一个标记都包含了对应的源码内容和其在源码中的位置,如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p><h4 id="二、语法分析-Semantic-Analysis"><a href="#二、语法分析-Semantic-Analysis" class="headerlink" title="二、语法分析 - Semantic Analysis"></a>二、语法分析 - Semantic Analysis</h4><p>之后上面的标记流会解析生成<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">抽象语法树</a>，我们可以使用 <code>clang -Xclang -ast-dump -fsyntax-only hello.c</code> 来展现解析这个过程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clang -Xclang -ast-dump -fsyntax-only hello.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出：</span></span><br><span class="line">hello.c:2:3: warning: implicit declaration of <span class="keyword">function</span> <span class="string">'NSLog'</span> is invalid <span class="keyword">in</span> C99 [-Wimplicit-function-declaration]</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">  ^</span><br><span class="line">hello.c:2:9: error: expected expression</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">        ^</span><br><span class="line">hello.c:2:23: error: expected expression</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">                      ^</span><br><span class="line">TranslationUnitDecl 0x7fe1d2816c08 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</span><br><span class="line">|-TypedefDecl 0x7fe1d28174a0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t <span class="string">'__int128'</span></span><br><span class="line">| `-BuiltinType 0x7fe1d28171a0 <span class="string">'__int128'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817508 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t <span class="string">'unsigned __int128'</span></span><br><span class="line">| `-BuiltinType 0x7fe1d28171c0 <span class="string">'unsigned __int128'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d28177b8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString <span class="string">'struct __NSConstantString_tag'</span></span><br><span class="line">| `-RecordType 0x7fe1d28175d0 <span class="string">'struct __NSConstantString_tag'</span></span><br><span class="line">|   `-Record 0x7fe1d2817558 <span class="string">'__NSConstantString_tag'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817850 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list <span class="string">'char *'</span></span><br><span class="line">| `-PointerType 0x7fe1d2817810 <span class="string">'char *'</span></span><br><span class="line">|   `-BuiltinType 0x7fe1d2816ca0 <span class="string">'char'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817af8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list <span class="string">'struct __va_list_tag [1]'</span></span><br><span class="line">| `-ConstantArrayType 0x7fe1d2817aa0 <span class="string">'struct __va_list_tag [1]'</span> 1 </span><br><span class="line">|   `-RecordType 0x7fe1d2817920 <span class="string">'struct __va_list_tag'</span></span><br><span class="line">|     `-Record 0x7fe1d28178a0 <span class="string">'__va_list_tag'</span></span><br><span class="line">`-FunctionDecl 0x7fe1d285d000 &lt;hello.c:1:1, line:4:1&gt; line:1:5 main <span class="string">'int ()'</span></span><br><span class="line">  `-CompoundStmt 0x7fe1d285d1f8 &lt;col:12, line:4:1&gt;</span><br><span class="line">    `-ReturnStmt 0x7fe1d285d1e8 &lt;line:3:3, col:10&gt;</span><br><span class="line">      `-IntegerLiteral 0x7fe1d285d1c8 &lt;col:10&gt; <span class="string">'int'</span> 0</span><br></pre></td></tr></table></figure><p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p><h4 id="三、静态分析-Static-Analyzer"><a href="#三、静态分析-Static-Analyzer" class="headerlink" title="三、静态分析 - Static Analyzer"></a>三、静态分析 - Static Analyzer</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#命令行执行 通过clang -cc1 -analyzer-checker-help可以列出能调用的 checker，但这些checker并不是所有都是默认开启的</span></span><br><span class="line">clang -cc1 -analyzer-checker-help</span><br><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg</span><br><span class="line">                                  Check <span class="keyword">for</span> logical errors <span class="keyword">for</span> <span class="keyword">function</span> calls and Objective-C message expressions (e.g., uninitialized arguments, null <span class="keyword">function</span> pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when castin</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>使用<a href="http://clang-analyzer.llvm.org.cn/scan-build.html" target="_blank" rel="noopener">scan-build</a>可以从命令行运行分析器,类似如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scan-build xcodebuild -project asdasd.xcodeproj</span><br><span class="line">scan-build: Using <span class="string">'/usr/local/Cellar/llvm/8.0.0/bin/clang-8'</span> <span class="keyword">for</span> static analysis</span><br><span class="line">Build settings from <span class="built_in">command</span> line:</span><br><span class="line">    CLANG_ANALYZER_EXEC = /usr/<span class="built_in">local</span>/Cellar/llvm/8.0.0/bin/clang-8</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS = </span><br><span class="line">    CLANG_ANALYZER_OUTPUT = plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR = /var/folders/s6/5jq8fd4x12v9blzt68qbv18m0000gn/T/scan-build-2019-04-18-141047-45509-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER = YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">error: Signing <span class="keyword">for</span> <span class="string">"asdasd"</span> requires a development team. Select a development team <span class="keyword">in</span> the project editor. (<span class="keyword">in</span> target <span class="string">'asdasd'</span>)</span><br><span class="line"></span><br><span class="line">** BUILD FAILED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory <span class="string">'/var/folders/s6/5jq8fd4x12v9blzt68qbv18m0000gn/T/scan-build-2019-04-18-141047-45509-1'</span> because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure><p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org.cn/" target="_blank" rel="noopener">Clang 静态分析器</a></p><!-- https://juejin.im/post/5a30ea0ff265da43094526f9 --><h3 id="生成代码和优化阶段"><a href="#生成代码和优化阶段" class="headerlink" title="生成代码和优化阶段"></a>生成代码和优化阶段</h3><p><strong><em>一、生成 LLVM 代码</em></strong></p><p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看hello.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p><p><code>clang  -emit-llvm hello.c -c -o hello.bc</code></p><p>接着用另一个命令来查看刚刚生成的二进制文件：</p><p><code>llvm-dis &lt; hello.bc | less</code></p><p>部分输出如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = '&lt;stdin&gt;'</span><br><span class="line">source_filename = <span class="string">"hello.c"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"x86_64-apple-macosx10.13.0"</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">13</span> x i8] c<span class="string">"hello world\0A\00"</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = call i32 (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr inbounds ([<span class="number">13</span> x i8], [<span class="number">13</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong><em>二、优化 LLVM 代码</em></strong></p><p>LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass — LLVM 5 documentation</a> 。如果开启了 bitcode 苹果会做进一步的优化</p><p><img src="/res/LLVM/xcode-optimize.png" alt></p><p><strong><em>三、输出汇编代码</em></strong></p><p>我们可以使用下面的命令让clang输出汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入</span></span><br><span class="line"> clang -S -o - hello.c</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输出</span></span><br><span class="line">.section__TEXT,__text,regular,pure_instructions <span class="comment"># .section 指令指定接下来会执行哪一个段</span></span><br><span class="line">.macosx_version_min 10, 13</span><br><span class="line">.globl_main           <span class="comment"># .globl 指令说明 _main 是一个外部符号</span></span><br><span class="line">.p2align4, 0x90     <span class="comment"># .align 指令指出了后面代码的对齐方式 如果需要的话，用 0x90 补齐</span></span><br><span class="line">_main:                                  <span class="comment">## 接下来是 main 函数的头部：</span></span><br><span class="line">.cfi_startproc          <span class="comment"># .cfi_startproc 指令通常用于函数的开始处</span></span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">pushq%rbp    <span class="comment"># rbp 寄存器 (基础指针寄存器 base pointer register)</span></span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset %rbp, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">subq<span class="variable">$16</span>, %rsp</span><br><span class="line">movl<span class="variable">$0</span>, -4(%rbp)</span><br><span class="line">leaqL_.str(%rip), %rdi</span><br><span class="line">movb<span class="variable">$0</span>, %al</span><br><span class="line">callq_printf <span class="comment">#调用了 printf</span></span><br><span class="line">xorl%ecx, %ecx</span><br><span class="line">movl%eax, -8(%rbp)          <span class="comment">## 4-byte Spill</span></span><br><span class="line">movl%ecx, %eax</span><br><span class="line">addq<span class="variable">$16</span>, %rsp</span><br><span class="line">popq%rbp <span class="comment"># 与pushq对应</span></span><br><span class="line">retq</span><br><span class="line">.cfi_endproc <span class="comment"># 与 .cfi_startproc 相匹配，以此标记出 main() 函数结束</span></span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line">.section__TEXT,__cstring,cstring_literals <span class="comment"># __TEXT __cstring 开启了一个新的段。</span></span><br><span class="line">L_.str:       <span class="comment">#L_.str 标记运行在实际的代码中获取到字符串的一个指针                          ## @.str</span></span><br><span class="line">.asciz<span class="string">"hello world\n"</span> <span class="comment">#.asciz 指令告诉编译器输出一个以 ‘\0’ (null) 结尾的字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.subsections_via_symbolsv <span class="comment"># .subsections_via_symbols 指令是静态链接编辑器使用的。</span></span><br></pre></td></tr></table></figure><p>具体的代码解读，有兴趣的同学可以到<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="noopener">苹果的 OS X Assembler Reference </a> 了解详细。</p><!-- https://objccn.io/issue-6-3/ --><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><p>汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 对象文件。这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如 生成 main.o文件</span></span><br><span class="line">clang -fmodules -c main.c -o main.o</span><br></pre></td></tr></table></figure><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器解决了目标文件和库之间的链接。例如上面汇编代码中 <code>callq   _printf</code>， <code>printf()</code> 是 libc 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 printf() 在内存中的具体位置：例如，_printf 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 libc)，并解决所有未知符号 (此处是 _printf) 的问题。然后将它们编码进最后的可执行文件中 （可以在 libc 中找到符号 _printf），接着链接器会输出可以运行的执行文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成 hello.out 的 Mach-O 二进制文件</span></span><br><span class="line">clang hello.c -o hello.out</span><br></pre></td></tr></table></figure><p>关于<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html" target="_blank" rel="noopener">Mach-O文件格式</a>有兴趣的同学可以通过apple文档来了解。</p><p>这里说 hello.out 是可执行文件，可以通过<code>file</code>来判断:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file hello.out</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">hello.out: Mach-O 64-bit executable x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行hello.out</span></span><br><span class="line">./hello.out</span><br><span class="line"><span class="comment">#输出 </span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="编译多个文件"><a href="#编译多个文件" class="headerlink" title="编译多个文件"></a>编译多个文件</h2><p>之前上面我们的实验都是使用单个hello.c文件。现在我们通过多个文件情况 了解下汇编器和链接器 ,如下三个文件：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File1.h:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File1.m:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"File1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSFullUserName</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//File2.m:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"File1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Foo *foo = [[Foo alloc] init];</span><br><span class="line">        [foo run];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有三个文件，需要我们编译多个文件。我们需要让clang对输入每个文件生成对应的目标文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clang  -c Only run preprocess, compile, and assemble steps</span></span><br><span class="line"></span><br><span class="line">clang -c File1.m <span class="comment">#生成 File1.o</span></span><br><span class="line">clang -c File2.m <span class="comment">#生成 File2.o</span></span><br></pre></td></tr></table></figure><p>这里我们加了<code>-c</code> 并没有编译头文件，现在我们来完成<code>链接器</code>这一步,将两个 .o 文件与Foundation库链接起来：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  -Wl,&lt;arg&gt;               Pass the comma separated arguments in &lt;arg&gt; to the linker</span></span><br><span class="line">clang File1.o File2.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class="line"><span class="comment"># 输出 a.out</span></span><br></pre></td></tr></table></figure><p>现在我们可以运行 <code>a.out</code> 了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out </span><br><span class="line">2019-04-16 20:49:35.070 a.out[71207:10299638] sunTongSheng</span><br></pre></td></tr></table></figure><h3 id="符号表和链接"><a href="#符号表和链接" class="headerlink" title="符号表和链接"></a>符号表和链接</h3><p>File1 和 File2 都使用了 Foundation framework。 File2.o 目标文件使用了它的 autorelease pool，并间接的使用了 libobjc.dylib 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。所有的这些关联的东西都被形象的称之为符号。</p><p>每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器在目标文件和动态库之间对符号做了解析处理。</p><p>可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 nm 工具观察一下 File2.o 目标文件，可以看到如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#nm : llvm symbol table dumper</span></span><br><span class="line">nm -nm File2.o</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br><span class="line">                 (undefined) external _objc_alloc</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush</span><br><span class="line">                 (undefined) external _objc_msgSend</span><br><span class="line">0000000000000000 (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure><p>上面就是那个目标文件的所有符号。_OBJC_CLASS_$_Foo 是 Foo Objective-C 类的符号。该符号是 undefined, external 。External 的意思是指对于这个目标文件该类并不是私有的，相反，non-external 的符号则表示对于目标文件是私有的。我们的 File2.o 目标文件引用了类 Foo，不过这并没有实现它。因此符号表中将其标示为 undefined。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。</p><p>接下来是 _main 符号，它是表示 main() 函数，同样为 external，这是因为该函数需要被调用，所以应该为可见的。由于在 helloworld.o 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到 <strong>TEXT,</strong>text section。</p><p>接下来看下 <code>File1.o</code>,看看有什么输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nm -nm File1.o</span><br><span class="line">                 (undefined) external _NSFullUserName</span><br><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_NSObject</span></span><br><span class="line">                 (undefined) external _OBJC_METACLASS_<span class="variable">$_NSObject</span></span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line">                 (undefined) external __objc_empty_cache</span><br><span class="line">0000000000000000 (__TEXT,__text) non-external -[Foo run]</span><br><span class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_<span class="variable">$_Foo</span></span><br><span class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_<span class="variable">$_INSTANCE_METHODS_Foo</span></span><br><span class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_<span class="variable">$_Foo</span></span><br><span class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_<span class="variable">$_Foo</span></span><br><span class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br></pre></td></tr></table></figure><p>File1.o 同样有 undefined 的符号。首先是使用了符号 <code>NSFullUserName()</code>，<code>NSLog()</code>和 <code>NSObject</code>。接着显示了 <code>_OBJC_CLASS_$_Foo</code> 已经定义了，并且对于 File1.o 是一个外部符号 , <code>File1.o</code> 包含了这个类的实现。</p><p>最后先来同样看下 a.out 的输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nm -nm a.out </span><br><span class="line">                 (undefined) external _NSFullUserName (from Foundation)</span><br><span class="line">                 (undefined) external _NSLog (from Foundation)</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_NSObject</span> (from CoreFoundation)</span><br><span class="line">                 (undefined) external _OBJC_METACLASS_<span class="variable">$_NSObject</span> (from CoreFoundation)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</span><br><span class="line">                 (undefined) external __objc_empty_cache (from libobjc)</span><br><span class="line">                 (undefined) external _objc_alloc (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</span><br><span class="line">                 (undefined) external _objc_msgSend (from libobjc)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000e90 (__TEXT,__text) non-external -[Foo run]</span><br><span class="line">0000000100000ec0 (__TEXT,__text) external _main</span><br><span class="line">0000000100001138 (__DATA,__objc_data) external _OBJC_METACLASS_<span class="variable">$_Foo</span></span><br><span class="line">0000000100001160 (__DATA,__objc_data) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br></pre></td></tr></table></figure><p>通过<code>a.out</code>的符号表，我们可以观察链接器是如何解析所有符号表的。当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析 _OBJC_CLASS_$_Foo。另外，它将使用 Foundation framework。当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，_NSFullUserName，_NSLog，_OBJC_CLASS_$_NSObject，_objc_autoreleasePoolPop 等符号都是遵循这个过程。</p><p>虽然所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。</p><p>可执行文件同样知道去哪里找到所需库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">otool -L a.out </span><br><span class="line">a.out:</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1560.12.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1454.90.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure><h3 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h3><p>在运行时，动态链接器dyld可以解析这些 <code>undefined</code> 符号，dyld将会确定好 <code>_NSFullUserName</code> 等符号，并指向它们在 <code>Foundation</code> 中的实现等。<br>上面提到文件符号表指向了需要的库，添加<code>DYLD_PRINT_LIBRARIES</code>环境变量可以打印出什么库被加载了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">export</span> DYLD_PRINT_LIBRARIES=; ./a.out )</span><br><span class="line">dyld: loaded: /Users/suntongsheng/Desktop/tmp/asdasd/Test/./a.out</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</span><br><span class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>比如可以针对 Foundation 运行 <code>nm</code>，并检查这些符号的定义情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nm -nm /System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName</span><br><span class="line">00000000000bb1be (__TEXT,__text) external _NSFullUserName</span><br></pre></td></tr></table></figure><p>上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun otool -L /System/Library/Frameworks/Foundation.framework/Foundation</span><br></pre></td></tr></table></figure><p>可以看到 Foundation 关联的库。</p><p><strong><em>动态链接器dyld 的共享缓存</em></strong></p><p>当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。</p><p>为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 /var/db/dyld/。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 共享缓存 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。</p><h2 id="最后总结一下就是以下编译过程："><a href="#最后总结一下就是以下编译过程：" class="headerlink" title="最后总结一下就是以下编译过程："></a>最后总结一下就是以下编译过程：</h2><p><img src="/res/LLVM/llvm1.png" alt></p><h2 id="Xcode-编译"><a href="#Xcode-编译" class="headerlink" title="Xcode 编译"></a>Xcode 编译</h2><p>以上说的是Clang如何编译C语言文件的过程，那么在Xcode里会经过哪些过程呢？</p><p>我们可以简单新建一个单页面工程，Build后在Report Navigation视图中查看详细日志：</p><p><img src="/res/LLVM/xcode.png" alt></p><p>详细的步骤如下：</p><ol><li>创建文件夹</li><li>把Entitlements.plist写入到DerivedData里，处理打包的时候需要的信息（比如application-identifier）。</li><li>创建一些辅助文件，比如各种.hmap (headermap是帮助编译器找到头文件的辅助文件：存储这头文件到其物理路径的映射关系)</li><li>编译.m文件，生成.o文件。</li><li>链接动态库，o文件，生成一个mach o格式的可执行文件。</li><li>编译assets，编译storyboard，链接storyboard</li><li>对App签名</li><li>生成 .app</li></ol><p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerlink&quot; title=&quot;编译器&quot;&gt;&lt;/a&gt;编译器&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大多数编译器由两部分组成：前端和后端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前端负责词法分析，语法分析，生成中间代码；&lt;/li&gt;
&lt;li&gt;后端以中间代码作为输入，进行行架构无关的代码优化，接着针对不同架构生成不同的机器码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Objective C/C/C++使用的编译器前端是clang，swift是swift，后端都是LLVM。&lt;/p&gt;
&lt;h3 id=&quot;llvm介绍&quot;&gt;&lt;a href=&quot;#llvm介绍&quot; class=&quot;headerlink&quot; title=&quot;llvm介绍&quot;&gt;&lt;/a&gt;llvm介绍&lt;/h3&gt;&lt;p&gt;LLVM是什么，是low level virtual machine的简称，其实是一个编译器框架。LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。编译器前端主要进行语法分析，语义分析，生成中间代码。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/LLVM/LLVMCompiler1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。而Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。Clang项目包括Clang前端和Clang静态分析器等。&lt;/p&gt;
&lt;p&gt;下图是iOS编译过程：&lt;br&gt;&lt;img src=&quot;/res/LLVM/iOSCompiler.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="重学iOS" scheme="https://developerdoc.com/categories/%E9%87%8D%E5%AD%A6iOS/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="LLVM" scheme="https://developerdoc.com/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLDB教程-命令篇</title>
    <link href="https://developerdoc.com/essay/LLDB/LLDB_tutorial/"/>
    <id>https://developerdoc.com/essay/LLDB/LLDB_tutorial/</id>
    <published>2019-03-14T12:53:17.000Z</published>
    <updated>2019-04-23T02:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>你是否曾经苦恼于理解项目的代码，而去尝试打印一个变量的值？然后使用NSLog 并且每次必须重新编译，从头开始？但是不一定要这么做。你可以使用调试器。而且即使你已经知道如何使用调试器检查变量，它可以做的还有很多。</p><h2 id="LLDB-是什么？"><a href="#LLDB-是什么？" class="headerlink" title="LLDB 是什么？"></a>LLDB 是什么？</h2><p><a href="http://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a>是Mac OS X上Xcode的默认调试器，支持再桌面和iOS设备和模拟器上调试C ，Objective-C和C++。它是新一代高性能调试器，它可以高效利用LLVM项目中的现有库，例如Clang表达式解析器和LLVM反汇编程序。</p><p>随着Xcode 5的发布，LLDB调试器已经取代了GDB，成为了Xcode工程中默认的调试器。它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。LLDB为Xcode提供了底层调试环境，其中包括内嵌在Xcode IDE中的位于调试区域的控制面板。</p><p><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a> 是facebook下一个开源LLDB命令集合。</p><p>与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。</p><a id="more"></a><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><img src="/res/LLDB/1.png" alt></p><p>这是一个简单加了断点的程序，程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。这时候我们应该打些什么命令呢？</p><p><strong><em>帮助 help</em></strong></p><p>最简单命令是 <code>help</code>，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 <code>help &lt;command-name&gt;</code> 来了解更多细节，例如 <code>help print</code> 或者 <code>help thread</code>。只需要在控制台 上图lldb字样的地方键入 help即可。</p><p><img src="/res/LLDB/2.png" alt></p><p><strong><em>打印对象 print</em></strong><br>打印值很简单；只要试试 print 命令:</p><p><img src="/res/LLDB/3.png" alt></p><p>LLDB 实际上会作前缀匹配。所以你也可以使用 prin，pri，或者 p。但你不能使用 pr，因为 LLDB 不能消除和 process 的歧义 (幸运的是 p 并没有歧义)。而print 则是<code>expression --</code>的简写方式。</p><p>你可能还注意到了，结果中有个 $0。实际上你可以使用它来指向这个结果。试试 print $0 + 7，你会看到 130。任何以$符开头的东西都是存在于 LLDB 的命名空间的，它们是为了帮助你进行调试而存在的。</p><p>打印复杂对象时，print可能显得力不从心 ，我们想看的是对象的 description 方法的结果，这时可以使用 <code>po</code> ，po 其实是 <code>e -o --</code>的别名。</p><p>甚至可以给print 指定不同的打印格式。它们都是以 <code>print/&lt;fmt&gt;</code> 或者简化的 <code>p/&lt;fmt&gt;</code> 格式书写。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的格式</span></span><br><span class="line">(lldb) p <span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">//十六进制:</span></span><br><span class="line">(lldb) p/x <span class="number">16</span></span><br><span class="line"><span class="number">0x10</span></span><br><span class="line"><span class="comment">//二进制 (t 代表 two)：</span></span><br><span class="line">(lldb) p/t <span class="number">16</span></span><br><span class="line"><span class="number">0</span>b00000000000000000000000000010000</span><br><span class="line">(lldb) p/t (<span class="keyword">char</span>)<span class="number">16</span></span><br><span class="line"><span class="number">0</span>b00010000</span><br></pre></td></tr></table></figure><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">这里是格式的完整清单</a></p><p><strong><em>修改对象 expression</em></strong></p><p>如果想改变一个值怎么办？我们要用到的是 <code>expression</code> 这个方便的命令。</p><p><img src="/res/LLDB/4.png" alt></p><p>上图中修改了num的值，断点步进后可以看到NSLog的对应值已经发生了变化。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>现在你已经可以打印对象和简单类型，并且知道如何使用 expression 命令在调试器中修改它们了。现在让我们使用一些变量来减少输入量。就像你可以在 C 语言中用 int a = 0 来声明一个变量一样，你也可以在 LLDB 中做同样的事情。不过为了能使用声明的变量，变量必须以$符开头。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) e <span class="keyword">int</span> $a = <span class="number">2</span></span><br><span class="line">(lldb) p $a * <span class="number">19</span></span><br><span class="line"><span class="number">38</span></span><br><span class="line">(lldb) e <span class="built_in">NSArray</span> *$array = @[ <span class="string">@"Saturday"</span>, <span class="string">@"Sunday"</span>, <span class="string">@"Monday"</span> ]</span><br><span class="line">(lldb) p [$array count]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">(lldb) po [[$array objectAtIndex:<span class="number">0</span>] uppercaseString]</span><br><span class="line">SATURDAY</span><br><span class="line">(lldb) p (<span class="keyword">char</span>)[[$array objectAtIndex:$a] characterAtIndex:<span class="number">0</span>]</span><br><span class="line"><span class="string">'M'</span></span><br><span class="line">(lldb) p/d (<span class="keyword">char</span>)[[$array objectAtIndex:$a] characterAtIndex:<span class="number">0</span>]</span><br><span class="line"><span class="number">77</span></span><br></pre></td></tr></table></figure><h3 id="UI调试"><a href="#UI调试" class="headerlink" title="UI调试"></a>UI调试</h3><p>因为全局变量是可访问的,可以像这样打印整个视图层级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</span><br><span class="line">&lt;UIWindow: 0x7fe5ac70c6a0; frame = (0 0; 375 812); gestureRecognizers = &lt;NSArray: 0x6000034cb780&gt;; layer = &lt;UIWindowLayer: 0x600003a84680&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x7fe5ac5069b0; frame = (0 0; 375 812); autoresize = W+H; layer = &lt;CALayer: 0x600003ad3620&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong><em>1、更新UI</em></strong></p><p>就像上文变量中提到那样，我们可以拿到这个view:</p><p><code>(lldb) expression id $myView = (id)0x7fe5ac5069b0</code></p><p>尝试做一些修改：</p><p><code>(lldb) expression (void)[$myView setBackgroundColor:[UIColor redColor]]</code></p><p>但是只有程序继续运行之后才会看到界面的变化。因为改变的内容必须被发送到渲染服务中，然后显示才会被更新。</p><p>渲染服务实际上是一个另外的进程 (被称作 backboardd)。这就是说即使我们正在调试的内容所在的进程被打断了，backboardd 也还是继续运行着的。</p><p>这意味着你可以运行下面的命令，而不用继续运行程序：</p><p><code>(lldb) expression (void)[CATransaction flush]</code></p><p>这个时候就能看到背景颜色的改变了。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>通过xcode加断点调试时，调试条上回出现四个可以控制程序执行流程的按钮：<br><img src="/res/LLDB/5.png" alt></p><p>从左到右分别是 continue program execution 、 step over 、 step into 和 step out。</p><p><strong><em>1、 continue program execution</em></strong> 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。<br>在 LLDB 中，你可以使用 <code>process continue</code> 或者 <code>thread continue</code> 命令来达到同样的效果。</p><p><strong><em>2、 step over</em></strong> 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。<br>LLDB 则可以使用 <code>thread step-over</code>，<code>next</code>，或者 <code>n</code> 命令。</p><p><strong><em>3、 step in</em></strong>按钮，可以跳进一个函数调用来调试或者检查程序的执行情况。<br>在LLDB中使用 <code>thread step-in</code>，<code>step</code>，或者 s 命令。注意，当前行不是函数调用时，next 和 step 效果是一样的。</p><p><strong><em>4、step out</em></strong>按钮 ，如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 n 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。<br>在LLDB中使用 <code>thread step-out</code>，</p><p><strong><em>thread return</em></strong> 使用<code>help thread</code>可以看到这个比较实用的函数。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>Xcode在断点导航中提供了一系列工具创建和管理断点，我们可以来看LLDB中等价的命令,主要是<code>breakpoint</code>命令。</p><p><strong><em>1、查看 启用/禁用</em></strong></p><p><img src="/res/LLDB/6.png" alt></p><p>上图是xcode查看断点的地方，点击断点会开启或关闭断点。对应的LLDB如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看断点 命令输出列表显示每个逻辑断点都有一个整数标识</span></span><br><span class="line"><span class="comment">//输出列表中另一个信息是断点位置是否是已解析的(resolved)。这个标识表示当与之相关的文件地址被加载到程序进行调试时，其位置是已解析的。</span></span><br><span class="line">  <span class="comment">//例如，如果在共享库中设置的断点之后被卸载了，则断点的位置还会保留，但其不能再被解析。</span></span><br><span class="line">(lldb) breakpoint list</span><br><span class="line">Current breakpoints:</span><br><span class="line">1: file = '/Users/suntongsheng/Desktop/tmp/asdasd/asdasd/main.m', line = 23, exact_match = 0, locations = 1, resolved = 1, hit count = 1</span><br><span class="line"></span><br><span class="line">  <span class="number">1.1</span>: where = asdasd`main + <span class="number">51</span> at main.m:<span class="number">23</span>, address = <span class="number">0x00000001070195d3</span>, resolved, hit count = <span class="number">1</span> </span><br><span class="line"><span class="comment">//禁用断点</span></span><br><span class="line">(lldb) breakpoint disable <span class="number">1</span></span><br><span class="line"><span class="number">1</span> breakpoints disabled.</span><br><span class="line"><span class="comment">//启用断点</span></span><br><span class="line">(lldb) breakpoint enable <span class="number">1</span></span><br><span class="line"><span class="number">1</span> breakpoints enabled.</span><br></pre></td></tr></table></figure><p><strong><em>2、 创建/删除</em></strong></p><p>在Xcode创建断点的方式一种是 直接在代码左边的行数出点击 即可创建断点。对应的LLDB如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在main.m的第24行创建断点</span></span><br><span class="line">(lldb) breakpoint set -f main.m -l <span class="number">24</span></span><br><span class="line">Breakpoint <span class="number">3</span>: where = asdasd`main + <span class="number">59</span> at main.m:<span class="number">24</span>, address = <span class="number">0x00000001070195db</span></span><br><span class="line"><span class="comment">//删除刚才的断点</span></span><br><span class="line">(lldb) breakpoint delete <span class="number">3</span></span><br><span class="line"><span class="number">1</span> breakpoints deleted; <span class="number">0</span> breakpoint locations disabled.</span><br></pre></td></tr></table></figure><p>还有一种是在断点导航，点击左下角的加号按钮，选择Symbolic BreakPoint会出现：</p><p><img src="/res/LLDB/7.png" alt></p><p>对应的LLDB如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行</span></span><br><span class="line">(lldb) breakpoint set  -F isEven</span><br><span class="line">Breakpoint <span class="number">6</span>: where = asdasd`isEven + <span class="number">16</span> at main.m:<span class="number">13</span>, address = <span class="number">0x0000000107019750</span></span><br><span class="line"><span class="comment">//Objective-C 的方法也完全可以</span></span><br><span class="line">(lldb) breakpoint set -F <span class="string">"-[NSArray objectAtIndex:]"</span></span><br><span class="line">Breakpoint <span class="number">5</span>: where = CoreFoundation`-[<span class="built_in">NSArray</span> objectAtIndex:], address = <span class="number">0x000000010ac7a950</span></span><br></pre></td></tr></table></figure><p>在 <code>[NSArray objectAtIndex:]</code>这个断点上，我们怎么能知道设置了什么呢？接下来我们可以用$arg1、$arg2等命令来打印出我们想要的信息。<br>在这里$arg1是指对象本身，$arg2是对象被调用的函数，po命令无法直接输出函数名，需要加上(SEL)，$arg3是被赋给函数的参数。</p><p><strong><em>3、 断点行为</em></strong></p><p>在Xcode中邮件断点可以编辑添加action信息，你可以添加多个行为：</p><p><img src="/res/LLDB/8.png" alt></p><p>对应的LLDB如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint set -f main.m -l <span class="number">31</span></span><br><span class="line">Breakpoint <span class="number">2</span>: where = asdasd`main + <span class="number">205</span> at main.m:<span class="number">31</span>, address = <span class="number">0x000000010ab2166d</span></span><br><span class="line"><span class="comment">//添加条件</span></span><br><span class="line">(lldb) breakpoint modify -c 'i == 80' 2</span><br><span class="line"><span class="comment">//添加行为</span></span><br><span class="line">(lldb) breakpoint command add <span class="number">2</span></span><br><span class="line">Enter your debugger command(s).  Type 'DONE' to end.</span><br><span class="line">&gt; po i</span><br><span class="line">&gt; DONE</span><br><span class="line"><span class="comment">//显示刚才的断点</span></span><br><span class="line">(lldb) breakpoint list <span class="number">2</span></span><br><span class="line">2: file = 'main.m', line = 31, exact_match = 0, locations = 1, resolved = 1, hit count = 0</span><br><span class="line">    Breakpoint commands:</span><br><span class="line">      po i</span><br><span class="line"></span><br><span class="line">Condition: i == <span class="number">80</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2.1</span>: where = asdasd`main + <span class="number">205</span> at main.m:<span class="number">31</span>, address = <span class="number">0x000000010ab2166d</span>, resolved, hit count = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 expression 命令来改变变量，然后继续运行。</p><h2 id="查看-线程-调用栈-状态"><a href="#查看-线程-调用栈-状态" class="headerlink" title="查看 线程/调用栈 状态"></a>查看 线程/调用栈 状态</h2><p>在进程停止后，LLDB会选择一个当前线程和线程中当前帧(frame)。很多检测状态的命令可以用于这个线程或帧。</p><p>为了检测进程的当前状态，可以从以下命令<code>thread list</code>开始：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) thread list</span><br><span class="line">Process <span class="number">48541</span> stopped</span><br><span class="line">* thread <span class="meta">#1: tid = 0x3bd1d2, 0x000000010eae0b66 libsystem_kernel.dylib`__pthread_kill + 10, queue = 'com.apple.main-thread', stop reason = signal SIGABRT</span></span><br><span class="line">  thread <span class="meta">#2: tid = 0x3bd24c, 0x000000010eae128a libsystem_kernel.dylib`__workq_kernreturn + 10</span></span><br></pre></td></tr></table></figure><p>星号(*)表示thread #1为当前线程。为了获取线程的跟踪栈，可以使用以下命令<code>thread backtrace</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认为当前线程 也可以指定线程 : thread backtrace 2</span></span><br><span class="line">(lldb) thread backtrace</span><br><span class="line">thread <span class="meta">#1: tid = 0x2c03, stop reason = breakpoint 1.1, queue = com.apple.main-thread</span></span><br><span class="line"> frame <span class="meta">#0: 0x0000000100010d5b, where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果想查看所有线程的调用栈，则可以使用以下命令：<code>(lldb) thread backtrace all</code></p><p>检查帧参数和本地变量的最简便的方式是使用<code>frame variable</code>命令：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span>) argc = <span class="number">1</span></span><br><span class="line">(<span class="keyword">char</span> **) argv = <span class="number">0x00007ffee4150ff0</span></span><br><span class="line">(<span class="built_in">NSUInteger</span>) num = <span class="number">123</span></span><br><span class="line">(__NSCFConstantString *) str = <span class="number">0x000000010bab00d8</span> <span class="string">@"learning LLDB"</span></span><br><span class="line">(__NSArrayI *) arr = <span class="number">0x0000600002982fa0</span> <span class="string">@"2 elements"</span></span><br><span class="line">(<span class="keyword">int</span>) i = <span class="number">80</span></span><br><span class="line">(<span class="built_in">BOOL</span>) result0 = <span class="literal">YES</span></span><br><span class="line">(<span class="built_in">BOOL</span>) result1 = <span class="literal">NO</span></span><br></pre></td></tr></table></figure><p>如果没有指定任何变量名，则会显示所有参数和本地变量。如果指定参数名或变量名，则只打印指定的值。如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame variable <span class="keyword">self</span></span><br><span class="line">(<span class="built_in">SKTGraphicView</span> *) <span class="keyword">self</span> = <span class="number">0x0000000100208b40</span></span><br></pre></td></tr></table></figure><p>如果想查看另外一帧，可以使用<code>frame select</code>命令，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) frame select <span class="number">2</span></span><br><span class="line">frame <span class="meta">#2: 0x000000010e88dc45 libsystem_c.dylib`abort + 127</span></span><br></pre></td></tr></table></figure><h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>image指令是target module指令的缩写，借助它我们能够查看当前的Binary Images相关的信息。日常开发我们主要利用它寻址。<code>image</code>命令的用法也挺多，首先可以用它来查看工程中使用的库，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list</span><br><span class="line">[  <span class="number">0</span>] <span class="number">9E11</span>F0C7<span class="number">-9</span>AB1<span class="number">-36</span>A8<span class="number">-8</span>FE4<span class="number">-8821</span>DBA05A2F <span class="number">0x000000010baad000</span> /Users/suntongsheng/Library/Developer/Xcode/DerivedData/asdasd-dufvhftdhjomdkcnrilgxlwykarv/Build/Products/Debug-iphonesimulator/asdasd.app/asdasd </span><br><span class="line">[  <span class="number">1</span>] <span class="number">8</span>A72DE9C-A136<span class="number">-3506</span>-AA02<span class="number">-4</span>BA2B82DCAF3 <span class="number">0x0000000115aa8000</span> /usr/lib/dyld</span><br></pre></td></tr></table></figure><p>我们还可以用它来查找可执行文件或共享库的原始地址，这一点还是很有用的，当我们的程序崩溃时，我们可以使用这条命令来查找崩溃所在的具体位置，如下所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array 3: %@"</span>, array[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//这段代码会抛出</span></span><br><span class="line">2019-03-19 16:10:32.841204+0800 asdasd[49351:4010863] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1]'</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line"><span class="number">0</span>   CoreFoundation                      <span class="number">0x0000000102c7f1bb</span> __exceptionPreprocess + <span class="number">331</span></span><br><span class="line"><span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x000000010221d735</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line"><span class="number">2</span>   CoreFoundation                      <span class="number">0x0000000102bcb4ec</span> _CFThrowFormattedException + <span class="number">194</span></span><br><span class="line"><span class="number">3</span>   CoreFoundation                      <span class="number">0x0000000102d01b00</span> +[__NSArrayI allocWithZone:] + <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   asdasd                              <span class="number">0x00000001019004ff</span> -[ViewController viewDidLoad] + <span class="number">287</span></span><br></pre></td></tr></table></figure><p>根据以上信息，我们可以判断崩溃位置是在ViewController中，要想知道具体在哪一行，可以使用以下命令<code>image lookup --address</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image lookup --address <span class="number">0x00000001019004ff</span></span><br><span class="line">      Address: asdasd[<span class="number">0x00000001000014ff</span>] (asdasd.__TEXT.__text + <span class="number">287</span>)</span><br><span class="line">      Summary: asdasd`-[ViewController viewDidLoad] + <span class="number">287</span> at ViewController.m:<span class="number">23</span></span><br></pre></td></tr></table></figure><p>可以看到，最后定位到了ViewController.m:23行，正是我们代码所在的位置。</p><p>image更多用法可以参考： <a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="noopener">Executable and Shared Library Query Commands。</a></p><!-- http://southpeak.github.io/2015/01/25/tool-lldb/ --><!-- https://juejin.im/post/5b1cd870e51d4506dc0ac76c --><!-- https://www.jianshu.com/p/67f08a4d8cf2 -->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否曾经苦恼于理解项目的代码，而去尝试打印一个变量的值？然后使用NSLog 并且每次必须重新编译，从头开始？但是不一定要这么做。你可以使用调试器。而且即使你已经知道如何使用调试器检查变量，它可以做的还有很多。&lt;/p&gt;
&lt;h2 id=&quot;LLDB-是什么？&quot;&gt;&lt;a href=&quot;#LLDB-是什么？&quot; class=&quot;headerlink&quot; title=&quot;LLDB 是什么？&quot;&gt;&lt;/a&gt;LLDB 是什么？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://lldb.llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLDB&lt;/a&gt;是Mac OS X上Xcode的默认调试器，支持再桌面和iOS设备和模拟器上调试C ，Objective-C和C++。它是新一代高性能调试器，它可以高效利用LLVM项目中的现有库，例如Clang表达式解析器和LLVM反汇编程序。&lt;/p&gt;
&lt;p&gt;随着Xcode 5的发布，LLDB调试器已经取代了GDB，成为了Xcode工程中默认的调试器。它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。LLDB为Xcode提供了底层调试环境，其中包括内嵌在Xcode IDE中的位于调试区域的控制面板。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/chisel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chisel&lt;/a&gt; 是facebook下一个开源LLDB命令集合。&lt;/p&gt;
&lt;p&gt;与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。&lt;/p&gt;
    
    </summary>
    
      <category term="重学iOS" scheme="https://developerdoc.com/categories/%E9%87%8D%E5%AD%A6iOS/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
      <category term="LLDB" scheme="https://developerdoc.com/tags/LLDB/"/>
    
  </entry>
  
  <entry>
    <title>iOS直播教程</title>
    <link href="https://developerdoc.com/quick-start/iOS%E7%9B%B4%E6%92%AD%E6%95%99%E7%A8%8B/"/>
    <id>https://developerdoc.com/quick-start/iOS直播教程/</id>
    <published>2019-03-07T07:09:58.000Z</published>
    <updated>2019-03-07T08:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直播原理"><a href="#直播原理" class="headerlink" title="直播原理"></a>直播原理</h2><p>一个简单的直播流程是: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app        -&gt; 视频采集   -&gt;  编码    -&gt; 推流     -&gt; 服务器</span><br><span class="line">服务器      -&gt; 拉流      -&gt;  解码    -&gt; 播放     -&gt; app</span><br></pre></td></tr></table></figure><p>其中涉及到的技术点比较多:</p><p><img src="/res/live/直播技术点.png" alt></p><a id="more"></a><h3 id="流媒体传输协议"><a href="#流媒体传输协议" class="headerlink" title="流媒体传输协议"></a>流媒体传输协议</h3><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4><ul><li>RTMP:实时消息传输协议,Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议，因为是开放协议所以都可以使用了。<ul><li>RTMP协议用于对象、视频、音频的传输。<ul><li>这个协议建立在TCP协议或者轮询HTTP协议之上。</li><li>RTMP协议就像一个用来装数据包的容器，这些数据可以是FLV中的视音频数据。一个单一的连接可以通过不同的通道传输多路网络流，这些通道中的包都是按照固定大小的包传输的</li></ul></li></ul></li></ul><h4 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS (HTTP Live Streaming)"></a>HLS (HTTP Live Streaming)</h4><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备（如iPhone、iPad）提供音视频直播和点播方案。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。</p><p>相对于常见的流媒体直播协议，例如RTMP协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p><p>m3u8，是HTTP Live Streaming直播的索引文件。</p><ul><li><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008332-CH1-SW1" target="_blank" rel="noopener">Apple: HTTP Live Streaming Overview </a></li><li><a href="https://developer.apple.com/streaming/" target="_blank" rel="noopener">Apple: HTTP Live Streaming(HLS) Overview</a></li></ul><h2 id="直播iOS实战"><a href="#直播iOS实战" class="headerlink" title="直播iOS实战"></a>直播iOS实战</h2><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><blockquote><p>使用HomeBrew 安装 nginx<br>没安装过HomwBrew的 看一下 <a href="https://brew.sh/" target="_blank" rel="noopener">HomeBrew主页</a> 安装一下</p></blockquote><p><strong>一：</strong> <em>增加home-brew对nginx的扩展</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/nginx</span><br></pre></td></tr></table></figure><p><strong>二：</strong> <em>安装Nginx服务器和rtmp模块</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx-full --with-rtmp-module</span><br></pre></td></tr></table></figure><p><strong>三：</strong> <em>查看是否安装成功</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew info nginx-full</span><br></pre></td></tr></table></figure><p><img src="/res/live/brewInfoNginx.png" alt>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf （配置文件路径）</span><br><span class="line">/usr/local/var/www （服务器默认路径）</span><br><span class="line">/usr/local/Cellar/ （安装路径）</span><br><span class="line">open -t /usr/local/etc/nginx/nginx.conf 可以用文本编辑器打开配置文件</span><br><span class="line">nginx -s reload 重新加载配置</span><br><span class="line">nginx -s reopen 重新打开log</span><br><span class="line">nginx -s stop 停止nginx</span><br><span class="line">nginx -s quit 退出nginx</span><br></pre></td></tr></table></figure><p><strong>四：</strong> <em>启动nginx</em></p><p>输入 开启服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>在浏览器中 输入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>如果出现下图, 则表示安装成功:</p><p><img src="/res/live/welcomeNginx.png" alt></p><h4 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h4><p><strong>一：</strong> <em>配置Nginx，支持http协议拉流</em></p><p>在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -t  /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>打开nginx配置文件,在http属性下找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面添加，成为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /hls &#123; </span><br><span class="line">#支持http协议拉流</span><br><span class="line">types &#123; </span><br><span class="line">application/vnd.apple.mpegurl m3u8; </span><br><span class="line">video/mp2t ts; </span><br><span class="line">&#125; </span><br><span class="line">root /usr/local/var/www; </span><br><span class="line">add_header Cache-Control no-cache; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二：</strong> <em>配置Nginx，支持rtmp协议推流</em></p><p>在终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -t  /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></p><p>打开nginx配置文件, 文件的末尾(最后一个 “}” 下一行 )添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1990;</span><br><span class="line">        </span><br><span class="line">        application hls&#123;</span><br><span class="line"></span><br><span class="line">          live on;</span><br><span class="line">          record off;</span><br><span class="line">          hls on;</span><br><span class="line">          hls_path /usr/local/var/www/hls;</span><br><span class="line">          hls_fragment 1s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>三：</strong> 应用配置</p><p>重启下nginx就行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="使用-ffmepg-测试推流"><a href="#使用-ffmepg-测试推流" class="headerlink" title="使用 ffmepg 测试推流"></a>使用 ffmepg 测试推流</h4><h3 id="在iOS端使用-LFLiveKit-推流"><a href="#在iOS端使用-LFLiveKit-推流" class="headerlink" title="在iOS端使用 LFLiveKit 推流"></a>在iOS端使用 LFLiveKit 推流</h3><blockquote><p>LFLiveKit它已经帮我们实现了视频采集、后台录制、美颜功能、支持h264、AAC编码，动态改变速率，RTMP传输等<br><a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit主页</a></p></blockquote><h4 id="使用LFLiveKit-demo-推流"><a href="#使用LFLiveKit-demo-推流" class="headerlink" title="使用LFLiveKit demo 推流"></a>使用LFLiveKit demo 推流</h4><p>下载源代码后，进入sample/LFLiveKitDemo 目录，运行下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>打开LFLiveKitDemo.xcworkspace 工程</p><p>将<strong>LFLivePreview.m</strong>文件的362行改为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.url = <span class="string">@"rtmp://10.45.33.96:1990/hls/abc"</span>;</span><br></pre></td></tr></table></figure><p>url对应的是 rtmp://[nginx服务器地址] : [端口] / [配置的应用] / 随便写</p><p>然后真机运行效果如下:</p><p><img src="/res/live/LFLiveKitPreview.png" width="50%"></p><h4 id="测试LFLiveKit-demo-推流"><a href="#测试LFLiveKit-demo-推流" class="headerlink" title="测试LFLiveKit demo 推流"></a>测试LFLiveKit demo 推流</h4><blockquote><p>保证nginx服务器是开启状态<br>点击上面demo中的开始直播后：</p></blockquote><p>在mac <strong>Safari</strong> 浏览器中输入 <a href="http://localhost:8080/hls/abc.m3u8" target="_blank" rel="noopener">http://localhost:8080/hls/abc.m3u8</a> 查看效果：</p><p><img src="/res/live/LFLiveKitTest.png" width="80%"></p><p>相对应的，直接使用iOS自带的AVPlayer就可以播放该链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;直播原理&quot;&gt;&lt;a href=&quot;#直播原理&quot; class=&quot;headerlink&quot; title=&quot;直播原理&quot;&gt;&lt;/a&gt;直播原理&lt;/h2&gt;&lt;p&gt;一个简单的直播流程是: &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app        -&amp;gt; 视频采集   -&amp;gt;  编码    -&amp;gt; 推流     -&amp;gt; 服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;服务器      -&amp;gt; 拉流      -&amp;gt;  解码    -&amp;gt; 播放     -&amp;gt; app&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中涉及到的技术点比较多:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/live/直播技术点.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="quick-start" scheme="https://developerdoc.com/categories/quick-start/"/>
    
    
      <category term="iOS" scheme="https://developerdoc.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub精选分享第四期</title>
    <link href="https://developerdoc.com/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E5%9B%9B%E6%9C%9F/"/>
    <id>https://developerdoc.com/weekly-share/GitHub精选分享第四期/</id>
    <published>2019-03-07T02:14:42.000Z</published>
    <updated>2019-03-07T04:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录这周看到值得分享的事，本期就分享点图片压缩工具类吧~</p><p><img src="/res/weeklyshare/image-tool-stack.png" alt="image-tool-stack"></p><p>上图是我的图片处理工具栈，矢量原型 Sketch，位图编辑 Pixelmator，搜集管理 Inboard，压缩优化 JPEGmini、ImageAlpha、ImageOptim。前四个是付费 App，后两个自由开源。</p><p>本次主要分享<strong>ImageOptim</strong> <strong>ImageAlpha</strong> <strong>ImageOptim-CLI</strong> 和 <strong>Squoosh</strong><br><a id="more"></a></p><h3 id="ImageOptim-JPG图片压缩利器"><a href="#ImageOptim-JPG图片压缩利器" class="headerlink" title="ImageOptim JPG图片压缩利器"></a><a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">ImageOptim JPG图片压缩利器</a></h3><blockquote class="blockquote-center"><p><a href="https://imageoptim.com/mac" target="_blank" rel="noopener">ImageOptim下载链接</a><br>如果你是Mac OS X电脑的使用者，也可试试看另外这一套图片减肥、最佳化工具ImageOptim，它可以支持PNG，JPEG跟GIF等格式的图档，通过内置的PNGOUT、AdvPNG、Pngcrush、OptiPNG、JpegOptim、jpegrescan、jpegtran与Gifsicle等图片最佳化工具，帮我们全自动压缩、缩减图片的大小。</p><p>ImageOptim的使用方法也很简单，就是把图片拉到ImageOptim窗口中，它会自动执行最佳化，然后就没了。</p></blockquote><h3 id="ImageAlpha-PNG图片有损压缩"><a href="#ImageAlpha-PNG图片有损压缩" class="headerlink" title="ImageAlpha PNG图片有损压缩"></a><a href="https://pngmini.com/" target="_blank" rel="noopener">ImageAlpha PNG图片有损压缩</a></h3><blockquote class="blockquote-center"><p><a href="https://pngmini.com/" target="_blank" rel="noopener">ImageAlpha 下载链接</a><br>通过应用有损压缩和转换为更高效的PNG8 + alpha格式，mageAlpha大大减少了24位PNG文件的文件大小（包括alpha透明度）。这些图像与iOS，所有浏览器兼容，甚至在IE6中降级。</p><p>通过使用最新的pngquant和pngnq-s9以及Alpha通道感知后处理器，ImageAlpha可以在MacromediaAdobe Fireworks中获得比类似功能更好的质量。</p></blockquote><h3 id="ImageOptim-CLI-图片压缩工具调用"><a href="#ImageOptim-CLI-图片压缩工具调用" class="headerlink" title="ImageOptim-CLI 图片压缩工具调用"></a><a href="https://github.com/JamieMason/ImageOptim-CLI" target="_blank" rel="noopener">ImageOptim-CLI 图片压缩工具调用</a></h3><p>今天处理的图片较多，想能不能有个自动工作流来解放双手。一搜，恰巧找到了 <a href="https://github.com/JamieMason/ImageOptim-CLI" target="_blank" rel="noopener">JamieMason/ImageOptim-CLI</a> 这个 macOS 项目。一句话描述就是，它会根据你的指定，选择性调用 JPEGmini、ImageAlpha、ImageOptim 等工具，来处理图片压缩问题。开始敲一行命令，中间过程全自动。</p><p>79% TypeScript + 21% AppleScript，分发为可执行的二进制包，所以不依赖 Node.js，并且支持 Homebrew 安装。</p><p>使用也非常方便，终端输入 imageoptim –help 即可得到说明，只需注意三个事项：第一、终端要取得 Accessibility 权限；第二、调用的 App 要自己另外下载安装；第三、顾名思义，它默认调用 ImageOptim，如果不用，可通过 –no-imageoptim 参数 disable 它。</p><p>支持的调用的 3 个 App 如下，JPEGmini Lite 免费，标准和 Pro 均需付费：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Supported Apps:</span><br><span class="line"></span><br><span class="line">  ImageAlpha: https://pngmini.com</span><br><span class="line">  ImageOptim: https://imageoptim.com</span><br><span class="line">  JPEGmini Lite: https://itunes.apple.com/us/app/jpegmini-lite/id525742250</span><br><span class="line">  JPEGmini Pro: https://itunes.apple.com/us/app/jpegmini-pro/id887163276</span><br><span class="line">  JPEGmini: https://itunes.apple.com/us/app/jpegmini/id498944723</span><br></pre></td></tr></table></figure><p>如需组合其他工具，添加对应参数即可，比如添加 –jpegmini 参数调用 JPEGmini：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">  # Run ImageOptim.app over every image in current directory</span><br><span class="line">  imageoptim</span><br><span class="line"></span><br><span class="line">  # Run ImageAlpha.app and ImageOptim.app over every PNG in current directory</span><br><span class="line">  imageoptim --imagealpha &apos;**/*.png&apos;</span><br><span class="line"></span><br><span class="line">  # Run JPEGmini.app and ImageOptim.app over every JPG in current directory</span><br><span class="line">  imageoptim --jpegmini &apos;**/*.jpg&apos; &apos;**/*.jpeg&apos;</span><br><span class="line"></span><br><span class="line">  # Run JPEGmini.app over every JPG in current directory</span><br><span class="line">  imageoptim --jpegmini --no-imageoptim &apos;**/*.jpg&apos; &apos;**/*.jpeg&apos;</span><br><span class="line"></span><br><span class="line">  # Run ImageOptim.app over every image in a specific directory</span><br><span class="line">  imageoptim &apos;~/Desktop&apos;</span><br></pre></td></tr></table></figure><p>那么，这几个工具是单干还是组合好呢，哪个搭配压缩和质量最合理呢？针对这个问题，ImageOptim-CLI 贴心地给出了 GIF、JPEG、PNG 各个格式各个工具及组合的<a href="https://jamiemason.github.io/ImageOptim-CLI/comparison/all/photoshop/desc/" target="_blank" rel="noopener">压缩效果对比</a></p><p><img src="/res/weeklyshare/imageoptim-cli-comparison.png" alt="imageoptim-cli-comparison"></p><p>先看 JPEG 项目，果不其然，JPEGmini &amp; ImageOptim 组合几无敌手，只在蓝天白云和 bril 人像上输给了 Kraken，当然，这个成绩主要是 JPEGmini 的功劳。</p><p>再看 PNG 项目，悬念只在 ImageOptim 单干以及与 ImageOptim 搭配两个方案之间。考虑到 24 位色的天际线、雀斑脸、蓝天白云等图片上，ImageOptim 单干弱势明显，还是建议二者无脑搭配。ImageAlpha则又是明显。</p><p>综合以上两个项目来看，如果能接受较高的图片质量损耗（注意表格中无底色的红字），Kraken 也是非常有竞争力的单一优化工具。</p><h3 id="Squoosh-是-Google-推出的一款在线简单高效的图片压缩工具"><a href="#Squoosh-是-Google-推出的一款在线简单高效的图片压缩工具" class="headerlink" title="Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具"></a><a href="https://github.com/GoogleChromeLabs/squoosh" target="_blank" rel="noopener">Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具</a></h3><blockquote class="blockquote-center"><p><a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh在线链接</a><br>Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具，支持 JPG、PNG 和 WebP 格式，可让您深入了解各种图像压缩器提供的高级选项</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录这周看到值得分享的事，本期就分享点图片压缩工具类吧~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/res/weeklyshare/image-tool-stack.png&quot; alt=&quot;image-tool-stack&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是我的图片处理工具栈，矢量原型 Sketch，位图编辑 Pixelmator，搜集管理 Inboard，压缩优化 JPEGmini、ImageAlpha、ImageOptim。前四个是付费 App，后两个自由开源。&lt;/p&gt;
&lt;p&gt;本次主要分享&lt;strong&gt;ImageOptim&lt;/strong&gt; &lt;strong&gt;ImageAlpha&lt;/strong&gt; &lt;strong&gt;ImageOptim-CLI&lt;/strong&gt; 和 &lt;strong&gt;Squoosh&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="每周分享" scheme="https://developerdoc.com/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
</feed>
