<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"developerdoc.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="原文地址: how-does-react-tell-a-class-from-a-function本文地址： React是如何区分Class和Function？边看边翻译 花了2h+… 如果你觉得读起来还算通顺不费事 那也算我为大家做了一点小贡献吧">
<meta property="og:type" content="article">
<meta property="og:title" content="(译)React是如何区分Class和Function？">
<meta property="og:url" content="https://developerdoc.com/essay/(%E8%AF%91)how-does-react-tell-a-class-from-a-function/index.html">
<meta property="og:site_name" content="孙同生的博客">
<meta property="og:description" content="原文地址: how-does-react-tell-a-class-from-a-function本文地址： React是如何区分Class和Function？边看边翻译 花了2h+… 如果你觉得读起来还算通顺不费事 那也算我为大家做了一点小贡献吧">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-12-04T14:33:48.000Z">
<meta property="article:modified_time" content="2019-03-06T03:19:45.000Z">
<meta property="article:author" content="SunTongSheng">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://developerdoc.com/essay/(%E8%AF%91)how-does-react-tell-a-class-from-a-function/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://developerdoc.com/essay/(%E8%AF%91)how-does-react-tell-a-class-from-a-function/","path":"essay/(译)how-does-react-tell-a-class-from-a-function/","title":"(译)React是如何区分Class和Function？"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>(译)React是如何区分Class和Function？ | 孙同生的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="孙同生的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">孙同生的博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">为美好的世界献上祝福</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E8%B0%83%E7%94%A8%E4%B8%A4%E8%80%85%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="nav-number">1.</span> <span class="nav-text">React调用两者的不同之处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么要用不同的调用方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A2%E7%A9%B6React%E5%BC%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">探究React式如何解决的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A"><span class="nav-number">3.1.</span> <span class="nav-text">异常情况一：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">异常情况二：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A"><span class="nav-number">3.3.</span> <span class="nav-text">异常情况三：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">解决方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype-%E4%B8%8E-proto"><span class="nav-number">3.4.1.</span> <span class="nav-text">prototype 与 __proto__</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#extends-%E4%B8%8E-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">3.4.2.</span> <span class="nav-text">extends 与 原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof-%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.3.</span> <span class="nav-text">instanceof 判断方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#React-%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="nav-number">3.4.4.</span> <span class="nav-text">React 判断方式</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SunTongSheng</p>
  <div class="site-description" itemprop="description">移动端 前端 跨平台</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">80</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://developerdoc.com/essay/(%E8%AF%91)how-does-react-tell-a-class-from-a-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SunTongSheng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孙同生的博客">
      <meta itemprop="description" content="移动端 前端 跨平台">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="(译)React是如何区分Class和Function？ | 孙同生的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          (译)React是如何区分Class和Function？
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-12-04 22:33:48" itemprop="dateCreated datePublished" datetime="2018-12-04T22:33:48+08:00">2018-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-03-06 11:19:45" itemprop="dateModified" datetime="2019-03-06T11:19:45+08:00">2019-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/essay/" itemprop="url" rel="index"><span itemprop="name">essay</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/essay/%E8%AF%91%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">译文</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>原文地址: <a href="https://overreacted.io/how-does-react-tell-a-class-from-a-function/">how-does-react-tell-a-class-from-a-function</a><br>本文地址： <a href="https://developerdoc.com/essay/(译)how-does-react-tell-a-class-from-a-function/">React是如何区分Class和Function？</a><br>边看边翻译 花了2h+… 如果你觉得读起来还算通顺不费事 那也算我为大家做了一点小贡献吧</p>
</blockquote>
<span id="more"></span>
<h2 id="React调用两者的不同之处"><a href="#React调用两者的不同之处" class="headerlink" title="React调用两者的不同之处"></a>React调用两者的不同之处</h2><p>一起来看下这个 function 类型的 <code>Greeting</code>组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 同样支持将它定义为 class 类型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(直到<a href="https://reactjs.org/docs/hooks-intro.html">最近 hooks-intro</a>，这是使用state等特性的唯一方法。)</p>
<p>当你想渲染<code>&lt;Greeting /&gt;</code>组件时，你不必关心它是如何定义的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类或者函数，都可以</span></span><br><span class="line">&lt;<span class="title class_">Greeting</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>但是，作为 <em>React本身</em> 是会认为这两个是有不同之处的。</p>
<p>如果<code>Greeting</code>是一个函数，React 只需要直接调用它:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React内</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Greeting</span>(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是如果<code>Greeting</code>是一个类，那么 React 就需要使用<code>new</code>来实例化它，然后在实例上调用<code>render</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React内</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.<span class="title function_">render</span>(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这两种情况下，<code>React</code>的目标是获取渲染节点（本例中，是<code>&lt;p&gt; Hello &lt;/ p&gt;</code>），但确切的步骤取决于<code>Greeting</code>的类型。</p>
<p><strong>那么React如何知道某个东西是class类型还是function类型呢？</strong></p>
<p>事实上，这篇文章更多的是关于JavaScript而不是关于React。<br>如何你好奇React为何以某种方式运作，让我们一起挖掘其中的原理。</p>
<p><strong>这是一段漫长的探求之旅。这篇文章没有太多关于React本身的信息，我们将讨论<code>new</code>，<code>this</code>，<code>class</code>，<code>arrow function</code>，<code>prototype</code>，<code>__ proto__</code>，<code>instanceof</code>这些概念，以及这些东西如何在JavaScript中运作的机制。幸运的是，当你仅仅是使用React时，你不需要考虑这么多。但你如果要深究React……</strong></p>
<p>(如果你真的只想知道答案，请拉动到文章最后。)</p>
<h2 id="为什么要用不同的调用方式？"><a href="#为什么要用不同的调用方式？" class="headerlink" title="为什么要用不同的调用方式？"></a>为什么要用不同的调用方式？</h2><p>首先，我们需要理解以不同方式处理class和function的重要性。注意我们在调用类时如何使用new运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If Greeting is a function</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Greeting</span>(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If Greeting is a class</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Greeting</span>(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.<span class="title function_">render</span>(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>让我们大致的了解下<code>new</code>在Javascript中做了什么：</p>
<hr>
<p>在ES6之前，Javascript没有class这个概念。但是，可以使用纯函数表现出和class相似的模式。 <strong>具体来说，你可以使用new来调用类似类构造方法的函数，来表现出和class相似的模式</strong> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是一个function</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>); <span class="comment">// ✅ Person &#123;name: &#x27;Fred&#x27;&#125;</span></span><br><span class="line"><span class="keyword">var</span> george = <span class="title class_">Person</span>(<span class="string">&#x27;George&#x27;</span>); <span class="comment">// 🔴 不会如期工作</span></span><br><span class="line"><span class="comment">//你今天仍然可以写这样的代码！在 `DevTools` 中尝试一下。</span></span><br></pre></td></tr></table></figure>

<p>如果不用<code>new</code>修饰<code>Person(&#39;Fred&#39;) </code>,Person内部的<code>this</code>在里面会指向 <code>window</code> 或者 <code>undefined</code> 。结果就是代码会崩溃或者像给<code>window.name</code>赋值一样愚蠢。</p>
<p>在调用之前添加<code>new</code>，等于说：“嘿 JavaScript，我知道<code>Person</code>只是一个函数，但让我们假装它是个类构造函数。 <strong>创建一个{}对象 并在<code>Person</code>函数内将<code>this</code>指向该对象， 这样我就可以赋值像<code>this.name</code>这样的东西。然后把那个对象返回给我。”</strong></p>
<p>上面这些就是<code>new</code>操作符做的事情。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>); <span class="comment">// `Person`内，相同的对象作为`this`</span></span><br></pre></td></tr></table></figure>
<p>同时<code>new</code>操作符使上面的<code>fred</code>对象可以使用<code>Person.prototype</code>上的任何内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Hi, I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>);</span><br><span class="line">fred.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>
<p>这是之前人们在JavaScript模拟类的方式。</p>
<p>可以看到的是在JavaScript早已有<code>new</code>。但是，<code>class</code>却是后来加入的特性。为了更明确我们的意图，重写一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;Hi, I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>);</span><br><span class="line">fred.<span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>
<p><em>在语言和API设计中把握开发人员的意图非常重要。</em></p>
<p>如果你编写一个函数，JavaScript就无法猜测你的意思是像<code>alert()</code>一样被直接调用，还是像<code>new Person()</code>那样充当构造函数。忘记添加<code>new</code>会导致令人困惑的执行结果。</p>
<p><strong>class语法让我们明确的告诉Javascript：“这不仅仅是一个函数 - 它是一个类，它有一个构造函数”。</strong> 如果在调用class时忘记使用<code>new</code>，JavaScript抛出异常：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>);</span><br><span class="line"><span class="comment">// ✅  If Person is a function: works fine</span></span><br><span class="line"><span class="comment">// ✅  If Person is a class: works fine too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> george = <span class="title class_">Person</span>(<span class="string">&#x27;George&#x27;</span>); <span class="comment">// We forgot `new`</span></span><br><span class="line"><span class="comment">// 😳 If Person is a constructor-like function: confusing behavior</span></span><br><span class="line"><span class="comment">// 🔴 If Person is a class: fails immediately</span></span><br></pre></td></tr></table></figure>
<p>这有助于我们尽早发现错误，而不是出现一些不符合预期的结果 比如<code>this.name</code>被视为<code>window.name</code>而不是<code>george.name</code>。</p>
<p>但是，这意味着<code>React</code>需要在调用任何class之前使用<code>new</code>。它不能只是将其作为普通函数直接调用，因为JavaScript会将其视为错误！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 React can&#x27;t just do this:</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="title class_">Counter</span>(props);</span><br></pre></td></tr></table></figure>
<p>这意味着麻烦(麻烦就是在于React需要区分Class和Function……)。</p>
<h2 id="探究React式如何解决的"><a href="#探究React式如何解决的" class="headerlink" title="探究React式如何解决的"></a>探究React式如何解决的</h2><blockquote>
<p>babel之类编译工具给解决问题带来的麻烦</p>
</blockquote>
<p>在我们探究React式如何解决这个问题时，需要考虑到大多数人都使用Babel之类的编译器来兼容浏览器（例如转义class等），所以我们需要在设计中考虑编译器这种情况。</p>
<p>在Babel的早期版本中，可以在没有<code>new</code>的情况下调用类。但是通过生成一些额外的代码，这个情况已经被修复了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// A bit simplified from Babel output:</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Our code:</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>); <span class="comment">// ✅ Okay</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&#x27;George&#x27;</span>);   <span class="comment">// 🔴 Can’t call class as a function</span></span><br></pre></td></tr></table></figure>
<p>你或许在打包文件中看到类似的代码，这就是<code>_classCallCheck</code>函数所做的功能。 （您可以通过设置“loose mode”不进行检查来减小捆绑包大小，但这可能会使代码最终转换为真正的原生类变得复杂。）</p>
<p>到现在为止，你应该大致了解使用<code>new</code>与不使用<code>new</code>来调用某些内容之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>new Person()</code></th>
<th><code>Person()</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>class</code></td>
<td>✅ <code>this</code> is a <code>Person</code> instance</td>
<td>🔴 <code>TypeError</code></td>
</tr>
<tr>
<td><code>function</code></td>
<td>✅ <code>this</code> is a <code>Person</code> instance</td>
<td>😳 <code>this</code> is <code>window</code> or <code>undefined</code></td>
</tr>
</tbody></table>
<p>这之中的区别就是React为什么需要正确调用组件的重要原因。 <strong>如果您的组件被定义为类，React在调用它时需要使用<code>new</code>。</strong></p>
<p><strong>那么问题来了 React是否可以判断某个东西是不是一个class？</strong></p>
<p>没有那么容易！即使我们可以<a href="https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function">在JavaScript es6 中区别class 和 function</a>，这仍然不适用于像Babel这样的工具处理之后的class。因为对于浏览器来说，它们只是单纯的function而已（class被babel处理后）。 </p>
<hr>
<p>Okay，也许React可以在每次调用时使用<code>new</code>？不幸的是，这也并不总是奏效。</p>
<h3 id="异常情况一："><a href="#异常情况一：" class="headerlink" title="异常情况一："></a>异常情况一：</h3><p>作为一般function，使用<code>new</code>调用它们会为它们提供一个对象实例作为<code>this</code>。对于作为构造函数编写的函数（如上面的<code>Person</code>），它是理想的，但它会给函数组件带来混乱：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 我们不希望“this”在这里成为任何一种情况下的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这种情况也是可以容忍的，但还有另外两个原因可以扼杀一直使用<code>new</code>的想法。</p>
<h3 id="异常情况二："><a href="#异常情况二：" class="headerlink" title="异常情况二："></a>异常情况二：</h3><p>第一个是箭头函数（未被babel编译时）会使<code>new</code>调用失效，使用<code>new</code>调用箭头函数会抛出一个异常</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Greeting</span> = (<span class="params"></span>) =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Greeting</span>(); <span class="comment">// 🔴 Greeting is not a constructor</span></span><br></pre></td></tr></table></figure>
<p>这种情况时是有意的，并且遵循箭头函数的设计。箭头函数的主要优点之一是它们没有自己的<code>this</code>绑定 - 取而代之的是 <code>this</code>被绑定到最近的函数体中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Friends</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> friends = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">friends</span>;</span><br><span class="line">    <span class="keyword">return</span> friends.<span class="title function_">map</span>(<span class="function"><span class="params">friend</span> =&gt;</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">Friend</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        // `<span class="attr">this</span>` <span class="attr">is</span> <span class="attr">resolved</span> <span class="attr">from</span> <span class="attr">the</span> `<span class="attr">render</span>` <span class="attr">method</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">size</span>=<span class="string">&#123;this.props.size&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;friend.name&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">key</span>=<span class="string">&#123;friend.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Okay，所以<strong>箭头功能没有自己的<code>this</code>。</strong> 这意味着箭头函数无法成为构造者！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 🔴 This wouldn’t make sense!</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，JavaScript不允许使用<code>new</code>调用箭头函数。如果你这样做，只会产生错误。这类似于JavaScript不允许在没有<code>new</code>的情况下调用类的方式。</p>
<p>这很不错，但它也使我们在全部函数调用前添加new的计划失败。 React不可以在所有情况下调用new，因为它会破坏箭头函数！我们可以尝试通过缺少<code>prototype</code>来判断出箭头函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;&#125;).<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// undefined</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;).<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// &#123;constructor: f&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是这个<a href="https://github.com/facebook/react/issues/4599#issuecomment-136562930">不适用</a>于使用<code>babel</code>编译的函数。这可能不是什么大问题，但还有另一个原因让这种方法失败。</p>
<h3 id="异常情况三："><a href="#异常情况三：" class="headerlink" title="异常情况三："></a>异常情况三：</h3><p>我们不能总是使用<code>new</code>的另一个原因是，这样做不支持返回字符串或其他原始类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Greeting</span>(); <span class="comment">// ✅ &#x27;Hello&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Greeting</span>(); <span class="comment">// 😳 Greeting &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这再次与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code>的设计</a>奇怪表现有关。正如我们之前看到的那样，<code>new</code>告诉JavaScript引擎创建一个对象，在函数内部创建该对象，然后将该对象作为<code>new</code>的结果。<br>但是，JavaScript还允许使用<code>new</code>调用的函数通过返回一些其他对象来覆盖<code>new</code>的返回值。这可能对类似对象池这样的模式很有用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created lazily</span></span><br><span class="line"><span class="keyword">var</span> zeroVector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vector</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> &amp;&amp; y === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (zeroVector !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Reuse the same instance</span></span><br><span class="line">      <span class="keyword">return</span> zeroVector;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroVector = <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 😲 b === c</span></span><br></pre></td></tr></table></figure>
<p>但是，如果函数的返回值不是对象，<code>new</code>会完全忽略函数的返回值。如果你返回一个字符串或一个数字，就好像没有返回一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Answer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Answer</span>(); <span class="comment">// ✅ 42</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Answer</span>(); <span class="comment">// 😳 Answer &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>当使用<code>new</code>调用函数时，无法从函数中读取原始返回值（如数字或字符串）。因此，如果React总是使用new，它将无法支持返回字符串类型的函数（组件）</p>
<p>这是不可接受的，所以我们得另寻他法。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>到目前为止我们了解到了什么？</strong>  React需要用<code>new</code>调用类（兼容<code>Babel</code>情况），但它需要调用常规函数或箭头函数（兼容Babel）时不能使用<code>new</code>。同时并没有可靠的方法来区分它们。<br><strong>如果我们无法解决一个普遍问题，那么我们能解决一个更具体的问题吗？</strong></p>
<p>将Component定义为class时，你可能希望继承<code>React.Component</code>使用其内置方法（比如<code>this.setState()</code>）。<strong>那么我们可以只检测React.Component子类，而不是尝试检测所有class吗？</strong></p>
<p><em>剧透：这正是React所做的。</em></p>
<h4 id="prototype-与-proto"><a href="#prototype-与-proto" class="headerlink" title="prototype 与 __proto__"></a><code>prototype</code> 与 <code>__proto__</code></h4><p>也许，判断<code>Greeting</code>是否是React component class的一般方法是测试<code>Greeting.prototype instanceof React.Component</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> A); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>我知道你在想什么。刚刚发生了什么？！要回答这个问题，我们需要了解JavaScript原型。</p>
<p>你可能熟悉原型链。JavaScript中的每个对象都可能有一个“原型”。当我们编写<code>fred.sayHi（）</code>但<code>fred</code>对象没有<code>sayHi</code>属性时，我们在<code>fred</code>的原型上查找<code>sayHi</code>属性。如果我们在那里找不到它，我们会看看链中的下一个原型–<code>fred</code>的原型的原型。并以此类推。</p>
<p><strong>令人困惑的是，类或函数的prototype属性并不指向该值的原型。</strong> 我不是在开玩笑。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 🤪 Not Person&#x27;s prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span>); <span class="comment">// 😳 Person&#x27;s prototype</span></span><br></pre></td></tr></table></figure>

<p>所以“原型链”更像是<code>__proto __.__ proto __.__ proto__</code>而不是<code>prototype.prototype.prototype</code>。我花了许多年才了解到这一点。</p>
<p><strong>所有对象的 <code>__proto__</code> 都指向其构造器的prototype</strong> 函数或类的<code>prototype</code>属性就是这样一个东西</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&#x27;Hi, I am &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Fred&#x27;</span>); <span class="comment">// Sets `fred.__proto__` to `Person.prototype`</span></span><br></pre></td></tr></table></figure>
<p>而<code>__proto__</code>链是JavaScript查找属性的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fred.<span class="title function_">sayHi</span>();</span><br><span class="line"><span class="comment">// 1. Does fred have a sayHi property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a sayHi property? Yes. Call it!</span></span><br><span class="line"></span><br><span class="line">fred.<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 1. Does fred have a toString property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a toString property? No.</span></span><br><span class="line"><span class="comment">// 3. Does fred.__proto__.__proto__ have a toString property? Yes. Call it!</span></span><br></pre></td></tr></table></figure>

<p>事实上，除非您正在调试与原型链相关的内容，否则您几乎不需要直接在代码中修改<code>__proto__</code>。如果你想在<code>fred .__ proto__</code>上添加东西，你应该把它放在<code>Person.prototype</code>上。它最初就是这么设计的。</p>
<p>甚至浏览器都不应该暴露<code>__proto__</code>属性，因为原型链被设计为一个内部概念。但是有些浏览器添加了<code>__proto__</code>，最终它被勉强标准化。</p>
<p>至今我仍然觉得“<code>prototype</code>的属性没有给你一个值的原型“非常令人困惑（例如，<code>fred.prototype</code>未定义，因为<code>fred</code>不是一个函数）。就个人而言，我认为这是导致经验丰富的开发人员也会误解JavaScript原型的最大原因。</p>
<h4 id="extends-与-原型链"><a href="#extends-与-原型链" class="headerlink" title="extends 与 原型链"></a>extends 与 原型链</h4><p>这帖子有点长 不是吗？别放弃！现在已经讲了80%的内容了，让我们继续吧</p>
<p>我们知道，当说调用<code>obj.foo</code>时，JavaScript实际上在<code>obj</code>，<code>obj .__ proto__</code>，<code>obj .__ proto __.__ proto__</code>中寻找<code>foo</code>，依此类推。</p>
<p>对于类来说原型链机制会更加复杂，但<code>extends</code>会使类完美适用原型链机制。这也是React类的实例访问<code>setState</code>之类的方法的原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">__proto__</span>); <span class="comment">// Greeting.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// React.Component.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line">c.<span class="title function_">render</span>();      <span class="comment">// Found on c.__proto__ (Greeting.prototype)</span></span><br><span class="line">c.<span class="title function_">setState</span>();    <span class="comment">// Found on c.__proto__.__proto__ (React.Component.prototype)</span></span><br><span class="line">c.<span class="title function_">toString</span>();    <span class="comment">// Found on c.__proto__.__proto__.__proto__ (Object.prototype)</span></span><br></pre></td></tr></table></figure>
<p>换句话说，类实例的<code>__protp__</code>链会镜像拷贝类的继承关系：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `extends` chain</span></span><br><span class="line"><span class="title class_">Greeting</span></span><br><span class="line">  → <span class="title class_">React</span>.<span class="property">Component</span></span><br><span class="line">    → <span class="title class_">Object</span> (implicitly)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Greeting</span>()</span><br><span class="line">  → <span class="title class_">Greeting</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    → <span class="title class_">React</span>.<span class="property">Component</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">      → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<p>如此两个链（继承链 原型链）</p>
<h4 id="instanceof-判断方式"><a href="#instanceof-判断方式" class="headerlink" title="instanceof 判断方式"></a>instanceof 判断方式</h4><p>由于<code>__proto__</code>链镜像拷贝类的继承关系，因此我们可以通过<code>Greeting</code>的原型链来判断<code>Greeting</code>是否继承了<code>React.Component</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Greeting</span>()</span><br><span class="line">  → <span class="title class_">Greeting</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 🕵️ We start here</span></span><br><span class="line">    → <span class="title class_">React</span>.<span class="property">Component</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// ✅ Found it!</span></span><br><span class="line">      → <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>
<p>方便的是，<code>x instanceof Y</code>就是相同的搜索原理。它在<code>x .__ proto__</code>链中寻找是否有<code>Y.prototype</code>存在。</p>
<p>通常，它用于确定某些东西是否是类的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting <span class="keyword">instanceof</span> <span class="title class_">Greeting</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting <span class="keyword">instanceof</span> <span class="title class_">React</span>.<span class="property">Component</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (✅ Found it!)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting <span class="keyword">instanceof</span> <span class="title class_">Banana</span>); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (🙅‍ Did not find it!)</span></span><br></pre></td></tr></table></figure>

<p>但它也可以用于确定一个类是否继承另一个类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Greeting</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">React</span>.<span class="property">Component</span>);</span><br><span class="line"><span class="comment">// greeting</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br></pre></td></tr></table></figure>

<p>这种判断方式就是是我们如何确定某些东西是React组件类还是一般函数。</p>
<h4 id="React-判断方式"><a href="#React-判断方式" class="headerlink" title="React 判断方式"></a>React 判断方式</h4><p>但这并不是React所做的。 😳</p>
<p><code>instanceof</code>解决方案的一个隐患是：当页面上有多个React副本时，我们正在检查的组件可能继承自另一个React副本的React.Component，这种instanceof方式就会失效。<br>在一个项目中混合使用React的多个副本是不好的方式，但我们应该尽可能避免出现由于历史遗留所产生的这种问题。 （使用Hooks，我们<a href="https://github.com/facebook/react/issues/13991">可能需要</a>强制删除重复数据。）</p>
<p>另一种可能的骚操作是检查原型上是否存在<code>render</code>方法。但是，当时还<a href="https://github.com/facebook/react/issues/4599#issuecomment-129714112">不清楚</a>组件API将如何变换。每个判断操作都有成本我们不想添加多于一次的操作。如果将render定义为实例方法（例如使用类属性语法），这也不起作用。</p>
<p>因此，React为基本组件<a href="https://github.com/facebook/react/pull/4663">添加</a>了一个特殊标志。React通过检查是该标志来判断一个东西是否是React组件类。</p>
<p>最初该标志在React.Component基础类本身上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property">isReactClass</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Greeting</span>.<span class="property">isReactClass</span>); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure>
<p>但是，我们想要判断的一些类实现没有<a href="https://github.com/scala-js/scala-js/issues/1900">复制</a>静态属性（或设置<code>__proto__</code>），因此标志丢失了。</p>
<p>这就是React将此标志移动到<code>React.Component.prototype</code>的原因：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> &#123;&#125;</span><br><span class="line"><span class="title class_">Component</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isReactComponent</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Greeting</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isReactComponent</span>); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure>
<p><strong>这就是React如何判断class的全部内容。</strong></p>
<hr>
<p>如今在React中使用就是<code>isReactComponent</code>标志检查。</p>
<p>如果不扩展React.Component，React将不会在原型上找到<code>isReactComponent</code>，也不会将组件视为类。现在你知道为什么<code>Cannot call a class as a function  </code>问题<a href="https://stackoverflow.com/questions/38481857/getting-cannot-call-a-class-as-a-function-in-my-react-project/42680526#42680526">最受欢迎的回答</a>是添加<code>extends React.Component</code>。最后，添加了一个<code>prototype.render</code>存在时，但<code>prototype.isReactComponent</code>不存在的<a href="https://github.com/facebook/react/pull/11168">警告</a>。</p>
<p><strong>实际的解决方案非常简单，但我用大量的时间解释了为什么React最终采取这个解决方案，以及替代方案是什么。</strong> 你可能觉得博文这个解释过程有点啰嗦，</p>
<p>根据我的经验，开发库API经常会遇到这种情况。为了使API易于使用，开发者需要考虑语言语义（可能，对于多种语言，包括未来的方向）、运行时性能、是否编译情况的兼容、完整体系和打包解决方案的状态、 早期预警和许多其他事情。 最终结果可能并不优雅，但必须实用。</p>
<p><strong>如果最终API是成功的，则用户永远不必考虑此过程。</strong> 取而代之的是他们只需要专注于创建应用程序。</p>
<p>但如果你也好奇……去探究其中的原因还是十分有趣的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E4%BA%8C%E6%9C%9F/" rel="prev" title="GitHub精选分享第二期">
                  <i class="fa fa-angle-left"></i> GitHub精选分享第二期
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%89%E6%9C%9F/" rel="next" title="GitHub精选分享第三期">
                  GitHub精选分享第三期 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">SunTongSheng</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">499k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:34</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":100,"height":200,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body>
</html>
