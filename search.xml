<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>(译)React是如何区分Class和Function？</title>
    <url>/essay/(%E8%AF%91)how-does-react-tell-a-class-from-a-function/</url>
    <content><![CDATA[<blockquote>
<p>原文地址: <a href="https://overreacted.io/how-does-react-tell-a-class-from-a-function/" target="_blank" rel="noopener">how-does-react-tell-a-class-from-a-function</a><br>本文地址： <a href="https://developerdoc.com/essay/(译)how-does-react-tell-a-class-from-a-function/">React是如何区分Class和Function？</a><br>边看边翻译 花了2h+… 如果你觉得读起来还算通顺不费事 那也算我为大家做了一点小贡献吧</p>
</blockquote>
<a id="more"></a>
<h2 id="React调用两者的不同之处"><a href="#React调用两者的不同之处" class="headerlink" title="React调用两者的不同之处"></a>React调用两者的不同之处</h2><p>一起来看下这个 function 类型的 <code>Greeting</code>组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 同样支持将它定义为 class 类型:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(直到<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">最近 hooks-intro</a>，这是使用state等特性的唯一方法。)</p>
<p>当你想渲染<code>&lt;Greeting /&gt;</code>组件时，你不必关心它是如何定义的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类或者函数，都可以</span></span><br><span class="line">&lt;Greeting /&gt;</span><br></pre></td></tr></table></figure>
<p>但是，作为 <em>React本身</em> 是会认为这两个是有不同之处的。</p>
<p>如果<code>Greeting</code>是一个函数，React 只需要直接调用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React内</span></span><br><span class="line"><span class="keyword">const</span> result = Greeting(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是如果<code>Greeting</code>是一个类，那么 React 就需要使用<code>new</code>来实例化它，然后在实例上调用<code>render</code>方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React内</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.render(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在这两种情况下，<code>React</code>的目标是获取渲染节点（本例中，是<code>&lt;p&gt; Hello &lt;/ p&gt;</code>），但确切的步骤取决于<code>Greeting</code>的类型。</p>
<p><strong>那么React如何知道某个东西是class类型还是function类型呢？</strong></p>
<p>事实上，这篇文章更多的是关于JavaScript而不是关于React。<br>如何你好奇React为何以某种方式运作，让我们一起挖掘其中的原理。</p>
<p><strong>这是一段漫长的探求之旅。这篇文章没有太多关于React本身的信息，我们将讨论<code>new</code>，<code>this</code>，<code>class</code>，<code>arrow function</code>，<code>prototype</code>，<code>__ proto__</code>，<code>instanceof</code>这些概念，以及这些东西如何在JavaScript中运作的机制。幸运的是，当你仅仅是使用React时，你不需要考虑这么多。但你如果要深究React……</strong></p>
<p>(如果你真的只想知道答案，请拉动到文章最后。)</p>
<h2 id="为什么要用不同的调用方式？"><a href="#为什么要用不同的调用方式？" class="headerlink" title="为什么要用不同的调用方式？"></a>为什么要用不同的调用方式？</h2><p>首先，我们需要理解以不同方式处理class和function的重要性。注意我们在调用类时如何使用new运算符：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If Greeting is a function</span></span><br><span class="line"><span class="keyword">const</span> result = Greeting(props); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If Greeting is a class</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Greeting(props); <span class="comment">// Greeting &#123;&#125;</span></span><br><span class="line"><span class="keyword">const</span> result = instance.render(); <span class="comment">// &lt;p&gt;Hello&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>让我们大致的了解下<code>new</code>在Javascript中做了什么：</p>
<hr>
<p>在ES6之前，Javascript没有class这个概念。但是，可以使用纯函数表现出和class相似的模式。 <strong>具体来说，你可以使用new来调用类似类构造方法的函数，来表现出和class相似的模式</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只是一个function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// ✅ Person &#123;name: 'Fred'&#125;</span></span><br><span class="line"><span class="keyword">var</span> george = Person(<span class="string">'George'</span>); <span class="comment">// 🔴 不会如期工作</span></span><br><span class="line"><span class="comment">//你今天仍然可以写这样的代码！在 `DevTools` 中尝试一下。</span></span><br></pre></td></tr></table></figure></p>
<p>如果不用<code>new</code>修饰<code>Person(&#39;Fred&#39;)</code>,Person内部的<code>this</code>在里面会指向 <code>window</code> 或者 <code>undefined</code> 。结果就是代码会崩溃或者像给<code>window.name</code>赋值一样愚蠢。</p>
<p>在调用之前添加<code>new</code>，等于说：“嘿 JavaScript，我知道<code>Person</code>只是一个函数，但让我们假装它是个类构造函数。 <strong>创建一个{}对象 并在<code>Person</code>函数内将<code>this</code>指向该对象， 这样我就可以赋值像<code>this.name</code>这样的东西。然后把那个对象返回给我。”</strong></p>
<p>上面这些就是<code>new</code>操作符做的事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// `Person`内，相同的对象作为`this`</span></span><br></pre></td></tr></table></figure>
<p>同时<code>new</code>操作符使上面的<code>fred</code>对象可以使用<code>Person.prototype</code>上的任何内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line">fred.sayHi();</span><br></pre></td></tr></table></figure>
<p>这是之前人们在JavaScript模拟类的方式。</p>
<p>可以看到的是在JavaScript早已有<code>new</code>。但是，<code>class</code>却是后来加入的特性。为了更明确我们的意图，重写一下代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    alert(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line">fred.sayHi();</span><br></pre></td></tr></table></figure></p>
<p><em>在语言和API设计中把握开发人员的意图非常重要。</em></p>
<p>如果你编写一个函数，JavaScript就无法猜测你的意思是像<code>alert()</code>一样被直接调用，还是像<code>new Person()</code>那样充当构造函数。忘记添加<code>new</code>会导致令人困惑的执行结果。</p>
<p><strong>class语法让我们明确的告诉Javascript：“这不仅仅是一个函数 - 它是一个类，它有一个构造函数”。</strong> 如果在调用class时忘记使用<code>new</code>，JavaScript抛出异常：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>);</span><br><span class="line"><span class="comment">// ✅  If Person is a function: works fine</span></span><br><span class="line"><span class="comment">// ✅  If Person is a class: works fine too</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> george = Person(<span class="string">'George'</span>); <span class="comment">// We forgot `new`</span></span><br><span class="line"><span class="comment">// 😳 If Person is a constructor-like function: confusing behavior</span></span><br><span class="line"><span class="comment">// 🔴 If Person is a class: fails immediately</span></span><br></pre></td></tr></table></figure></p>
<p>这有助于我们尽早发现错误，而不是出现一些不符合预期的结果 比如<code>this.name</code>被视为<code>window.name</code>而不是<code>george.name</code>。</p>
<p>但是，这意味着<code>React</code>需要在调用任何class之前使用<code>new</code>。它不能只是将其作为普通函数直接调用，因为JavaScript会将其视为错误！<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🔴 React can't just do this:</span></span><br><span class="line"><span class="keyword">const</span> instance = Counter(props);</span><br></pre></td></tr></table></figure></p>
<p>这意味着麻烦(麻烦就是在于React需要区分Class和Function……)。</p>
<h2 id="探究React式如何解决的"><a href="#探究React式如何解决的" class="headerlink" title="探究React式如何解决的"></a>探究React式如何解决的</h2><blockquote>
<p>babel之类编译工具给解决问题带来的麻烦</p>
</blockquote>
<p>在我们探究React式如何解决这个问题时，需要考虑到大多数人都使用Babel之类的编译器来兼容浏览器（例如转义class等），所以我们需要在设计中考虑编译器这种情况。</p>
<p>在Babel的早期版本中，可以在没有<code>new</code>的情况下调用类。但是通过生成一些额外的代码，这个情况已经被修复了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A bit simplified from Babel output:</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Our code:</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// ✅ Okay</span></span><br><span class="line">Person(<span class="string">'George'</span>);   <span class="comment">// 🔴 Can’t call class as a function</span></span><br></pre></td></tr></table></figure>
<p>你或许在打包文件中看到类似的代码，这就是<code>_classCallCheck</code>函数所做的功能。 （您可以通过设置“loose mode”不进行检查来减小捆绑包大小，但这可能会使代码最终转换为真正的原生类变得复杂。）</p>
<p>到现在为止，你应该大致了解使用<code>new</code>与不使用<code>new</code>来调用某些内容之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>new Person()</code></th>
<th><code>Person()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>class</code></td>
<td>✅ <code>this</code> is a <code>Person</code> instance</td>
<td>🔴 <code>TypeError</code></td>
</tr>
<tr>
<td><code>function</code></td>
<td>✅ <code>this</code> is a <code>Person</code> instance</td>
<td>😳 <code>this</code> is <code>window</code> or <code>undefined</code></td>
</tr>
</tbody>
</table>
<p>这之中的区别就是React为什么需要正确调用组件的重要原因。 <strong>如果您的组件被定义为类，React在调用它时需要使用<code>new</code>。</strong></p>
<p><strong>那么问题来了 React是否可以判断某个东西是不是一个class？</strong></p>
<p>没有那么容易！即使我们可以<a href="https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function" target="_blank" rel="noopener">在JavaScript es6 中区别class 和 function</a>，这仍然不适用于像Babel这样的工具处理之后的class。因为对于浏览器来说，它们只是单纯的function而已（class被babel处理后）。 </p>
<hr>
<p>Okay，也许React可以在每次调用时使用<code>new</code>？不幸的是，这也并不总是奏效。</p>
<h3 id="异常情况一："><a href="#异常情况一：" class="headerlink" title="异常情况一："></a>异常情况一：</h3><p>作为一般function，使用<code>new</code>调用它们会为它们提供一个对象实例作为<code>this</code>。对于作为构造函数编写的函数（如上面的<code>Person</code>），它是理想的，但它会给函数组件带来混乱：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 我们不希望“this”在这里成为任何一种情况下的实例</span></span><br><span class="line">  <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这种情况也是可以容忍的，但还有另外两个原因可以扼杀一直使用<code>new</code>的想法。</p>
<h3 id="异常情况二："><a href="#异常情况二：" class="headerlink" title="异常情况二："></a>异常情况二：</h3><p>第一个是箭头函数（未被babel编译时）会使<code>new</code>调用失效，使用<code>new</code>调用箭头函数会抛出一个异常<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Greeting = <span class="function"><span class="params">()</span> =&gt;</span> &lt;p&gt;Hello&lt;<span class="regexp">/p&gt;;</span></span><br><span class="line"><span class="regexp">new Greeting(); /</span><span class="regexp">/ 🔴 Greeting is not a constructor</span></span><br></pre></td></tr></table></figure></p>
<p>这种情况时是有意的，并且遵循箭头函数的设计。箭头函数的主要优点之一是它们没有自己的<code>this</code>绑定 - 取而代之的是 <code>this</code>被绑定到最近的函数体中。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Friends</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> friends = <span class="keyword">this</span>.props.friends;</span><br><span class="line">    <span class="keyword">return</span> friends.map(<span class="function"><span class="params">friend</span> =&gt;</span></span><br><span class="line">      &lt;Friend</span><br><span class="line">        <span class="comment">// `this` is resolved from the `render` method</span></span><br><span class="line">        size=&#123;<span class="keyword">this</span>.props.size&#125;</span><br><span class="line">        name=&#123;friend.name&#125;</span><br><span class="line">        key=&#123;friend.id&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Okay，所以<strong>箭头功能没有自己的<code>this</code>。</strong> 这意味着箭头函数无法成为构造者！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 🔴 This wouldn’t make sense!</span></span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，JavaScript不允许使用<code>new</code>调用箭头函数。如果你这样做，只会产生错误。这类似于JavaScript不允许在没有<code>new</code>的情况下调用类的方式。</p>
<p>这很不错，但它也使我们在全部函数调用前添加new的计划失败。 React不可以在所有情况下调用new，因为它会破坏箭头函数！我们可以尝试通过缺少<code>prototype</code>来判断出箭头函数：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).prototype <span class="comment">// undefined</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).prototype <span class="comment">// &#123;constructor: f&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>但是这个<a href="https://github.com/facebook/react/issues/4599#issuecomment-136562930" target="_blank" rel="noopener">不适用</a>于使用<code>babel</code>编译的函数。这可能不是什么大问题，但还有另一个原因让这种方法失败。</p>
<h3 id="异常情况三："><a href="#异常情况三：" class="headerlink" title="异常情况三："></a>异常情况三：</h3><p>我们不能总是使用<code>new</code>的另一个原因是，这样做不支持返回字符串或其他原始类型。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Greeting(); <span class="comment">// ✅ 'Hello'</span></span><br><span class="line"><span class="keyword">new</span> Greeting(); <span class="comment">// 😳 Greeting &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这再次与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener"><code>new</code>的设计</a>奇怪表现有关。正如我们之前看到的那样，<code>new</code>告诉JavaScript引擎创建一个对象，在函数内部创建该对象，然后将该对象作为<code>new</code>的结果。<br>但是，JavaScript还允许使用<code>new</code>调用的函数通过返回一些其他对象来覆盖<code>new</code>的返回值。这可能对类似对象池这样的模式很有用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created lazily</span></span><br><span class="line"><span class="keyword">var</span> zeroVector = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vector</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> &amp;&amp; y === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (zeroVector !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Reuse the same instance</span></span><br><span class="line">      <span class="keyword">return</span> zeroVector;</span><br><span class="line">    &#125;</span><br><span class="line">    zeroVector = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Vector(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Vector(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 😲 b === c</span></span><br></pre></td></tr></table></figure>
<p>但是，如果函数的返回值不是对象，<code>new</code>会完全忽略函数的返回值。如果你返回一个字符串或一个数字，就好像没有返回一样。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Answer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Answer(); <span class="comment">// ✅ 42</span></span><br><span class="line"><span class="keyword">new</span> Answer(); <span class="comment">// 😳 Answer &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>当使用<code>new</code>调用函数时，无法从函数中读取原始返回值（如数字或字符串）。因此，如果React总是使用new，它将无法支持返回字符串类型的函数（组件）</p>
<p>这是不可接受的，所以我们得另寻他法。</p>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><p><strong>到目前为止我们了解到了什么？</strong>  React需要用<code>new</code>调用类（兼容<code>Babel</code>情况），但它需要调用常规函数或箭头函数（兼容Babel）时不能使用<code>new</code>。同时并没有可靠的方法来区分它们。<br><strong>如果我们无法解决一个普遍问题，那么我们能解决一个更具体的问题吗？</strong></p>
<p>将Component定义为class时，你可能希望继承<code>React.Component</code>使用其内置方法（比如<code>this.setState()</code>）。<strong>那么我们可以只检测React.Component子类，而不是尝试检测所有class吗？</strong></p>
<p><em>剧透：这正是React所做的。</em></p>
<h4 id="prototype-与-proto"><a href="#prototype-与-proto" class="headerlink" title="prototype 与 __proto__"></a><code>prototype</code> 与 <code>__proto__</code></h4><p>也许，判断<code>Greeting</code>是否是React component class的一般方法是测试<code>Greeting.prototype instanceof React.Component</code>：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype <span class="keyword">instanceof</span> A); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>我知道你在想什么。刚刚发生了什么？！要回答这个问题，我们需要了解JavaScript原型。</p>
<p>你可能熟悉原型链。JavaScript中的每个对象都可能有一个“原型”。当我们编写<code>fred.sayHi（）</code>但<code>fred</code>对象没有<code>sayHi</code>属性时，我们在<code>fred</code>的原型上查找<code>sayHi</code>属性。如果我们在那里找不到它，我们会看看链中的下一个原型–<code>fred</code>的原型的原型。并以此类推。</p>
<p><strong>令人困惑的是，类或函数的prototype属性并不指向该值的原型。</strong> 我不是在开玩笑。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// 🤪 Not Person's prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__); <span class="comment">// 😳 Person's prototype</span></span><br></pre></td></tr></table></figure></p>
<p>所以“原型链”更像是<code>__proto __.__ proto __.__ proto__</code>而不是<code>prototype.prototype.prototype</code>。我花了许多年才了解到这一点。</p>
<p><strong>所有对象的 <code>__proto__</code> 都指向其构造器的prototype</strong> 函数或类的<code>prototype</code>属性就是这样一个东西<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi, I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fred = <span class="keyword">new</span> Person(<span class="string">'Fred'</span>); <span class="comment">// Sets `fred.__proto__` to `Person.prototype`</span></span><br></pre></td></tr></table></figure></p>
<p>而<code>__proto__</code>链是JavaScript查找属性的方式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fred.sayHi();</span><br><span class="line"><span class="comment">// 1. Does fred have a sayHi property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a sayHi property? Yes. Call it!</span></span><br><span class="line"></span><br><span class="line">fred.toString();</span><br><span class="line"><span class="comment">// 1. Does fred have a toString property? No.</span></span><br><span class="line"><span class="comment">// 2. Does fred.__proto__ have a toString property? No.</span></span><br><span class="line"><span class="comment">// 3. Does fred.__proto__.__proto__ have a toString property? Yes. Call it!</span></span><br></pre></td></tr></table></figure></p>
<p>事实上，除非您正在调试与原型链相关的内容，否则您几乎不需要直接在代码中修改<code>__proto__</code>。如果你想在<code>fred .__ proto__</code>上添加东西，你应该把它放在<code>Person.prototype</code>上。它最初就是这么设计的。</p>
<p>甚至浏览器都不应该暴露<code>__proto__</code>属性，因为原型链被设计为一个内部概念。但是有些浏览器添加了<code>__proto__</code>，最终它被勉强标准化。</p>
<p>至今我仍然觉得“<code>prototype</code>的属性没有给你一个值的原型“非常令人困惑（例如，<code>fred.prototype</code>未定义，因为<code>fred</code>不是一个函数）。就个人而言，我认为这是导致经验丰富的开发人员也会误解JavaScript原型的最大原因。</p>
<h4 id="extends-与-原型链"><a href="#extends-与-原型链" class="headerlink" title="extends 与 原型链"></a>extends 与 原型链</h4><p>这帖子有点长 不是吗？别放弃！现在已经讲了80%的内容了，让我们继续吧</p>
<p>我们知道，当说调用<code>obj.foo</code>时，JavaScript实际上在<code>obj</code>，<code>obj .__ proto__</code>，<code>obj .__ proto __.__ proto__</code>中寻找<code>foo</code>，依此类推。</p>
<p>对于类来说原型链机制会更加复杂，但<code>extends</code>会使类完美适用原型链机制。这也是React类的实例访问<code>setState</code>之类的方法的原理：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;Hello&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Greeting();</span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__); <span class="comment">// Greeting.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__.__proto__); <span class="comment">// React.Component.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(c.__proto__.__proto__.__proto__); <span class="comment">// Object.prototype</span></span><br><span class="line"></span><br><span class="line">c.render();      <span class="comment">// Found on c.__proto__ (Greeting.prototype)</span></span><br><span class="line">c.setState();    <span class="comment">// Found on c.__proto__.__proto__ (React.Component.prototype)</span></span><br><span class="line">c.toString();    <span class="comment">// Found on c.__proto__.__proto__.__proto__ (Object.prototype)</span></span><br></pre></td></tr></table></figure></p>
<p>换句话说，类实例的<code>__protp__</code>链会镜像拷贝类的继承关系：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `extends` chain</span></span><br><span class="line">Greeting</span><br><span class="line">  → React.Component</span><br><span class="line">    → <span class="built_in">Object</span> (implicitly)</span><br><span class="line"></span><br><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> Greeting()</span><br><span class="line">  → Greeting.prototype</span><br><span class="line">    → React.Component.prototype</span><br><span class="line">      → <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></p>
<p>如此两个链（继承链 原型链）</p>
<h4 id="instanceof-判断方式"><a href="#instanceof-判断方式" class="headerlink" title="instanceof 判断方式"></a>instanceof 判断方式</h4><p>由于<code>__proto__</code>链镜像拷贝类的继承关系，因此我们可以通过<code>Greeting</code>的原型链来判断<code>Greeting</code>是否继承了<code>React.Component</code>：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `__proto__` chain</span></span><br><span class="line"><span class="keyword">new</span> Greeting()</span><br><span class="line">  → Greeting.prototype <span class="comment">// 🕵️ We start here</span></span><br><span class="line">    → React.Component.prototype <span class="comment">// ✅ Found it!</span></span><br><span class="line">      → <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure></p>
<p>方便的是，<code>x instanceof Y</code>就是相同的搜索原理。它在<code>x .__ proto__</code>链中寻找是否有<code>Y.prototype</code>存在。</p>
<p>通常，它用于确定某些东西是否是类的实例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="keyword">new</span> Greeting();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> Greeting); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> React.Component); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (✅ Found it!)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting <span class="keyword">instanceof</span> Banana); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// greeting (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype </span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype (🙅‍ Did not find it!)</span></span><br></pre></td></tr></table></figure></p>
<p>但它也可以用于确定一个类是否继承另一个类：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Greeting.prototype <span class="keyword">instanceof</span> React.Component);</span><br><span class="line"><span class="comment">// greeting</span></span><br><span class="line"><span class="comment">//   .__proto__ → Greeting.prototype (🕵️‍ We start here)</span></span><br><span class="line"><span class="comment">//     .__proto__ → React.Component.prototype (✅ Found it!)</span></span><br><span class="line"><span class="comment">//       .__proto__ → Object.prototype</span></span><br></pre></td></tr></table></figure></p>
<p>这种判断方式就是是我们如何确定某些东西是React组件类还是一般函数。</p>
<h4 id="React-判断方式"><a href="#React-判断方式" class="headerlink" title="React 判断方式"></a>React 判断方式</h4><p>但这并不是React所做的。 😳</p>
<p><code>instanceof</code>解决方案的一个隐患是：当页面上有多个React副本时，我们正在检查的组件可能继承自另一个React副本的React.Component，这种instanceof方式就会失效。<br>在一个项目中混合使用React的多个副本是不好的方式，但我们应该尽可能避免出现由于历史遗留所产生的这种问题。 （使用Hooks，我们<a href="https://github.com/facebook/react/issues/13991" target="_blank" rel="noopener">可能需要</a>强制删除重复数据。）</p>
<p>另一种可能的骚操作是检查原型上是否存在<code>render</code>方法。但是，当时还<a href="https://github.com/facebook/react/issues/4599#issuecomment-129714112" target="_blank" rel="noopener">不清楚</a>组件API将如何变换。每个判断操作都有成本我们不想添加多于一次的操作。如果将render定义为实例方法（例如使用类属性语法），这也不起作用。</p>
<p>因此，React为基本组件<a href="https://github.com/facebook/react/pull/4663" target="_blank" rel="noopener">添加</a>了一个特殊标志。React通过检查是该标志来判断一个东西是否是React组件类。</p>
<p>最初该标志在React.Component基础类本身上：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Component.isReactClass = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Greeting.isReactClass); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure></p>
<p>但是，我们想要判断的一些类实现没有<a href="https://github.com/scala-js/scala-js/issues/1900" target="_blank" rel="noopener">复制</a>静态属性（或设置<code>__proto__</code>），因此标志丢失了。</p>
<p>这就是React将此标志移动到<code>React.Component.prototype</code>的原因：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can check it like this</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Greeting.prototype.isReactComponent); <span class="comment">// ✅ Yes</span></span><br></pre></td></tr></table></figure></p>
<p><strong>这就是React如何判断class的全部内容。</strong></p>
<hr>
<p>如今在React中使用就是<code>isReactComponent</code>标志检查。</p>
<p>如果不扩展React.Component，React将不会在原型上找到<code>isReactComponent</code>，也不会将组件视为类。现在你知道为什么<code>Cannot call a class as a function</code>问题<a href="https://stackoverflow.com/questions/38481857/getting-cannot-call-a-class-as-a-function-in-my-react-project/42680526#42680526" target="_blank" rel="noopener">最受欢迎的回答</a>是添加<code>extends React.Component</code>。最后，添加了一个<code>prototype.render</code>存在时，但<code>prototype.isReactComponent</code>不存在的<a href="https://github.com/facebook/react/pull/11168" target="_blank" rel="noopener">警告</a>。</p>
<p><strong>实际的解决方案非常简单，但我用大量的时间解释了为什么React最终采取这个解决方案，以及替代方案是什么。</strong> 你可能觉得博文这个解释过程有点啰嗦，</p>
<p>根据我的经验，开发库API经常会遇到这种情况。为了使API易于使用，开发者需要考虑语言语义（可能，对于多种语言，包括未来的方向）、运行时性能、是否编译情况的兼容、完整体系和打包解决方案的状态、 早期预警和许多其他事情。 最终结果可能并不优雅，但必须实用。</p>
<p><strong>如果最终API是成功的，则用户永远不必考虑此过程。</strong> 取而代之的是他们只需要专注于创建应用程序。</p>
<p>但如果你也好奇……去探究其中的原因还是十分有趣的。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>译文</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreLocation 教程</title>
    <url>/essay/CoreLocation/</url>
    <content><![CDATA[<h1 id="CoreLocation-iOS定位"><a href="#CoreLocation-iOS定位" class="headerlink" title="CoreLocation - iOS定位"></a>CoreLocation - iOS定位</h1><p>使用 <a href="https://developer.apple.com/documentation/corelocation" target="_blank" rel="noopener">CoreLocation</a> 框架定位，基本分为权限获取,位置更新，区域检测，iBeacon,方向检测，地理编码几方面。</p>
<p>demo链接： <a href="https://github.com/sunyanyan/BlogDemos/tree/master/Location_Demo" target="_blank" rel="noopener">Location_Demo</a></p>
<h2 id="iOS的定位支持"><a href="#iOS的定位支持" class="headerlink" title="iOS的定位支持"></a>iOS的定位支持</h2><blockquote>
<p>GPS卫星定位</p>
</blockquote>
<p>其原理就是:利用天上的卫星(24颗工作卫星和数颗备份星)不断地广播信号, 地面的GPS接收设备收到信号后, 通过分析多个卫星信号，就可以计算出地球坐标, GPS保证全球任何一个地方(98%)都可以同时收到至少4个卫星的信号, 从而可以准确确定您的经纬度以及海拔位置（三颗星只能获得经纬度，四颗星还可以获得海拔高度）。GPS定位精度可达10米以内<br><a id="more"></a><br>iOS的GPS定位于单纯的GPS定位不同，它是A-GPS（所谓辅助GPS），首先通过基站定位或WiFi定位获得该设备的大概位置，然后通过将设备的大致位置发发哦远程服务器，由服务器负责进行查询和计算，从而获取当前位置的卫星信息，并通过网络将这些卫星信息反馈给iOS设备，避免了iOS设备直接通过GPS扫面、分析天上的卫星信息。A-GPS优点是定位快，缺点是需要网络，但也只是在初次定位时需要网络，因为一旦卫星信息返回，在有限时间和范围内，这些信息无须改变，之后的GPS定位就不再需要联网，都是直接用这些卫星参数接受信息了。</p>
<p>与基站、WIFI定位相比，GPS定位耗电量最大，速度最慢，但是精度最高。</p>
<blockquote>
<p>基站定位</p>
</blockquote>
<p>每个手机基站都是一个标识符，iOS设备可以搜集周围所有收到信号的基站和它们的标识符，通过联网发送到苹果云端服务器，再由服务器根据这些基站的位置信息查询并计算出当前位置，然后把该定位信息返回给手机。</p>
<blockquote>
<p>WiFi定位</p>
</blockquote>
<p>iOS设备通过无线网卡搜集周围所有的WiFi热点，获得它们的MAC地址，然后通过Apple的云端服务器查询该WiFi热点是否已经登记，如果已经登记，即可获取该WiFi热点的位置，最后通过对多个WiFi热点折中计算得到当前位置并返回给iOS设备。精确度大概在几十米范围内。</p>
<h2 id="定位相关API"><a href="#定位相关API" class="headerlink" title="定位相关API"></a>定位相关API</h2><p>首先需要获取地理信息权限。定位权限分为 <strong>仅在使用应用期间</strong> 和 <strong>始终允许</strong> ; 获取到权限后，使用 CLLocationManager 类可以开始在其代理方法 <em>didUpdateLocations</em> 中获得CLLocation位置信息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CLLocationManager的常用操作</span></span><br><span class="line"><span class="comment">//开始用户定位</span></span><br><span class="line">- (<span class="keyword">void</span>)startUpdatingLocation;</span><br><span class="line"><span class="comment">//停止用户定位</span></span><br><span class="line">- (<span class="keyword">void</span>) stopUpdatingLocation;</span><br><span class="line"><span class="comment">//当调用了startUpdatingLocation方法后，就开始不断地定位用户的位置，中途会频繁地调用代理的下面方法</span></span><br><span class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didUpdateLocations:(<span class="built_in">NSArray</span> *)locations;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定位设置：</span></span><br><span class="line"><span class="comment">//只有当最新的位置与上一次获取的位置之间的距离, 大于这个值时, 才会通过代理告诉外界.</span></span><br><span class="line"><span class="keyword">self</span>.locationM.distanceFilter = <span class="number">100</span>;</span><br><span class="line">	 </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定位精确度</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyBestForNavigation    最适合导航</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyBest    精度最好的</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyNearestTenMeters    附近10米</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyHundredMeters    附近100米</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyKilometer    附近1000米</span></span><br><span class="line"><span class="comment">kCLLocationAccuracyThreeKilometers    附近3000米</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">self</span>.locationM.desiredAccuracy = kCLLocationAccuracyBest;</span><br></pre></td></tr></table></figure>
<p>可以获得的 CLLocation 位置信息包括了：经纬度、位置的精度、海拔高度、海拔高度的精度、速度等信息。</p>
<p>相应的通过CLLocation 可以计算两地之间的直线距离:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 北京:39.6 116.39</span></span><br><span class="line"><span class="comment">// 广州:23.08 113.15</span></span><br><span class="line"><span class="built_in">CLLocation</span> *BeiJing = [[<span class="built_in">CLLocation</span> alloc] initWithLatitude:<span class="number">39.6</span> longitude:<span class="number">116.39</span>];</span><br><span class="line"><span class="built_in">CLLocation</span> *GuangZhou = [[<span class="built_in">CLLocation</span> alloc] initWithLatitude:<span class="number">23.08</span> longitude:<span class="number">113.15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到两地之间的距离</span></span><br><span class="line"><span class="built_in">CLLocationDistance</span> distance = [BeiJing distanceFromLocation:GuangZhou];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%.2f"</span>, distance);</span><br></pre></td></tr></table></figure>
<h2 id="后台定位"><a href="#后台定位" class="headerlink" title="后台定位"></a>后台定位</h2><blockquote>
<p>后台短时间持续定位</p>
</blockquote>
<p>可以在 Background Modes 中开启Location Updates选项。这样就可以实现后台定位，但是该方法只能实现后台定位20-30分钟的时间。</p>
<blockquote>
<p>后台永久持续定位</p>
</blockquote>
<p>设置代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//allowsBackgroundLocationUpdates 这个属性是 iOS 9.0 新增的属性，</span></span><br><span class="line"><span class="comment">//默认为 NO ，设置为 YES</span></span><br><span class="line"><span class="comment">//需要保证 Target -&gt; Capabilities -&gt; Background Modes 的开关打开，并勾选 Location updates ，否则会导致 crash。</span></span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">9.0</span>, *)) &#123;</span><br><span class="line">	<span class="keyword">self</span>.locationManager.allowsBackgroundLocationUpdates = <span class="literal">YES</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fallback on earlier versions</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//系统是否可以自行中断程序的定位功能    </span></span><br><span class="line"><span class="keyword">self</span>.locationManager.pausesLocationUpdatesAutomatically = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>该方法让系统不能够自行关闭程序的定位功能，保证程序一直处于后台定位中， </p>
<p><strong>定位权限为应用使用期间的时候，程序在后台运行时会在顶部有一条蓝色的信息框<br>定位权限为始终的时候，就不会有蓝色框了。</strong></p>
<blockquote>
<p>关于 pausesLocationUpdatesAutomatically 属性</p>
</blockquote>
<p>CLLocationManager.pausesLocationUpdatesAutomatically 设置是否允许自动暂停定位服务，目前Apple的官方文档描述的很模糊，导致Stackoverflow上有很多的讨论：</p>
<p>该选项主要用来节省电量消耗，防止app在进入后台后没有及时停止定位消耗电量，设置为YES后，当iOS判定设备不太可能发生移动的时候(这句话是Apple文档直译，然而并不知道具体怎么判定)，会自动暂停掉定位服务以及相关硬件设备<br>app在后台定位时，一旦符合了Apple的判定，定位服务以及相关硬件设备被暂停了，除非app回到前台，否则不会恢复定位服务(硬件暂停使得iOS无法判定设备移动)</p>
<h2 id="区域监听"><a href="#区域监听" class="headerlink" title="区域监听"></a>区域监听</h2><p>区域监听是指,我们通过CLCircularRegion指定一个区域, 然后当用户持握设备进入或者离开指定区域, 我们都能监听到.</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化CLLocationManager等……</span></span><br><span class="line"> <span class="comment">// 1. 判断区域监听服务是否可用 </span></span><br><span class="line"> <span class="keyword">if</span> ([<span class="built_in">CLLocationManager</span> isMonitoringAvailableForClass:[<span class="built_in">CLCircularRegion</span> <span class="keyword">class</span>]]) </span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建区域中心</span></span><br><span class="line">     <span class="built_in">CLLocationCoordinate2D</span> center = <span class="built_in">CLLocationCoordinate2DMake</span>(<span class="number">29.12345</span>, <span class="number">131.23456</span>);</span><br><span class="line">     <span class="comment">// 创建区域（指定区域中心，和区域半径）</span></span><br><span class="line">     <span class="built_in">CLLocationDistance</span> radius = <span class="number">1000</span>;</span><br><span class="line">     <span class="comment">// 判断区域半径是否大于最大监听区域半径,如果大于, 就没法监听</span></span><br><span class="line">     <span class="keyword">if</span> (radius &gt; <span class="keyword">self</span>.locationM.maximumRegionMonitoringDistance) &#123;</span><br><span class="line">         radius = <span class="keyword">self</span>.locationM.maximumRegionMonitoringDistance;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">CLCircularRegion</span> *region = [[<span class="built_in">CLCircularRegion</span> alloc] initWithCenter:center radius:radius identifier:<span class="string">@"一个identifier"</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 开始监听指定区域</span></span><br><span class="line">     [<span class="keyword">self</span>.locationM startMonitoringForRegion:region];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;<span class="built_in">NSLog</span>(<span class="string">@"区域监听不可用"</span>);&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进去监听区域后调用 </span></span><br><span class="line">-(<span class="keyword">void</span>)locationManager:(<span class="keyword">nonnull</span> <span class="built_in">CLLocationManager</span> *)manager didEnterRegion:(<span class="keyword">nonnull</span> <span class="built_in">CLRegion</span> *)region</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"进入区域---%@"</span>, region.identifier);</span><br><span class="line">    [manager stopMonitoringForRegion:region];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开监听区域后调用 </span></span><br><span class="line">-(<span class="keyword">void</span>)locationManager:(<span class="keyword">nonnull</span> <span class="built_in">CLLocationManager</span> *)manager didExitRegion:(<span class="keyword">nonnull</span> <span class="built_in">CLRegion</span> *)region</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"离开区域---%@"</span>, region.identifier);</span><br><span class="line">    [manager stopMonitoringForRegion:region];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听某个区域时, 只有进入或者离开这个区域时, 才能回调对应的方法, 是一个进入或者离开的动作 </span></span><br><span class="line"><span class="comment">//如果想知道某一个区域的当前状态(识别用户是在区域内部, 还是区域外部), 则需要使用以下方法</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.locationM requestStateForRegion:region];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求某个区域状态时, 回调的代理方法</span></span><br><span class="line">-(<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didDetermineState:(<span class="built_in">CLRegionState</span>)state forRegion:(<span class="built_in">CLRegion</span> *)region</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">CLRegionStateUnknown</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"未知状态"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">CLRegionStateInside</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"在区域内部"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">CLRegionStateOutside</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"在区域外部"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ibeacon"><a href="#ibeacon" class="headerlink" title="ibeacon"></a>ibeacon</h2><p>iBeacon 是苹果公司2013年9月发布的移动设备用OS（iOS7）上配备的新功能。其工作方式是，配备有低功耗蓝牙（BLE）通信功能的设备使用BLE技术向周围发送自己特有的 ID，接收到该 ID 的应用软件会根据该 ID 采取一些行动。</p>
<p>iOS 中 iBeacon 是基于地理位置的微定位技术，虽然借助手机蓝牙进行接收Majro、Minor，但是他们在开发工程中没有任何关系。<br>iBeacon使用苹果提供CoreLocation库，然而在 BLE 在开发过程中使用CoreBluetooth库。从上面提供的库来看就很清楚了，特别是在 iOS8.0 之后的时候如果想使用iBeacon，必须让用户点击是否允许XXapp使用地理位置。如果在第一次使用 iOS App 扫描iBeacon的时候没有提示这句话，是不可能接收到iBeacon的信号（除非iOS 8.0之下）。如果是 BLE 则的开发过程中之需要提示用户打开蓝牙，并不要求其他的地理位置任何信息。</p>
<p><em>就不写代码了……</em></p>
<h2 id="地理编码与反地理编码"><a href="#地理编码与反地理编码" class="headerlink" title="地理编码与反地理编码"></a>地理编码与反地理编码</h2><p>需要获得网络权限</p>
<blockquote>
<p>地理编码：根据给定的地名，获得具体的位置信息（比如经纬度、地址的全称等)。</p>
</blockquote>
<p>输入上海市闵行区南华街25号的结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CLGeocoder</span> *geocoder = [[<span class="built_in">CLGeocoder</span> alloc] init];</span><br><span class="line">[geocoder geocodeAddressString:address </span><br><span class="line">completionHandler:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">CLPlacemark</span> *&gt; * _Nullable placemarks, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="comment">//获取结果        </span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p><img src="/res/CoreLocation/1.jpeg" alt></p>
<blockquote>
<p>反地理编码：根据给定的经纬度，获得具体的位置信息,省市区街道等信息;</p>
</blockquote>
<p>解析定位当前的位置的结果：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CLGeocoder</span> *geocoder = [[<span class="built_in">CLGeocoder</span> alloc] init];</span><br><span class="line">[geocoder reverseGeocodeLocation:location </span><br><span class="line">completionHandler:^(<span class="built_in">NSArray</span>&lt;<span class="built_in">CLPlacemark</span> *&gt; * _Nullable placemarks, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line"><span class="comment">//获取结果</span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p><img src="/res/CoreLocation/2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLPlacemark 地标对象详解</span><br><span class="line">    location            : CLLocation 类型, 位置对象信息, 里面包含经纬度, 海拔等等</span><br><span class="line">    region              : CLRegion 类型, 地标对象对应的区域</span><br><span class="line">    addressDictionary  : NSDictionary 类型, 存放街道,省市等信息</span><br><span class="line">    name                : NSString 类型, 地址全称</span><br><span class="line">    thoroughfare        : NSString 类型, 街道名称</span><br><span class="line">    locality            : NSString 类型, 城市名称</span><br><span class="line">    administrativeArea : NSString 类型, 省名称</span><br><span class="line">    country             : NSString 类型, 国家名称</span><br></pre></td></tr></table></figure>
<h2 id="方向监测-指南针"><a href="#方向监测-指南针" class="headerlink" title="方向监测 / 指南针"></a>方向监测 / 指南针</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取指南针信息</span></span><br><span class="line"><span class="comment">//①、CLLocationDegrees headingFilter：设置只有当设置方向的改变值超过该属性值时才激发delegate方法；</span></span><br><span class="line"><span class="comment">//②、CLDeviceOrientation headingOrientation：设置设备当前方向；</span></span><br><span class="line">[<span class="keyword">self</span>.locationManager startUpdatingHeading];</span><br><span class="line"><span class="comment">//当设备的方向改变时，iOS系统将会自动激发CLLocationManager的delegate对象的</span></span><br><span class="line">- (<span class="keyword">void</span>)locationManager:(<span class="built_in">CLLocationManager</span> *)manager didUpdateHeading:(<span class="built_in">CLHeading</span> *)newHeading &#123;</span><br><span class="line"> <span class="comment">//CLHeading方法的主要参数：</span></span><br><span class="line"><span class="comment">//与磁北方向的偏角@property(readonly, nonatomic) CLLocationDirection magneticHeading; </span></span><br><span class="line"><span class="comment">//与正北方向的偏角@property(readonly, nonatomic) CLLocationDirection trueHeading;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>方向补充：</p>
</blockquote>
<p>Core Location支持两种不同的获取方向相关信息的方式：</p>
<p>当设备处于某个点时(CLHeading)，带有磁力计的设备能能够报告其位置信息；此类被称为设备的朝向。<br>当设备处于移动过程中时(CLLocation.course)，通过带有GPS硬件的报告的位置位置信息；此类被称为设备的行动方向。</p>
<p>朝向和行动方向表现出设备不同的信息。设备的朝向真实的反映出了设备在一个点时相对于磁北或者真北的朝向。而设备的行动方向则表现了设备在运动过程中的运动方向其并没有考虑设备的方向。你使用一种还是这两种相结合，完全取决于你的APP；例如：一个导航APP是否要在两者之间切换完全取决于用户的速度，在步行速度时，设备的朝向对于在当前环境下的确认用户方向是用户最为关心的事情；而在一辆车里运动时，行动方向则变得尤为重要。</p>
<hr>
<blockquote>
<p>后台定位补充：</p>
</blockquote>
<p><em>关于 pausesLocationUpdatesAutomatically 属性</em>:</p>
<p>CLLocationManager.pausesLocationUpdatesAutomatically 设置是否允许自动暂停定位服务，目前Apple的官方文档描述的很模糊，导致<a href="https://stackoverflow.com/questions/17484352/iphone-gps-in-background-never-resumes-after-pause" target="_blank" rel="noopener">Stackoverflow上有很多的讨论</a>：</p>
<p>该选项主要用来节省电量消耗，防止app在进入后台后没有及时停止定位消耗电量，设置为YES后，当iOS判定  <strong>设备不太可能发生移动的时候</strong>  (这句话是Apple文档直译，然而并不知道具体怎么判定)，会自动暂停掉定位服务以及相关硬件设备</p>
<p><em>唤醒</em>:</p>
<p>首先这个方法需要 始终 权限，然后在开启定位调用 startUpdatingLocation 的同时调用 startMonitoringSignificantLocationChanges 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[_locationManager startUpdatingLocation];</span><br><span class="line"><span class="comment">// 开启位置明显变化监控</span></span><br><span class="line">[_locationManager startMonitoringSignificantLocationChanges];</span><br></pre></td></tr></table></figure>
<p>开启了这个方法之后，当位置发生较明显的变化时同样会触发一个位置更新事件，这个变化距离不依据 distanceFilter 属性值变化，而是固定的 500 米（指与上一次触发此事件时的距离），且每 5 分钟最多触发一次，触发的时候如果 APP 被杀死了，这个事件还会唤醒 APP ，APP 会在用户无感知的情况下重新走正常的启动流程，只是界面上没有任何显示，此时会在 application:didFinishLaunchingWithOptions: 方法中携带 UIApplicationLaunchOptionsLocationKey 这个 key 来表明当前启动是被位置事件唤醒的，请注意判断这个 key 来绕过一些不需要在后台启动时执行的逻辑，或者执行一些你想要在后台启动后执行的逻辑，比如启动位置上报服务。在 APP 重新启动之后需要重新调用 startMonitoringSignificantLocationChanges 以保证 APP 再次被杀之后能被重新唤醒。</p>
<p>由此方法触发的位置更新事件同样会调用正常位置更新服务 startUpdatingLocation 的locationManager:didUpdateLocations: 回调方法，这个更新事件可能是一个最近缓存的位置，也可能是最新位置，而更精确的位置会在几秒钟之后再次回调，所以如果对细微位置差别比较敏感的话，可以通过回调的 CLLocation 对象中的时间戳来过滤。</p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Autorelease相关.md</title>
    <url>/essay/Autorelease%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="Autorelease对象什么时候释放？"><a href="#Autorelease对象什么时候释放？" class="headerlink" title="Autorelease对象什么时候释放？"></a>Autorelease对象什么时候释放？</h2><p>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，</p>
<p>而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</p>
<a id="more"></a>
<p>当然，我们也可以手动添加<code>@autoreleasepool</code>干预Autorelease对象的释放时机：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"sunnyxx"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str); <span class="comment">// Console: (null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="什么时候用-autoreleasepool"><a href="#什么时候用-autoreleasepool" class="headerlink" title="什么时候用@autoreleasepool"></a>什么时候用@autoreleasepool</h2><p>根据<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">Apple的文档</a>，使用场景如下：</p>
<ul>
<li>写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。</li>
<li>写循环，循环里面包含了大量临时创建的对象。（本文的例子）</li>
<li>创建了新的线程。（非Cocoa程序创建线程时才需要）</li>
<li>长时间在后台运行的任务。</li>
</ul>
<h3 id="利用-autoreleasepool优化循环"><a href="#利用-autoreleasepool优化循环" class="headerlink" title="利用@autoreleasepool优化循环"></a>利用@autoreleasepool优化循环</h3><p>利用@autoreleasepool优化循环的内存占用，我觉得最有用的一点，下面就说说这个点。<br>如下面的循环，次数非常多，而且循环体里面的对象都是临时创建使用的，就可以用@autoreleasepool包起来，让每次循环结束时，可以及时的释放临时对象的内存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来自Apple文档，见参考</span></span><br><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> urls) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span> stringWithContentsOfURL:url</span><br><span class="line">                                        encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error];</span><br><span class="line">        <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool</p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreText介绍.md</title>
    <url>/essay/CoreText%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>介绍CoreText的一些概念</p>
</blockquote>
<a id="more"></a>
<h3 id="Core-Text基础"><a href="#Core-Text基础" class="headerlink" title="Core Text基础"></a>Core Text基础</h3><p><img src="/res/CoreText/coretext_framework_arch.png" alt></p>
<p>CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。</p>
<p> UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处：</p>
<pre><code>CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。
CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取）
CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。
基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。
</code></pre><p>当然，基于 CoreText 的排版方案也有一些劣势：</p>
<pre><code>CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。
基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。
</code></pre><p>以下是Core Text的构成：</p>
<p><img src="/res/CoreText/core_text_arch.png" alt></p>
<ul>
<li>CTFrame可以想象成画布, 画布的大小范围由CGPath决定</li>
<li>CTFrame由很多CTLine组成, CTLine表示为一行</li>
<li>CTLine由多个CTRun组成, CTRun相当于一行中的多个块, 但是CTRun不需要你自己创建, 由NSAttributedString的属性决定, 系统自动生成。每个CTRun对应不同属性</li>
<li>CTFramesetter是一个工厂, 创建CTFrame, 一个界面上可以有多个CTFrame</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><img src="/res/CoreText/coretext_text_handing.png" alt></p>
<ul>
<li>字体(Font):是一系列字号、样式和磅值相同的字符(例如:10磅黑体Palatino)。现多被视为字样的同义词</li>
<li>字面(Face):是所有字号的磅值和格式的综合</li>
<li>字体集(Font family):是一组相关字体(例如:Franklin family包括Franklin Gothic、Fran-klinHeavy和Franklin Compressed)</li>
<li>磅值(Weight):用于描述字体粗度。典型的磅值,从最粗到最细,有极细、细、book、中等、半粗、粗、较粗、极粗</li>
<li>样式(Style):字形有三种形式:Roman type是直体;oblique type是斜体;utakuc type是斜体兼曲线(比Roman type更像书法体)。</li>
<li>x高度(X height):指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大</li>
<li>Cap高度(Cap height):与x高度相似。指大写字母的平均高度(以C为基准)</li>
<li>下行字母(Descender):例如在字母q中,基线以下的字母部分叫下伸部分</li>
<li>上行字母(Ascender):x高度以上的部分(比如字母b)叫做上伸部分</li>
<li>基线(Baseline):通常在x、v、b、m下的那条线 描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状</li>
</ul>
<h3 id="CoreText定义的字体-样式"><a href="#CoreText定义的字体-样式" class="headerlink" title="CoreText定义的字体 样式"></a>CoreText定义的字体 样式</h3><blockquote>
<p>可以在 CTStringAttributes.h 中找到</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTCharacterShapeAttributeName;</span><br><span class="line"><span class="comment">//字体形状属性  必须是CFNumberRef对象默认为0，非0则对应相应的字符形状定义，如1表示传统字符形状</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTFontAttributeName;</span><br><span class="line"><span class="comment">//字体属性   必须是CTFont对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTKernAttributeName;</span><br><span class="line"><span class="comment">//字符间隔属性 必须是CFNumberRef对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTLigatureAttributeName;</span><br><span class="line"><span class="comment">//设置是否使用连字属性，设置为0，表示不使用连字属性。标准的英文连字有FI,FL.默认值为1，既是使用标准连字。也就是当搜索到f时候，会把fl当成一个文字。必须是CFNumberRef 默认为1,可取0,1,2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTForegroundColorAttributeName;</span><br><span class="line"><span class="comment">//字体颜色属性  必须是CGColor对象，默认为black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTForegroundColorFromContextAttributeName;</span><br><span class="line"> <span class="comment">//上下文的字体颜色属性 必须为CFBooleanRef 默认为False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTParagraphStyleAttributeName;</span><br><span class="line"><span class="comment">//段落样式属性 必须是CTParagraphStyle对象 默认为NIL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTStrokeWidthAttributeName;</span><br><span class="line"><span class="comment">//笔画线条宽度 必须是CFNumberRef对象，默为0.0f，标准为3.0f</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTStrokeColorAttributeName;</span><br><span class="line"><span class="comment">//笔画的颜色属性 必须是CGColorRef 对象，默认为前景色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTSuperscriptAttributeName;</span><br><span class="line"><span class="comment">//设置字体的上下标属性 必须是CFNumberRef对象 默认为0,可为-1为下标,1为上标，需要字体支持才行。如排列组合的样式Cn1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTUnderlineColorAttributeName;</span><br><span class="line"><span class="comment">//字体下划线颜色属性 必须是CGColorRef对象，默认为前景色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTUnderlineStyleAttributeName;</span><br><span class="line"><span class="comment">//字体下划线样式属性 必须是CFNumberRef对象,默为kCTUnderlineStyleNone 可以通过CTUnderlineStypleModifiers 进行修改下划线风格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTVerticalFormsAttributeName;</span><br><span class="line"><span class="comment">//文字的字形方向属性 必须是CFBooleanRef 默认为false，false表示水平方向，true表示竖直方向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTGlyphInfoAttributeName;</span><br><span class="line"><span class="comment">//字体信息属性 必须是CTGlyphInfo对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCTRunDelegateAttributeName</span><br><span class="line"><span class="comment">//CTRun 委托属性 必须是CTRunDelegate对象</span></span><br></pre></td></tr></table></figure>
<h3 id="CoreText坐标系"><a href="#CoreText坐标系" class="headerlink" title="CoreText坐标系"></a>CoreText坐标系</h3><p><img src="/res/CoreText/coreText_zuobiao.png" alt></p>
<p>从图中可看出CoreText坐标系是以左下角为坐标原点，而我们常使用的UIKit是以左上角为坐标原点，因此在CoreText中的布局完成后需要对其坐标系进行转换，否则直接绘制出现位置反转的镜像情况。</p>
<h3 id="CoreText-图文混排"><a href="#CoreText-图文混排" class="headerlink" title="CoreText 图文混排"></a>CoreText 图文混排</h3><p>CoreText实际上并没有相应API直接将一个图片转换为CTRun并进行绘制，它所能做的只是为图片预留相应的空白区域，而真正的绘制则是交由CoreGraphics完成。(像OSX就方便很多，直接将图片打包进NSTextAttachment即可，根本无须操心绘制的事情，所以基于这个想法，M80AttributedLabel的接口和实现也是使用了attachment这么个概念，图片或者UIView都是被当作文字段中的attachment。)</p>
<p>在CoreText中提供了CTRunDelegate这么个Core Foundation类，顾名思义它可以对CTRun进行拓展：AttributedString某个段设置kCTRunDelegateAttributeName属性之后，CoreText使用它生成CTRun是通过当前Delegate的回调来获取自己的ascent，descent和width，而不是根据字体信息。这样就给我们留下了可操作的空间：用一个空白字符作为图片的占位符，设好Delegate，占好位置，然后用CoreGraphics进行图片的绘制。</p>
<h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><blockquote>
<p>新建一个UIView类，在其drawRect方法中</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.获取上下文</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">// 2.转换坐标系</span></span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context, <span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context , <span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="comment">// 3.初始化路径 (绘制的区域)</span></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path , <span class="literal">NULL</span> , <span class="keyword">self</span>.bounds);</span><br><span class="line">    <span class="comment">// 4.初始化字符串</span></span><br><span class="line">    <span class="built_in">NSAttributedString</span>* attString = [[<span class="built_in">NSAttributedString</span> alloc]initWithString:<span class="string">@"Hello CoreText"</span>];</span><br><span class="line">    <span class="comment">// 5.初始化framesetter</span></span><br><span class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attString);</span><br><span class="line">    <span class="comment">// 6. 绘制frame</span></span><br><span class="line">    <span class="built_in">CTFrameRef</span> frame = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, [attString length]), path , <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 7. 绘制富文本</span></span><br><span class="line">    <span class="built_in">CTFrameDraw</span>(frame, context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. 释放</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(frame);</span><br><span class="line">    <span class="built_in">CFRelease</span>(path);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Hello CoreText</code>就会显示在该View上了，这是CoreText的基本使用步骤。</p>
<h3 id="简单的富文本"><a href="#简单的富文本" class="headerlink" title="简单的富文本"></a>简单的富文本</h3><blockquote>
<p>在上面代码的基础上，为NSAttributeString添加相关的字体信息</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableAttributedString</span>* mAttStr = [[<span class="built_in">NSMutableAttributedString</span> alloc]initWithString:<span class="string">@"Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;Hello CoreText ;"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置字体属性</span></span><br><span class="line"><span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>(<span class="built_in">CFSTR</span>(<span class="string">"Georgia"</span>), <span class="number">40</span>, <span class="literal">NULL</span>);</span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTFontAttributeName value:(__bridge <span class="keyword">id</span> _Nonnull)(font)  range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置斜体字</span></span><br><span class="line"><span class="built_in">CTFontRef</span> font2 = <span class="built_in">CTFontCreateWithName</span>((<span class="built_in">CFStringRef</span>)[<span class="built_in">UIFont</span> italicSystemFontOfSize:<span class="number">20</span>].fontName, <span class="number">14</span>, <span class="literal">NULL</span>);</span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTFontAttributeName value:(__bridge <span class="keyword">id</span> _Nonnull)(font2)  range:<span class="built_in">NSMakeRange</span>(<span class="number">6</span>, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//下划线</span></span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTUnderlineStyleAttributeName value:(<span class="keyword">id</span>)[<span class="built_in">NSNumber</span> numberWithInt:kCTUnderlineStyleDouble] range:<span class="built_in">NSMakeRange</span>(<span class="number">18</span>, <span class="number">4</span>)];</span><br><span class="line"><span class="comment">//下划线颜色</span></span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTUnderlineStyleAttributeName value:(<span class="keyword">id</span>)[<span class="built_in">NSNumber</span> numberWithInt:kCTUnderlineStyleSingle] range:<span class="built_in">NSMakeRange</span>(<span class="number">25</span>, <span class="number">4</span>)];</span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTUnderlineColorAttributeName value:(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor range:<span class="built_in">NSMakeRange</span>(<span class="number">25</span>, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置字体间隔</span></span><br><span class="line"><span class="keyword">long</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">CFNumberRef</span> num = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTKernAttributeName value:(__bridge <span class="keyword">id</span>)num range:<span class="built_in">NSMakeRange</span>(<span class="number">36</span>, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置字体颜色</span></span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTForegroundColorAttributeName value:(<span class="keyword">id</span>)[<span class="built_in">UIColor</span> redColor].CGColor range:<span class="built_in">NSMakeRange</span>(<span class="number">43</span>, <span class="number">4</span>)];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置空心字</span></span><br><span class="line"><span class="keyword">long</span> number2 = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">CFNumberRef</span> num2 = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number2);</span><br><span class="line">[mAttStr addAttribute:(<span class="keyword">id</span>)kCTStrokeWidthAttributeName value:(__bridge <span class="keyword">id</span>)num2 range:<span class="built_in">NSMakeRange</span>(<span class="number">54</span>, <span class="number">4</span>)];</span><br></pre></td></tr></table></figure>
<p>效果图:<br><img src="/res/CoreText/CoreText.png" alt></p>
<h3 id="更多的样式"><a href="#更多的样式" class="headerlink" title="更多的样式"></a>更多的样式</h3><blockquote>
<p>在介绍如何绘制更多样式之前，需要介绍 按Line绘制 <code>CTLineDraw</code> 和按Run绘制 <code>CTRunDraw</code></p>
</blockquote>
<h4 id="CTLineDraw-按行绘制"><a href="#CTLineDraw-按行绘制" class="headerlink" title="CTLineDraw 按行绘制"></a>CTLineDraw 按行绘制</h4><p>将上面的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CTFrameDraw</span>(frame, context);</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.2使用CTLine绘制</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(frame);</span><br><span class="line"><span class="built_in">CFIndex</span> numOfLines =  <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line"><span class="comment">//获取每一行的origin,CoreText的origin是在字形的baseLine处</span></span><br><span class="line"><span class="built_in">CGPoint</span> lineOrigins[<span class="built_in">CFArrayGetCount</span>(lines)];</span><br><span class="line"><span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfLines; i++) &#123;</span><br><span class="line">    <span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">    <span class="comment">//设置每一行的位置</span></span><br><span class="line">    <span class="built_in">CGContextSetTextPosition</span>(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">    <span class="comment">//开始一行的绘制</span></span><br><span class="line">    <span class="built_in">CTLineDraw</span>(line , context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CTRunDraw-按Run绘制"><a href="#CTRunDraw-按Run绘制" class="headerlink" title="CTRunDraw 按Run绘制"></a>CTRunDraw 按Run绘制</h4><p>将上面的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CTFrameDraw</span>(frame, context);</span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.3 使用CTRun绘制</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(frame);</span><br><span class="line"><span class="built_in">CFIndex</span> numOfLines =  <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    <span class="comment">//获取每一行的origin,CoreText的origin是在字形的baseLine处</span></span><br><span class="line"><span class="built_in">CGPoint</span> lineOrigins[<span class="built_in">CFArrayGetCount</span>(lines)];</span><br><span class="line"><span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfLines; i++) &#123;</span><br><span class="line">    <span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">        <span class="comment">//设置每一行的位置</span></span><br><span class="line">    <span class="built_in">CGContextSetTextPosition</span>(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">        <span class="comment">//开始每个run的绘制</span></span><br><span class="line">    <span class="built_in">CFArrayRef</span> runs = <span class="built_in">CTLineGetGlyphRuns</span>(line);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">CFArrayGetCount</span>(runs); j++) &#123;</span><br><span class="line">        <span class="built_in">CTRunRef</span> run = <span class="built_in">CFArrayGetValueAtIndex</span>(runs, j);</span><br><span class="line">        <span class="built_in">CTRunDraw</span>(run, context, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终 CTRunDraw CTLineDraw 和 CTFrameDraw的绘制结果都是相同的。</p>
<h4 id="实现删除线效果"><a href="#实现删除线效果" class="headerlink" title="实现删除线效果"></a>实现删除线效果</h4><blockquote>
<p>既然我们可以按照一小块CTRun的方式绘制，就可以对一些CTRun做一些自定义绘制</p>
<p>比如在 &lt; CoreText/CTStringArrtibutes.h &gt;中并没有找到删除线的定义，我们可以尝试去实现它。</p>
</blockquote>
<p><strong>一、</strong>在NSAttributedString中添加删除线属性（<code>NSStrikethroughStyleAttributeName</code>字段定义在NSAttributedString.h中，coreText没有对应的实现）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//额外的删除线</span></span><br><span class="line">[mAttStr addAttribute:<span class="built_in">NSStrikethroughStyleAttributeName</span> value:[<span class="built_in">NSNumber</span> numberWithInt:<span class="built_in">NSUnderlineStyleSingle</span>] range:<span class="built_in">NSMakeRange</span>(<span class="number">72</span>,<span class="number">18</span>)];</span><br></pre></td></tr></table></figure>
<p><strong>二、</strong>在上面按run绘制的基础上判断一下有无删除线属性，有就绘制。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.3 使用CTRun绘制</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(frame);</span><br><span class="line"><span class="built_in">CFIndex</span> numOfLines =  <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    <span class="comment">//获取每一行的origin,CoreText的origin是在字形的baseLine处</span></span><br><span class="line"><span class="built_in">CGPoint</span> lineOrigins[<span class="built_in">CFArrayGetCount</span>(lines)];</span><br><span class="line"><span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfLines; i++) &#123;</span><br><span class="line">    <span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">        <span class="comment">//设置每一行的位置</span></span><br><span class="line">    <span class="built_in">CGContextSetTextPosition</span>(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">        <span class="comment">//开始每个run的绘制</span></span><br><span class="line">    <span class="built_in">CFArrayRef</span> runs = <span class="built_in">CTLineGetGlyphRuns</span>(line);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">CFArrayGetCount</span>(runs); j++) &#123;</span><br><span class="line">        <span class="built_in">CTRunRef</span> run = <span class="built_in">CFArrayGetValueAtIndex</span>(runs, j);</span><br><span class="line">        <span class="built_in">CTRunDraw</span>(run, context, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取run的样式</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *runAttributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);</span><br><span class="line">        <span class="comment">//判断是否有指定的样式</span></span><br><span class="line">        <span class="keyword">if</span>(runAttributes[<span class="built_in">NSStrikethroughStyleAttributeName</span>] != <span class="literal">nil</span>)&#123;</span><br><span class="line">            <span class="comment">//绘制样式</span></span><br><span class="line">            [<span class="keyword">self</span> drawStrikethroughStyleInRun:run attributes:runAttributes context:context];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三、</strong> 实现方法 <code>-drawStrikethroughStyleInRun: attributes : context :</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 画删除线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)drawStrikethroughStyleInRun:(<span class="built_in">CTRunRef</span>)run attributes: (<span class="built_in">NSDictionary</span>*)attributes context:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFNumberRef</span> styleRef = (__bridge <span class="built_in">CFNumberRef</span>)(attributes[<span class="built_in">NSStrikethroughStyleAttributeName</span>]);</span><br><span class="line">    <span class="built_in">NSUnderlineStyle</span> style = <span class="built_in">NSUnderlineStyleNone</span>;</span><br><span class="line">    <span class="built_in">CFNumberGetValue</span>(styleRef, kCFNumberSInt64Type, &amp;style);</span><br><span class="line">    <span class="keyword">if</span> (style == <span class="built_in">NSUnderlineStyleNone</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2.获得画线的宽度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> lineWidth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((style &amp; <span class="built_in">NSUnderlineStyleThick</span>) == <span class="built_in">NSUnderlineStyleThick</span>)&#123;</span><br><span class="line">        lineWidth = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGContextSetLineWidth</span>(context, lineWidth);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.获取画线的起点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> firstP = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    size_t length = <span class="built_in">CTRunGetGlyphCount</span>(run);</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CGPoint</span> *firstGP = <span class="built_in">CTRunGetPositionsPtr</span>(run);</span><br><span class="line">    <span class="keyword">if</span> (!firstGP) &#123;</span><br><span class="line">        <span class="built_in">NSMutableData</span> *tempBuffer = [[<span class="built_in">NSMutableData</span> alloc] initWithLength:<span class="keyword">sizeof</span>(<span class="built_in">CGPoint</span>) * length];</span><br><span class="line">        <span class="built_in">CTRunGetPositions</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, length), (<span class="built_in">CGPoint</span> *)tempBuffer.mutableBytes);</span><br><span class="line">        firstGP = tempBuffer.mutableBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    firstP = *firstGP ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.开始画线</span></span><br><span class="line">    <span class="built_in">CGContextBeginPath</span>(context);</span><br><span class="line">    <span class="comment">//4.1 划线的颜色</span></span><br><span class="line">    <span class="built_in">CGColorRef</span> lineColor = (__bridge <span class="built_in">CGColorRef</span>)attributes[<span class="built_in">NSStrikethroughColorAttributeName</span>];</span><br><span class="line">    <span class="keyword">if</span>(lineColor == <span class="literal">nil</span>)&#123;</span><br><span class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, <span class="built_in">UIColor</span>.blueColor.CGColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(context, lineColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.2高度</span></span><br><span class="line">    <span class="built_in">UIFont</span>* font = attributes[<span class="built_in">NSFontAttributeName</span>];</span><br><span class="line">    <span class="keyword">if</span>(font == <span class="literal">nil</span>)&#123;</span><br><span class="line">        font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="built_in">UIFont</span>.systemFontSize];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CGFloat</span> lineHeight = font.xHeight / <span class="number">2.0</span> + firstP.y;</span><br><span class="line">    <span class="comment">//4.3多行处理</span></span><br><span class="line">    <span class="built_in">CGPoint</span> pt =  <span class="built_in">CGContextGetTextPosition</span>(context);</span><br><span class="line">    lineHeight += pt.y;</span><br><span class="line">    <span class="comment">//4.5 删除线的长度</span></span><br><span class="line">    <span class="keyword">float</span> w = <span class="built_in">CTRunGetTypographicBounds</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="literal">nil</span> , <span class="literal">nil</span>, <span class="literal">nil</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 画线</span></span><br><span class="line">    <span class="built_in">CGContextMoveToPoint</span>(context, pt.x + firstP.x, lineHeight);</span><br><span class="line">    <span class="built_in">CGContextAddLineToPoint</span>(context, pt.x + firstP.x + w, lineHeight);</span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/res/CoreText/CoreText二.png" alt></p>
<h4 id="实现自定义样式-矩形框标注"><a href="#实现自定义样式-矩形框标注" class="headerlink" title="实现自定义样式-矩形框标注"></a>实现自定义样式-矩形框标注</h4><blockquote>
<p>自定义一个<strong>TSRectColor</strong> 一个包住文字的矩形框，尝试去实现它。</p>
</blockquote>
<p><strong>一、</strong> 在 NSAttributedString 中添加自定义属性：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的矩形框</span></span><br><span class="line">[mAttStr addAttribute:<span class="string">@"TSRectColor"</span> value:[<span class="built_in">UIColor</span> yellowColor] range:<span class="built_in">NSMakeRange</span>(<span class="number">90</span>, <span class="number">18</span>)];</span><br></pre></td></tr></table></figure>
<p><strong>二、</strong> 修改一下上面的实现删除线的代码，添加实现矩形框。与实现删除线不一样的是，实现矩形框需要在<code>CTRunDraw</code>之前：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//7.3 使用CTRun绘制</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(frame);</span><br><span class="line"><span class="built_in">CFIndex</span> numOfLines =  <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    <span class="comment">//获取每一行的origin,CoreText的origin是在字形的baseLine处</span></span><br><span class="line"><span class="built_in">CGPoint</span> lineOrigins[<span class="built_in">CFArrayGetCount</span>(lines)];</span><br><span class="line"><span class="built_in">CTFrameGetLineOrigins</span>(frame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numOfLines; i++) &#123;</span><br><span class="line">    <span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines, i);</span><br><span class="line">        <span class="comment">//设置每一行的位置</span></span><br><span class="line">    <span class="built_in">CGContextSetTextPosition</span>(context, lineOrigins[i].x, lineOrigins[i].y);</span><br><span class="line">        <span class="comment">//开始每个run的绘制</span></span><br><span class="line">    <span class="built_in">CFArrayRef</span> runs = <span class="built_in">CTLineGetGlyphRuns</span>(line);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">CFArrayGetCount</span>(runs); j++) &#123;</span><br><span class="line">        <span class="built_in">CTRunRef</span> run = <span class="built_in">CFArrayGetValueAtIndex</span>(runs, j);</span><br><span class="line">        <span class="comment">//获取run的样式</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *runAttributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);</span><br><span class="line">        <span class="keyword">if</span>(runAttributes[<span class="string">@"TSRectColor"</span>])&#123;</span><br><span class="line">            <span class="comment">//绘制自定义矩形框 (需要放在CTRunDraw之前 否则绘制的颜色会挡住文字)</span></span><br><span class="line">            [<span class="keyword">self</span> drawRectColorInRun:run  attributes:runAttributes context:context];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CTRunDraw</span>(run, context, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//判断是否有指定的样式</span></span><br><span class="line">        <span class="keyword">if</span>(runAttributes[<span class="built_in">NSStrikethroughStyleAttributeName</span>] != <span class="literal">nil</span>)&#123;</span><br><span class="line">            <span class="comment">//绘制删除线</span></span><br><span class="line">            [<span class="keyword">self</span> drawStrikethroughStyleInRun:run attributes:runAttributes context:context];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三、</strong> 实现 <code>-drawRectColorInRun: attributes: context:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 绘制矩形框</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)drawRectColorInRun:(<span class="built_in">CTRunRef</span>)run attributes: (<span class="built_in">NSDictionary</span>*)attributes context:(<span class="built_in">CGContextRef</span>)context &#123;</span><br><span class="line">    <span class="comment">//1.判断属性是否存在啊</span></span><br><span class="line">    <span class="built_in">UIColor</span>* color = attributes[<span class="string">@"TSRectColor"</span>];</span><br><span class="line">    <span class="keyword">if</span>(!color)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//2.画线的起点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> firstPoint = [<span class="keyword">self</span> firstPointInRun:run];</span><br><span class="line">    <span class="comment">//3.获取run的宽度 ascent descent</span></span><br><span class="line">    <span class="built_in">CGFloat</span> ascent,descent;</span><br><span class="line">    <span class="keyword">double</span> typographicBounds = <span class="built_in">CTRunGetTypographicBounds</span>(run , <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> textP = <span class="built_in">CGContextGetTextPosition</span>(context);</span><br><span class="line">    <span class="comment">//4. 需要填充的区域</span></span><br><span class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(firstPoint.x + textP.x, textP.y + firstPoint.y - descent, typographicBounds, ascent + descent);</span><br><span class="line">    <span class="comment">//5. 开始填充颜色</span></span><br><span class="line">    <span class="built_in">CGContextSetStrokeColorWithColor</span>(context , color.CGColor);</span><br><span class="line">    <span class="built_in">CGContextAddRect</span>(context, rect);</span><br><span class="line">    <span class="built_in">CGContextStrokePath</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果：</p>
<p><img src="/res/CoreText/coreText三.png" alt></p>
<h3 id="添加超链接"><a href="#添加超链接" class="headerlink" title="添加超链接"></a>添加超链接</h3><blockquote>
<p>如何识别文字中的超链接 不同场景有不同的处理方式，这里就不处理了。</p>
</blockquote>
<blockquote>
<p>添加超链接 简单来讲就是重写touchesBegan方法 获取点击的点，再到<code>CTFrameRef</code>中比较</p>
</blockquote>
<p>重写touchesBegan方法 根据touch事件获取点point</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    <span class="built_in">UITouch</span>* touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    <span class="keyword">bool</span> ifClicked = [<span class="keyword">self</span> ifClickLink:point];</span><br><span class="line">    <span class="keyword">if</span> (ifClicked) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"点击了连接"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断touch点</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">bool</span>)ifClickLink:(<span class="built_in">CGPoint</span>)point&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectContainsPoint</span>(<span class="keyword">self</span>.bounds, point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//textFrame 通过CTFrameGetLineOrigins获取所有line的原点</span></span><br><span class="line">    <span class="built_in">CFArrayRef</span> lines = <span class="built_in">CTFrameGetLines</span>(<span class="keyword">self</span>.textFrame);</span><br><span class="line">    <span class="keyword">if</span>(!lines) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(lines);</span><br><span class="line">    <span class="built_in">CGPoint</span> origins[count];</span><br><span class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(<span class="keyword">self</span>.textFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), origins);</span><br><span class="line">    <span class="comment">//CoreText坐标系不同翻转一下</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformScale</span>(<span class="built_in">CGAffineTransformMakeTranslation</span>(<span class="number">0</span>, <span class="keyword">self</span>.bounds.size.height), <span class="number">1.</span>f, <span class="number">-1.</span>f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> linePoint = origins[i];</span><br><span class="line">        <span class="built_in">CTLineRef</span> line = <span class="built_in">CFArrayGetValueAtIndex</span>(lines , i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取CTLine的区域</span></span><br><span class="line">        <span class="built_in">CGFloat</span> ascent = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">CGFloat</span> descent = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">CGFloat</span> leading = <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">CGFloat</span> width = (<span class="built_in">CGFloat</span>)<span class="built_in">CTLineGetTypographicBounds</span>(line, &amp;ascent, &amp;descent, &amp;leading);</span><br><span class="line">        <span class="built_in">CGFloat</span> height = ascent + descent;</span><br><span class="line">        <span class="built_in">CGRect</span> flippedLineRect = <span class="built_in">CGRectMake</span>(linePoint.x, linePoint.y - descent, width, height);</span><br><span class="line">        <span class="built_in">CGRect</span> lineRect = <span class="built_in">CGRectApplyAffineTransform</span>(flippedLineRect, transform);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//比较point和line 获取点击处于哪个line</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(lineRect, point)) &#123;</span><br><span class="line">            <span class="comment">//line、point 通过CTLineGetStringIndexForPosition获取到点击字符在整段文字中的 index</span></span><br><span class="line">            <span class="built_in">CFIndex</span> idx = <span class="built_in">CTLineGetStringIndexForPosition</span>(line, point);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,idx);</span><br><span class="line">            <span class="comment">//判断点击的文字是否在链接文字区域</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> ifClickRangeContainIndex:idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就监测到了点击事件，并且知道点击了哪个字符。再做相关超链接的点击逻辑，就添加超链接功能成功了。</p>
<blockquote>
<p>以上代码都在 <a href="https://github.com/sunyanyan/TSCode/blob/master/CoreText/CoreText/TestView.m" target="_blank" rel="noopener">https://github.com/sunyanyan/TSCode/blob/master/CoreText/CoreText/TestView.m</a> </p>
</blockquote>
<h3 id="图文混排"><a href="#图文混排" class="headerlink" title="图文混排"></a>图文混排</h3><blockquote>
<p>CoreText是不直接支持绘制图片的，但是我们可以先在需要显示图片的地方用一个特殊的空白占位符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度，这样绘制文字的时候就会先把图片的位置留出来，再在drawRect方法里面用CGContextDrawImage绘制图片。</p>
</blockquote>
<p>在NSMutableString中添加空白字符为图片占位</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)addImageAttStr&#123;</span><br><span class="line">    <span class="comment">//图文混排部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CTRunDelegateCallbacks：一个用于保存指针的结构体，由CTRun delegate进行回调</span></span><br><span class="line">    <span class="built_in">CTRunDelegateCallbacks</span> callbacks;</span><br><span class="line">    memset(&amp;callbacks, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">CTRunDelegateCallbacks</span>));</span><br><span class="line">    callbacks.version = kCTRunDelegateVersion1;</span><br><span class="line">    callbacks.getAscent = ascentCallback;</span><br><span class="line">    callbacks.getDescent = descentCallback;</span><br><span class="line">    callbacks.getWidth = widthCallback;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 图片信息字典</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *imgInfoDic = @&#123;<span class="string">@"width"</span>:@<span class="number">100</span>,<span class="string">@"height"</span>:@<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置CTRun的代理</span></span><br><span class="line">    <span class="built_in">CTRunDelegateRef</span> delegate = <span class="built_in">CTRunDelegateCreate</span>(&amp;callbacks, (__bridge <span class="keyword">void</span> *)imgInfoDic);</span><br><span class="line">    <span class="comment">// 使用0xFFFC作为空白的占位符</span></span><br><span class="line">    <span class="keyword">unichar</span> objectReplacementChar = <span class="number">0xFFFC</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *content = [<span class="built_in">NSString</span> stringWithCharacters:&amp;objectReplacementChar length:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *space = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:content];</span><br><span class="line">    <span class="built_in">CFAttributedStringSetAttribute</span>((<span class="built_in">CFMutableAttributedStringRef</span>)space, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">1</span>), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">    <span class="built_in">CFRelease</span>(delegate);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.sampleAttStr insertAttributedString:space atIndex:<span class="number">50</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中用到的CTRun delegate回调</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> ascentCallback(<span class="keyword">void</span> *ref) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref objectForKey:<span class="string">@"height"</span>] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> descentCallback(<span class="keyword">void</span> *ref) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> widthCallback(<span class="keyword">void</span> *ref) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">NSNumber</span> *)[(__bridge <span class="built_in">NSDictionary</span> *)ref objectForKey:<span class="string">@"width"</span>] floatValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在CTFrameDraw之后用CGContextDrawImage绘制图片</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//8. 绘制图片</span></span><br><span class="line"><span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"one.png"</span>];</span><br><span class="line"><span class="built_in">CGContextDrawImage</span>(context, [<span class="keyword">self</span> calculateImagePositionInCTFrame:frame], image.CGImage);</span><br></pre></td></tr></table></figure>
<p>用到的calculateImagePositionInCTFrame方法:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGRect</span>)calculateImagePositionInCTFrame:(<span class="built_in">CTFrameRef</span>)ctFrame &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 获得CTLine数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *lines = (<span class="built_in">NSArray</span> *)<span class="built_in">CTFrameGetLines</span>(ctFrame);</span><br><span class="line">    <span class="built_in">NSInteger</span> lineCount = [lines count];</span><br><span class="line">    <span class="built_in">CGPoint</span> lineOrigins[lineCount];</span><br><span class="line">    <span class="built_in">CTFrameGetLineOrigins</span>(ctFrame, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), lineOrigins);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 遍历每个CTLine</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span> ; i &lt; lineCount; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CTLineRef</span> line = (__bridge <span class="built_in">CTLineRef</span>)lines[i];</span><br><span class="line">        <span class="built_in">NSArray</span> *runObjArray = (<span class="built_in">NSArray</span> *)<span class="built_in">CTLineGetGlyphRuns</span>(line);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 遍历每个CTLine中的CTRun</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> runObj <span class="keyword">in</span> runObjArray) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CTRunRef</span> run = (__bridge <span class="built_in">CTRunRef</span>)runObj;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *runAttributes = (<span class="built_in">NSDictionary</span> *)<span class="built_in">CTRunGetAttributes</span>(run);</span><br><span class="line">            <span class="built_in">CTRunDelegateRef</span> delegate = (__bridge <span class="built_in">CTRunDelegateRef</span>)[runAttributes valueForKey:(<span class="keyword">id</span>)kCTRunDelegateAttributeName];</span><br><span class="line">            <span class="keyword">if</span> (delegate == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSDictionary</span> *metaDic = <span class="built_in">CTRunDelegateGetRefCon</span>(delegate);</span><br><span class="line">            <span class="keyword">if</span> (![metaDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGRect</span> runBounds;</span><br><span class="line">            <span class="built_in">CGFloat</span> ascent;</span><br><span class="line">            <span class="built_in">CGFloat</span> descent;</span><br><span class="line">            </span><br><span class="line">            runBounds.size.width = <span class="built_in">CTRunGetTypographicBounds</span>(run, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="number">0</span>), &amp;ascent, &amp;descent, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds.size.height = ascent + descent;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGFloat</span> xOffset = <span class="built_in">CTLineGetOffsetForStringIndex</span>(line, <span class="built_in">CTRunGetStringRange</span>(run).location, <span class="literal">NULL</span>);</span><br><span class="line">            runBounds.origin.x = lineOrigins[i].x + xOffset;</span><br><span class="line">            runBounds.origin.y = lineOrigins[i].y;</span><br><span class="line">            runBounds.origin.y -= descent;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGPathRef</span> pathRef = <span class="built_in">CTFrameGetPath</span>(ctFrame);</span><br><span class="line">            <span class="built_in">CGRect</span> colRect = <span class="built_in">CGPathGetBoundingBox</span>(pathRef);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGRect</span> delegateBounds = <span class="built_in">CGRectOffset</span>(runBounds, colRect.origin.x, colRect.origin.y);</span><br><span class="line">            <span class="keyword">return</span> delegateBounds;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectZero</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如图:</p>
<p><img src="/res/CoreText/coreTextImage.png" alt></p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD相关.md</title>
    <url>/essay/GCD/</url>
    <content><![CDATA[<blockquote>
<p>OS X 10.8或iOS 6以及之后版本中使用，Dispatch Queue将会由ARC自动管理,不需要手动释放</p>
</blockquote>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>分为串行队列和并发队列<br><a id="more"></a></p>
</blockquote>
<ul>
<li>将多个任务提交给串行队列，多个任务只能按顺序执行，前一个任务执行完，才能开始下一个任务</li>
<li>将多个任务交给并发队列，并发队列可以按FIFO的顺序启动多个任务，任务完成顺序按任务和系统决定</li>
</ul>
<blockquote>
<p>获取队列：</p>
</blockquote>
<ul>
<li>dispatch_get_main_queue() <ul>
<li>获取主线程关联串行队列</li>
</ul>
</li>
<li>dispatch_get_current_queue()<ul>
<li>获取当前执行代码所在队列</li>
</ul>
</li>
<li>dispatch_get_global_queue(long identifier, unsigned long flags)<ul>
<li>获取系统的全局并发队列</li>
<li>第一个参数接受一下四个优先级<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH:         </li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT:       </li>
<li>DISPATCH_QUEUE_PRIORITY_LOW:           </li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND: </li>
</ul>
</li>
<li>第二个参数一般传入0</li>
</ul>
</li>
</ul>
<blockquote>
<p>创建队列：</p>
</blockquote>
<ul>
<li>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)<ul>
<li>第一个参数表示队列对应字符串标签</li>
<li>第二个参数指定队列类型，分为：<ul>
<li>DISPATCH_QUEUE_SERIAL  串行</li>
<li>DISPATCH_QUEUE_CONCURRENT 并发    </li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>获取队列相关信息</p>
</blockquote>
<ul>
<li>dispatch_queue_get_label(dispatch_queue_t queue);<ul>
<li>获取队列对应的标签 </li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><ul>
<li>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);<ul>
<li>将代码块以异步方式提交给指定队列</li>
</ul>
</li>
<li>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);<ul>
<li>将代码块以同步方式提交给指定队列</li>
<li><strong>先后提交的两个代码块（即使提交给并发队列），前一个执行完才会执行下一个</strong></li>
</ul>
</li>
<li>dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);<ul>
<li>将代码块以异步方式提交给指定队列,并在dispatch_time指定的时间开始执行</li>
</ul>
</li>
<li>dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));<ul>
<li>将代码块以异步方式提交给指定队列,重复执行代码</li>
<li>第一个参数指定重复几次</li>
<li>第三个参数 block代码块的 size_t表示当前正在执行第几次</li>
</ul>
</li>
<li>dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);<ul>
<li>在任务提交给队列，在应用的某个生命周期内只执行一次</li>
<li>第一个参数表示代码块是否已经执行过</li>
</ul>
</li>
</ul>
<h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p><code>dispatch_block_cancel</code>。 iOS8之后可以调用dispatch_block_cancel来取消（需要注意必须用dispatch_block_create创建dispatch_block_t）<br>代码示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)gcdBlockCancel&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.gcdtest.www"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block1 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block1 %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block2 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block2 %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t block3 = dispatch_block_create(<span class="number">0</span>, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block3 %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block1);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, block2);</span><br><span class="line">    dispatch_block_cancel(block3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h2><ul>
<li><p>void dispatch_group_notify(dispatch_group_t group,<br>  dispatch_queue_t queue,<br>  dispatch_block_t block); </p>
<ul>
<li>group中所有代码块执行完之后执行    </li>
</ul>
</li>
<li><p>long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);</p>
<ul>
<li>返回值表示经过指定的等待时间，属于这个group的任务是否已经全部执行完，如果是则返回0，否则返回非0。 </li>
<li>第一个参数表示等待的group </li>
<li>第二个参数则表示等待时间，有两个特殊值<ul>
<li>DISPATCH_TIME_NOW 表示立刻检查属于这个group的任务是否已经完成</li>
<li>DISPATCH_TIME_FOREVER 表示一直等到属于这个group的任务全部完成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>)</span><br><span class="line">let group = dispatch_group_create()</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_notify(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"completed"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的顺序与添加进队列的顺序无关，因为队列是Concurrent Dispatch Queue，但“completed”的输出一定是在最后的    </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>)</span><br><span class="line">let group = dispatch_group_create()</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"1"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br><span class="line">dispatch_group_async(group, globalQueue) &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   println(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用dispatch_group_wait函数</span></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER)</span><br><span class="line">println(<span class="string">"completed"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="暂停和恢复"><a href="#暂停和恢复" class="headerlink" title="暂停和恢复"></a>暂停和恢复</h3><blockquote>
<p>这些函数不会影响到队列中已经执行的任务，队列暂停后，已经添加到队列中但还没有执行的任务不会执行，直到队列被恢复</p>
</blockquote>
<ul>
<li>dispatch_suspend(queue) //暂停某个队列  </li>
<li>dispatch_resume(queue)  //恢复某个队列    </li>
</ul>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch barrier async"></a>dispatch barrier async</h2><p>我们知道数据在写入时，不能在其他线程读取或写入。但是多个线程同时读取数据是没有问题的。所以我们可以把读取任务放入并行队列，把写入任务放入串行队列，并且保证写入任务执行过程中没有读取任务可以执行。</p>
<p>这样的需求比较常见，GCD提供了一个非常简单的解决办法——dispatch_barrier_async</p>
<p>假设我们有四个读取任务，在第二三个任务之间有一个写入任务，代码大概是这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let queue = dispatch_queue_create(<span class="string">"com.gcd.kt"</span>, DISPATCH_QUEUE_CONCURRENT)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block1_for_reading)  </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block2_for_reading)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   	这里插入写入任务，比如：</span></span><br><span class="line"><span class="comment">   	dispatch_async(queue, block_for_writing)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block3_for_reading)  </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block4_for_reading)</span><br></pre></td></tr></table></figure>
<p>如果代码这样写，由于这几个block是并发执行，就有可能在前两个block中读取到已经修改了的数据。如果是有多写入任务，那问题更严重，可能会有数据竞争。</p>
<p>如果使用dispatch_barrier_async函数，代码就可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue, block1_for_reading)  </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block2_for_reading)</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, block_for_writing)</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block3_for_reading)  </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, block4_for_reading)</span><br></pre></td></tr></table></figure>
<p>dispatch_barrier_async会把并行队列的运行周期分为这三个过程：</p>
<ol>
<li>首先等目前追加到并行队列中所有任务都执行完成</li>
<li>开始执行dispatch_barrier_async中的任务，这时候即使向并行队列提交任务，也不会执行</li>
<li>dispatch_barrier_async中的任务执行完成后，并行队列恢复正常。</li>
</ol>
<p>总的来说，dispatch_barrier_async起到了“承上启下”的作用。它保证此前的任务都先于自己执行，此后的任务也迟于自己执行。正如barrier的含义一样，它起到了一个栅栏、或是分水岭的作用。</p>
<p>这样一来，使用并行队列和dispatc_barrier_async方法，就可以高效的进行数据和文件读写了。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>dispatch_semaphore</strong></p>
<p>首先介绍一下信号量(semaphore)的概念。信号量是持有计数的信号，不过这么解释等于没解释。我们举个生活中的例子来看看。</p>
<p>假设有一个房子，它对应进程的概念，房子里的人就对应着线程。一个进程可以包括多个线程。这个房子(进程)有很多资源，比如花园、客厅等，是所有人(线程)共享的。</p>
<p>但是有些地方，比如卧室，最多只有两个人能进去睡觉。怎么办呢，在卧室门口挂上两把钥匙。进去的人(线程)拿着钥匙进去，没有钥匙就不能进去，出来的时候把钥匙放回门口。</p>
<p>这时候，门口的钥匙数量就称为信号量(Semaphore)。很明显，信号量为0时需要等待，信号量不为零时，减去1而且不等待。</p>
<p>dispatch_semaphore 与他相关的共有三个函数，分别是</p>
<ul>
<li>dispatch_semaphore_create，</li>
<li>dispatch_semaphore_signal，</li>
<li>dispatch_semaphore_wait。</li>
</ul>
<p>下面我们逐一介绍三个函数：</p>
<blockquote>
<p>dispatch_semaphore_create的声明为：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">　　dispatch_semaphore_t  dispatch_semaphore_create(<span class="keyword">long</span> value);</span><br></pre></td></tr></table></figure>
<p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。</p>
<p>值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p>
<blockquote>
<p>dispatch_semaphore_signal的声明为：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">long</span> dispatch_semaphore_signal(dispatch_semaphore_t dsema)</span><br></pre></td></tr></table></figure>
<p>  这个函数会使传入的信号量dsema的值加1； </p>
<blockquote>
<p>dispatch_semaphore_wait的声明为：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">　　<span class="keyword">long</span> dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</span><br></pre></td></tr></table></figure>
<p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；</p>
<p>如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。</p>
<p>如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p>
<p>　　</p>
<blockquote>
<p>返回值</p>
</blockquote>
<p>dispatch_semaphore_signal的返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。</p>
<p>dispatch_semaphore_wait的返回值也为long型。当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。当其返回不为0时，表示timeout发生。</p>
<blockquote>
<p>设置timeout时，</p>
</blockquote>
<p>比较有用的两个宏：</p>
<ul>
<li>DISPATCH_TIME_NOW　　表示当前；</li>
<li>DISPATCH_TIME_FOREVER　　表示遥远的未来；</li>
</ul>
<p>一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。</p>
<blockquote>
<p>dispatch_time的声明如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">　　dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)；</span><br></pre></td></tr></table></figure>
<p>创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。</p>
<p>例如：dispatch_time_t  t = dispatch_time(DISPATCH_TIME_NOW, 1<em>1000</em>1000*1000);表示当前时间向后延时一秒为timeout的时间。</p>
<p>我们来看一个完整的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var semaphore = dispatch_semaphore_create(<span class="number">1</span>)  </span><br><span class="line">let queue = dispatch_queue_create(<span class="string">"com.gcd.kt"</span>, DISPATCH_QUEUE_CONCURRENT)  </span><br><span class="line">var array: [Int] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1.</span>.<span class="number">.100000</span> &#123;  </span><br><span class="line">	<span class="built_in">dispatch_async</span>(queue, &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           某个线程执行到这里，如果信号量值为1，那么wait方法返回1，开始执行接下来的操作。</span></span><br><span class="line"><span class="comment">           与此同时，因为信号量变为0，其它执行到这里的线程都必须等待</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           执行了wait方法后，信号量的值变成了0。可以进行接下来的操作。</span></span><br><span class="line"><span class="comment">           这时候其它线程都得等待wait方法返回。</span></span><br><span class="line"><span class="comment">           可以对array修改的线程在任意时刻都只有一个，可以安全的修改array</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       array.append(i)</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           排他操作执行结束，记得要调用signal方法，把信号量的值加1。</span></span><br><span class="line"><span class="comment">           这样，如果有别的线程在等待wait函数返回，就由最先等待的线程执行。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       dispatch_semaphore_signal(semaphore)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置时间间隔 1秒</span></span><br><span class="line">uint64_t interval = <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line"><span class="comment">//开启一个专门执行timer的GCD回调队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"myqueue"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//创建timer</span></span><br><span class="line">dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"><span class="comment">//配置timer 最后一个参数表示精准度， 0为最精准</span></span><br><span class="line">dispatch_source_set_timer(_timer, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>), interval, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置回调</span></span><br><span class="line">__block <span class="keyword">int</span> timeCount = <span class="number">0</span>;</span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">    DLog(<span class="string">@"计时开始"</span>);</span><br><span class="line">    timeCount ++;</span><br><span class="line">    <span class="keyword">if</span>(timeCount &gt;= <span class="number">6</span>)&#123;</span><br><span class="line">        DLog(<span class="string">@" da "</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(timeCount &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">    	<span class="comment">//结束计时</span></span><br><span class="line">        dispatch_source_cancel(_timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_source默认为suspend状态，需要手动resume</span></span><br><span class="line">dispatch_resume(_timer);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NSOperation-简介.md</title>
    <url>/essay/NSOperation-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>NSOperation-简介</p>
</blockquote>
<a id="more"></a>
<h2 id="常用子类："><a href="#常用子类：" class="headerlink" title="常用子类："></a>常用子类：</h2><blockquote>
<p>NSOperation是一个基类，不应该直接生成NSOperation对象，而是应该用它的子类。</p>
</blockquote>
<ul>
<li>NSInvocationOperation<ul>
<li>将特定对象的特定方法封装成NSOperation</li>
</ul>
</li>
<li>NSBlockOperation<ul>
<li>将代码块封装成NSOpreation</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例：</p>
</blockquote>
<p>创建NSInvocationOperation</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSString</span>* url = <span class="string">@"http://www.xxx.com"</span>;</span><br><span class="line"><span class="comment">//以self的downloadImageFromURL:方法作为执行体，创建NSOperation</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span>* operation = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(downloadImageFromURL:) object:url];</span><br></pre></td></tr></table></figure>
<p>创建NSBlockOperation</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSBlockOperation</span>* operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	<span class="comment">//执行体</span></span><br><span class="line">	...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="常用状态："><a href="#常用状态：" class="headerlink" title="常用状态："></a>常用状态：</h2><blockquote>
<p>可以通过KVO监听NSOperation的状态</p>
</blockquote>
<ul>
<li>isCancelled </li>
<li>isAsynchronous </li>
<li>isExecuting  </li>
<li>isFinished  </li>
<li>isReady  </li>
</ul>
<h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><blockquote>
<p>创建了一个NSBlockOperation，并且设置好它的block，也就是将要执行的任务。这个任务会在主线程中执行。</p>
</blockquote>
<blockquote>
<p>调用start方法让NSOperation方法运行起来。start是一个同步方法。</p>
</blockquote>
<blockquote>
<p>在当前任务状态和依赖关系合适的情况下，启动NSOperation的main方法任务，需要注意缺省实现只是在当前线程运行。如果需要并发执行，子类必须重写这个方法，并且使 - (BOOL)isConcurrent 方法返回YES</p>
</blockquote>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">let operation = <span class="built_in">NSBlockOperation</span> &#123; () -&gt; Void <span class="keyword">in</span>  </span><br><span class="line">   	print(<span class="built_in">NSThread</span>.currentThread())</span><br><span class="line">&#125;</span><br><span class="line">operation.addExecutionBlock &#123; () -&gt; Void <span class="keyword">in</span>  </span><br><span class="line">   	print(<span class="string">"execution block1 --(NSThread.currentThread())"</span>)</span><br><span class="line">&#125;</span><br><span class="line">operation.start()</span><br></pre></td></tr></table></figure>
</code></pre><p> 默认的NSOperation是同步执行的。简单的看一下NSOperation类的定义会发现它有一个只读属性asynchronous</p>
<p> 这意味着如果想要异步执行，就需要自定义NSOperation的子类。或者使用NSOperationQueue</p>
<h2 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h2><blockquote>
<p>如果我们有两次网络请求，第二次请求会用到第一次的数据。如果此时网络情况不好，第一次请求超时了，那么第二次请求也没有必要发送了。当然，用户也有可能人为地取消某个NSOperation。</p>
</blockquote>
<blockquote>
<p>当某个NSOperation被取消时，我们应该尽可能的清除NSOperation内部的数据并且把cancelled和finished设为true，把executing设为false。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//取消某个NSOperation</span></span><br><span class="line">operation1.cancel()</span><br><span class="line"> </span><br><span class="line"><span class="comment">//取消某个NSOperationQueue剩余的NSOperation</span></span><br><span class="line">queue.cencelAllOperations()</span><br></pre></td></tr></table></figure>
<h2 id="获取状态"><a href="#获取状态" class="headerlink" title="获取状态"></a>获取状态</h2><ul>
<li>@property(readonly, getter=isCancelled) BOOL cancelled<ul>
<li>当前任务状态是否已标记为取消  </li>
</ul>
</li>
<li>@property(readonly, getter=isExecuting) BOOL executing<ul>
<li>当前任务状态是否已标记为取消 </li>
</ul>
</li>
<li>@property(readonly, getter=isFinished) BOOL finished<ul>
<li>NSOperation任务是否已结束 </li>
</ul>
</li>
<li>@property(readonly, getter=isConcurrent) BOOL concurrent</li>
<li>@property(readonly, getter=isAsynchronous) BOOL asynchronous</li>
<li>@property(readonly, getter=isReady) BOOL ready<ul>
<li>NSOperation任务是否已结束 </li>
</ul>
</li>
<li>@property(copy) NSString *name</li>
</ul>
<h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><ul>
<li><p>-(void)waitUntilFinished</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="built_in">NSBlockOperation</span> *opB = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">	[opA waitUntilFinished]; <span class="comment">//opB线程等待直到opA执行结束（正常结束或被取消）</span></span><br><span class="line">      	[<span class="keyword">self</span> operate];</span><br><span class="line">  	&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="设置依赖"><a href="#设置依赖" class="headerlink" title="设置依赖"></a>设置依赖</h2><blockquote>
<p>依然考虑刚刚所说的两次网络请求的例子。因为第二次请求会用到第一次的数据，所以我们要保证发出第二次请求的时候第一个请求已经执行完。但是我们同时还希望利用到NSOperationQueue的并发特性（因为可能不止这两个任务）。</p>
</blockquote>
<blockquote>
<p>这时候我们可以设置NSOperation之间的依赖关系。语法非常简洁：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">operation2.addDependency(operation1)</span><br></pre></td></tr></table></figure>
<p>需要注意的是NSOperation之间的相互依赖会导致死锁</p>
<p>移除依赖：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDependency:(<span class="built_in">NSOperation</span> *)operation</span><br></pre></td></tr></table></figure>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><blockquote>
<p>GCD中，任务（block）是没有优先级的，而队列具有优先级。和GCD相反，我们一般考虑NSOperation的优先级</p>
</blockquote>
<blockquote>
<p>NSOperation有一个NSOperationQueuePriority枚举类型的属性queuePriority</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSInteger</span> &#123;</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryLow</span> = <span class="number">-8</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityLow</span> = <span class="number">-4</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125; <span class="built_in">NSOperationQueuePriority</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果NSInvocationOperation和NSBlockOperation对象不能满足需求, 我们可以直接继承NSOperation, 并添加额外的功能。</p>
<p>继承所需的工作量主要取决于你要实现非并发还是并发的NSOperation。定义同步的NSOperation要简单许多,只需要重载-main这个方法，在这个方法里面执行主任务,并正确地响应取消事件; 对于异步NSOperation, 必须重写NSOperation的多个基本方法进行实现（main、start）。</p>
</blockquote>
<!--more-->
<h2 id="自定义非并发NSOperation"><a href="#自定义非并发NSOperation" class="headerlink" title="自定义非并发NSOperation"></a>自定义非并发NSOperation</h2><ol>
<li>重写NSOperation的<code>main</code>方法,该方法会作为NSOperation所启动线程的执行体<ul>
<li>在 operation 的 main 方法里面,必须提供 autorelease pool,因为你的 operation 完成后需要销毁。</li>
</ul>
</li>
<li>实现KVO机制，一旦你的 operation 开始了,必须通过 KVO,告诉所有的监听者,现在该operation的执行状态。（即修改isFinished，isExecuting的值）</li>
<li>重载 isExecuting方法和isFinished方法。在这两个方法中,必须返回一个线程安全值（通常是个BOOL值）,这个值可以在 operation 中进行操作。</li>
</ol>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><blockquote>
<p>.h文件：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^HYBDownloadReponse)(<span class="built_in">UIImage</span> *image);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *url;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HYBDownloadReponse responseBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUrl:(<span class="built_in">NSString</span> *)url completion:(HYBDownloadReponse)completion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>.m文件：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DownloadOperation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperation</span> () </span>&#123;</span><br><span class="line">   <span class="built_in">BOOL</span> _isFinished;</span><br><span class="line">   <span class="built_in">BOOL</span> _isExecuting;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DownloadOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUrl:(<span class="built_in">NSString</span> *)url completion:(HYBDownloadReponse)completion &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="keyword">self</span>.url = url;</span><br><span class="line">       <span class="keyword">self</span>.responseBlock = completion;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重写这个主方法</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">   <span class="comment">// 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池</span></span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       <span class="comment">// 提供一个变量标识，来表示我们需要执行的操作是否完成了，当然，没开始执行之前，为NO</span></span><br><span class="line">       <span class="built_in">BOOL</span> taskIsFinished = <span class="literal">NO</span>;</span><br><span class="line">       <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// while 保证：只有当没有执行完成和没有被取消，才执行我们自定义的相应操作</span></span><br><span class="line">       <span class="keyword">while</span> (taskIsFinished == <span class="literal">NO</span> &amp;&amp; [<span class="keyword">self</span> isCancelled] == <span class="literal">NO</span>)&#123;</span><br><span class="line">           <span class="comment">// 获取图片数据</span></span><br><span class="line">           <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.url];</span><br><span class="line">           <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">           image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"Current Thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 这里，设置我们相应的操作都已经完成，后面就是要通知KVO我们的操作完成了。</span></span><br><span class="line">           </span><br><span class="line">           taskIsFinished = <span class="literal">YES</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// KVO 生成通知，告诉其他线程，该operation 执行完了</span></span><br><span class="line">       [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">       [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">       _isFinished = <span class="literal">YES</span>;</span><br><span class="line">       _isExecuting = <span class="literal">NO</span>;</span><br><span class="line">       [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">       [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span>.responseBlock) &#123;</span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="keyword">self</span>.responseBlock(image);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">   <span class="comment">// 如果我们取消了在开始之前，我们就立即返回并生成所需的KVO通知</span></span><br><span class="line">   <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled])&#123;</span><br><span class="line">       <span class="comment">// 我们取消了该 operation，那么就要告诉KVO，该operation已经执行完成（isFinished）</span></span><br><span class="line">       <span class="comment">// 这样，调用的队列（或者线程）会继续执行。</span></span><br><span class="line">       [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">       _isFinished = <span class="literal">NO</span>;</span><br><span class="line">       [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isFinished"</span>];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 没有取消，那就要告诉KVO，该队列开始执行了（isExecuting）！那么，就会调用main方法，进行同步执行。</span></span><br><span class="line">       [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">       _isExecuting = <span class="literal">YES</span>;</span><br><span class="line">       [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(main) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">       [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@"isExecuting"</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">   <span class="keyword">return</span> _isExecuting;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">   <span class="keyword">return</span> _isFinished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><blockquote>
<p>queue方式：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DownloadOperation *operation = [[DownloadOperation alloc] initWithUrl:<span class="string">@"https://mmbiz.qlogo.cn/mmbiz/sia5QxFVcFD0wkCgnmf6DVxI6fVewNS8rhtZb71v2DMpDy8jIdtviaetzicwQzTEoKKyHAN96Beibk2G61tZpezQ0Q/0?wx_fmt=png"</span> completion:^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">   <span class="comment">//    self.imageView.image = image;</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">DownloadOperation *operation1 = [[DownloadOperation alloc] initWithUrl:<span class="string">@"https://mmbiz.qlogo.cn/mmbiz/sia5QxFVcFD0wkCgnmf6DVxI6fVewNS8rhtZb71v2DMpDy8jIdtviaetzicwQzTEoKKyHAN96Beibk2G61tZpezQ0Q/0?wx_fmt=png"</span> completion:^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">   <span class="comment">//    self.imageView1.image = image;</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">[queue addOperation:operation];</span><br><span class="line">[queue addOperation:operation1];</span><br><span class="line">[queue setMaxConcurrentOperationCount:<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>手动方式：</p>
</blockquote>
<pre><code>DownloadOperation *operation = [[DownloadOperation alloc] initWithUrl:@&quot;https://mmbiz.qlogo.cn/mmbiz/sia5QxFVcFD0wkCgnmf6DVxI6fVewNS8rhtZb71v2DMpDy8jIdtviaetzicwQzTEoKKyHAN96Beibk2G61tZpezQ0Q/0?wx_fmt=png&quot; completion:^(UIImage *image) {
//    self.imageView.image = image;
}];
[operation start];        
</code></pre><h2 id="自定义并发NSOperation"><a href="#自定义并发NSOperation" class="headerlink" title="自定义并发NSOperation"></a>自定义并发NSOperation</h2><ol>
<li>和同步一样需要 重写mian start</li>
<li>和同步一样需要 使用KVO通知状态改变</li>
<li>和同步一样需要 重写isExecuting isFinishing</li>
<li>比同步多的是 重写isAsynchronous（或者isConcurrent）</li>
</ol>
<h3 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DownloadOperation.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DownloadOperation</span> () </span>&#123;</span><br><span class="line"><span class="keyword">@private</span> <span class="built_in">BOOL</span> _isFinished;</span><br><span class="line"><span class="keyword">@private</span> <span class="built_in">BOOL</span> _isExecuting;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DownloadOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUrl:(<span class="built_in">NSString</span> *)url completion:(HYBDownloadReponse)completion &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="keyword">self</span>.url = url;</span><br><span class="line">       <span class="keyword">self</span>.responseBlock = completion;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须重写这个主方法</span></span><br><span class="line">- (<span class="keyword">void</span>)main &#123;</span><br><span class="line">   <span class="comment">// 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池</span></span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">       <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">           <span class="comment">// 获取图片数据</span></span><br><span class="line">           <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="keyword">self</span>.url];</span><br><span class="line">           <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">           image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"currentThread: %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 被取消，也可能发生在转换的地方</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">           image = <span class="literal">nil</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled] &amp;&amp; <span class="keyword">self</span>.responseBlock) &#123;</span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="keyword">self</span>.responseBlock(image);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与自定义同步NSOperation不同的是，必须要实现下面的方法</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED <span class="meta-string">&lt; __IPHONE_7_0</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">- (BOOL)isConcurrent &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">   return YES;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#else</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">- (BOOL)isAsynchronous &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">   return YES;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#endif</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">@end</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于非主队列来说，一旦一个NSOperation被放入其中，那这个NSOperation一定是并发执行的。 NSOperationQueue会为每一个NSOperation创建线程并调用它的start方法。 </p>
</blockquote>
<!--more-->
<h2 id="KVO键值观察"><a href="#KVO键值观察" class="headerlink" title="KVO键值观察"></a>KVO键值观察</h2><ul>
<li>operations - read-only</li>
<li>operationCount - read-only</li>
<li>maxConcurrentOperationCount - readable and writable</li>
<li>suspended - readable and writable</li>
<li>name - readable and writable</li>
</ul>
<h2 id="获取特殊NSOperationQueue"><a href="#获取特殊NSOperationQueue" class="headerlink" title="获取特殊NSOperationQueue"></a>获取特殊NSOperationQueue</h2><ul>
<li>+(NSOperationQueue *)currentQueue<ul>
<li>返回当前NSOperationQueue，如果当前线程不是在NSOperationQueue上运行则返回nil </li>
</ul>
</li>
<li>+(NSOperationQueue *)mainQueue<ul>
<li>返回主线程的NSOperationQueue</li>
</ul>
</li>
</ul>
<h2 id="管理队列中的Operation"><a href="#管理队列中的Operation" class="headerlink" title="管理队列中的Operation"></a>管理队列中的Operation</h2><ul>
<li>-(void)addOperation:(NSOperation *)operation    <ul>
<li>加入到执行队列中，如果isReady则开始执行 </li>
</ul>
</li>
<li>-(void)addOperations:(NSArray<nsoperation *> *)ops waitUntilFinished:(BOOL)wait<ul>
<li>批量加入执行operation，wait标志是否当前线程等到所有operation结束 </li>
</ul>
</nsoperation></li>
<li>-(void)addOperationWithBlock:(void (^)(void))block<ul>
<li>相当于加入一个NSBlockOperation执行任务 </li>
</ul>
</li>
<li>-(void)cancelAllOperations<ul>
<li>相当于加入一个NSBlockOperation执行任务 </li>
</ul>
</li>
<li>-(void)waitUntilAllOperationsAreFinished<ul>
<li>当前线程等待，直到所有operation都执行结束 </li>
</ul>
</li>
<li>@property(readonly, copy) NSArray &lt;__kindof NSOperation <em>&gt; </em>operations<ul>
<li>返回已加入执行operation的数组，当某个operation结束后会自动从这个数组清除 </li>
</ul>
</li>
<li>@property(readonly) NSUInteger operationCount<ul>
<li>返回已加入执行operation的数目 </li>
</ul>
</li>
<li>@property NSInteger maxConcurrentOperationCount<ul>
<li>设置最大并发执行数，如果为1则同时只有一个并发任务在运行，可控制顺序执行关系</li>
</ul>
</li>
<li><p>@property(getter=isSuspended) BOOL suspended</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">queue.suspended = <span class="literal">true</span> <span class="comment">//暂停queue中所有operation  </span></span><br><span class="line">queue.suspended = <span class="literal">false</span> <span class="comment">//恢复queue中所有operation</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let operationQueue = <span class="built_in">NSOperationQueue</span>()  </span><br><span class="line">let operation = <span class="built_in">NSBlockOperation</span> &#123; () -&gt; Void <span class="keyword">in</span>  </span><br><span class="line">   	print(<span class="built_in">NSThread</span>.currentThread())</span><br><span class="line">&#125;</span><br><span class="line">   operation.addExecutionBlock &#123; () -&gt; Void <span class="keyword">in</span></span><br><span class="line">   	print(<span class="string">"execution block1 -- (NSThread.currentThread())"</span>)</span><br><span class="line">&#125;</span><br><span class="line">operationQueue.addOperation(operation)  </span><br><span class="line">print(<span class="string">"操作结束"</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>NSRunloop简介.md</title>
    <url>/essay/NSRunloop%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>NSRunLoop是IOS消息机制的处理模式</p>
</blockquote>
<ul>
<li>NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</li>
<li>NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)同步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。</li>
</ul>
<a id="more"></a>
<h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><ol>
<li>NSRunloop类用来处理类似键盘鼠标之类的输入源，NSPort对象或者NSConnection对象。同时也可以处理NSTimer对象。</li>
<li>不能创建和显示管理NSRunloop对象。主线程内的NSThread都已经自动创建了NSRunloop对象。</li>
<li>通过 <code>[NSRunloop currentRunLoop]</code> 获得当前线程的NSRunloop对象。</li>
<li>NSTimer对象使用 fire 方法时不会创建NSRunloop对象。</li>
<li><p>NSTimer当使用scheduled 初始化时会把timer以默认模式添加到当前NSRunloop中，而当使用timer方法初始化时，需要自己手动将timer添加到NSRunloop中。</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop]addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">如果不启动run loop，timer的事件是不会响应的</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSRunloop不是线程安全的。</p>
</li>
</ol>
<h2 id="runloop和线程有什么关系"><a href="#runloop和线程有什么关系" class="headerlink" title="runloop和线程有什么关系"></a>runloop和线程有什么关系</h2><p>Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。</p>
<p>###runloop 和线程的关系：</p>
<p>主线程的run loop默认是启动的。</p>
<p>iOS的应用程序里面，程序启动后会有一个如下的main()函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, 			<span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p> 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</p>
<p> 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="http://blog.csdn.net/wzzvictory/article/details/9237973" target="_blank" rel="noopener">《Objective-C之run loop详解》</a>。</p>
<h2 id="runloop的mode作用是什么？"><a href="#runloop的mode作用是什么？" class="headerlink" title="runloop的mode作用是什么？"></a>runloop的mode作用是什么？</h2><p>model 主要是用来指定事件在运行循环中的优先级的，分为：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li>
</ul>
<p>苹果公开提供的 Mode 有两个：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes） </li>
</ul>
<h2 id="以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#以-scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h2><p>RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。</p>
<p>如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>
<p>同时因为mode还是可定制的，所以：</p>
<p>Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将timer添加到NSDefaultRunLoopMode中</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">    target:<span class="keyword">self</span></span><br><span class="line">    selector:<span class="keyword">@selector</span>(timerTick:)</span><br><span class="line">    userInfo:<span class="literal">nil</span></span><br><span class="line">    repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//然后再添加到NSRunLoopCommonModes里</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span></span><br><span class="line">    target:<span class="keyword">self</span></span><br><span class="line">    selector:<span class="keyword">@selector</span>(timerTick:)</span><br><span class="line">    userInfo:<span class="literal">nil</span></span><br><span class="line">    repeats:<span class="literal">YES</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>参考链接 <a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">深入理解RunLoop</a></p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>RN中布局样式的写法</title>
    <url>/essay/RN%E4%B8%AD%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>介绍原始写法 &amp; 及其改进写法一</p>
<p>还有比较流行的 styled-components在RN中的使用 &amp; 及其改进写法二</p>
</blockquote>
<h3 id="1-原写法"><a href="#1-原写法" class="headerlink" title="1.原写法"></a>1.原写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> styles1 = StyleSheet.create(&#123;</span><br><span class="line">    item1:&#123;</span><br><span class="line">        width:<span class="number">100</span>,</span><br><span class="line">        height:<span class="number">200</span>,</span><br><span class="line">        backgroundColor:<span class="string">'#66CCFF'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    item2:&#123;</span><br><span class="line">        width:<span class="number">100</span>,</span><br><span class="line">        height:<span class="number">200</span>,</span><br><span class="line">        backgroundColor:<span class="string">'#66CCFF'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    item3:&#123;</span><br><span class="line">        width:<span class="number">50</span>,</span><br><span class="line">        height:<span class="number">100</span>,</span><br><span class="line">        top:<span class="number">50</span>,</span><br><span class="line">        left:<span class="number">25</span>,</span><br><span class="line">        backgroundColor:<span class="string">'#66CCFF'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'styles1 :'</span>,styles1);</span><br></pre></td></tr></table></figure>
<p>原写法的缺点在于变量不好引入，不好体现样式间的关系，没有计算表达式等……</p>
<a id="more"></a>
<h3 id="2-改进写法一"><a href="#2-改进写法一" class="headerlink" title="2.改进写法一"></a>2.改进写法一</h3><p>看StyleSheet.create的代码，就是直接返回一个对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在react native 0.44版本中</span></span><br><span class="line"><span class="keyword">var</span> StyleSheet = &#123;</span><br><span class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">styles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> styles;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>那就可以不限于StyleSheet.create的写法，可以比较自由的返回一个对象了，下面给出一个我的简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 换一种写法，简单引入了变量表达式</span></span><br><span class="line"><span class="comment"> * 虽然还是没有像iOS中 view.center / autolayout之类的写法方便</span></span><br><span class="line"><span class="comment"> * @returns &#123;&#123;&#125;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">styles2Creator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> itemWidth = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">let</span> itemHeight = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//引用常量</span></span><br><span class="line">    s.item1 = &#123;</span><br><span class="line">        width:itemWidth,</span><br><span class="line">        height:itemHeight,</span><br><span class="line">        backgroundColor:<span class="string">'#66CCFF'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//引用其他样式的值</span></span><br><span class="line">    s.item2 = &#123;</span><br><span class="line">        width:s.item1.width,</span><br><span class="line">        height:itemHeight,</span><br><span class="line">        backgroundColor:<span class="string">`<span class="subst">$&#123;s.item1.backgroundColor&#125;</span>`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">//计算表达式 </span></span><br><span class="line">    s.item3 = &#123;</span><br><span class="line">        width: s.item2.width / <span class="number">2</span>,</span><br><span class="line">        height: s.item2.height / <span class="number">2</span>,</span><br><span class="line">        top:s.item2.height / <span class="number">4</span>,</span><br><span class="line">        left:s.item2.width / <span class="number">4</span>,</span><br><span class="line">        backgroundColor:s.item1.backgroundColor,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//样式的继承</span></span><br><span class="line">    s.item4 = &#123;</span><br><span class="line">    	...s.item3,</span><br><span class="line">    	backgroundColor:<span class="string">'#FF00CC'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//带参数</span></span><br><span class="line">    s.item5 = <span class="function">(<span class="params">top</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> &#123;</span><br><span class="line">    		...s.item3,</span><br><span class="line">    		marginTop:top,</span><br><span class="line">    	&#125;;    	</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//带参数 + 缺省值</span></span><br><span class="line">    s.item6 = <span class="function">(<span class="params">top</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> &#123;</span><br><span class="line">    		...s.item3,</span><br><span class="line">    		marginTop:top ? top : <span class="number">10</span>,</span><br><span class="line">    	&#125;;       	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> style2 = styles2Creator();</span><br><span class="line"><span class="comment">//const style2 = StyleSheet.create(styles2Creator());</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'style2 :'</span>,style2);</span><br></pre></td></tr></table></figure>
<p>运行一下可以看到 log出来的style2和style1的属性。</p>
<h3 id="3-styled-components"><a href="#3-styled-components" class="headerlink" title="3. styled-components"></a>3. styled-components</h3><blockquote>
<p>号称React 中的 CSS 最佳实践,使用行内样式，支持CSS。该第三方也也可用于RN。</p>
</blockquote>
<p><code>react-native init</code>了个RN工程 写了个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View,</span><br><span class="line">    Image</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="comment">//需要 `npm install --save styled-components`</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">"styled-components/native"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里开始styled-components 式的样式：</span></span><br><span class="line"><span class="comment">//styled-components的格式为： const [自定义变量名] = styled.[相应的系统组件]`css表达式`;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通写法 （不大写开头会报错……</span></span><br><span class="line"><span class="keyword">const</span> ListContainerView = styled.View<span class="string">`</span></span><br><span class="line"><span class="string">    width:360;</span></span><br><span class="line"><span class="string">    height:280;</span></span><br><span class="line"><span class="string">    background-color: #F0F2F5;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展 （backgroundColor 和 background-color都可以</span></span><br><span class="line"><span class="keyword">const</span> ItemContainerView = ListContainerView.extend<span class="string">`</span></span><br><span class="line"><span class="string">    backgroundColor: #66CCFF;</span></span><br><span class="line"><span class="string">    flexDirection:row;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带参数</span></span><br><span class="line"><span class="keyword">const</span> LeftImageContainerView = styled.View<span class="string">`</span></span><br><span class="line"><span class="string">    height:<span class="subst">$&#123;props =&gt; props.primary ? <span class="number">280</span> : <span class="number">180</span>&#125;</span>;;</span></span><br><span class="line"><span class="string">    width:180;</span></span><br><span class="line"><span class="string">    background-color: #77BB00;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后发现一个尴尬的事就是不知道怎么扩展自定义组件 比如JDImage</span></span><br><span class="line"><span class="comment">//带计算表达式</span></span><br><span class="line"><span class="keyword">const</span> LeftImageHeight = <span class="number">280</span> - <span class="number">10</span> *<span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> LeftImage = styled.Image<span class="string">`</span></span><br><span class="line"><span class="string">    margin-top:10;</span></span><br><span class="line"><span class="string">    margin-left:10;</span></span><br><span class="line"><span class="string">    width:<span class="subst">$&#123;<span class="number">180</span> - <span class="number">10</span> *<span class="number">2</span>&#125;</span>;</span></span><br><span class="line"><span class="string">    height:<span class="subst">$&#123;LeftImageHeight&#125;</span>;</span></span><br><span class="line"><span class="string">    background-color: #FFFFFF;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想要获取另一个组件样式LeftImage的高度 不能直接使用 $&#123;LeftImage.height&#125;</span></span><br><span class="line"><span class="comment">//因为 LeftImage返回的是  ƒ StyledNativeComponent()方法……</span></span><br><span class="line"><span class="keyword">const</span> RightContainerView = styled.View<span class="string">`</span></span><br><span class="line"><span class="string">    width:160;</span></span><br><span class="line"><span class="string">    height:<span class="subst">$&#123;LeftImageHeight&#125;</span>;</span></span><br><span class="line"><span class="string">    background-color: #FF00CC;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ItemContainerView &gt;</span><br><span class="line">                &lt;LeftImageContainerView primary&gt;</span><br><span class="line">                    &#123;<span class="built_in">console</span>.log(<span class="string">'LeftImageContainerView.style:'</span>,LeftImageContainerView)&#125;</span><br><span class="line">                    &lt;LeftImage source=&#123;&#123;<span class="attr">uri</span>:<span class="string">'http://static.runoob.com/images/demo/demo2.jpg'</span>&#125;&#125;/&gt;</span><br><span class="line">                &lt;<span class="regexp">/LeftImageContainerView&gt;</span></span><br><span class="line"><span class="regexp">                &lt;RightContainerView&gt;&lt;/</span>RightContainerView&gt;</span><br><span class="line">            &lt;<span class="regexp">/ItemContainerView&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">AppRegistry.registerComponent('MyApp', () =&gt; MyApp);</span></span><br></pre></td></tr></table></figure>
<p><strong><em>优点：</em></strong></p>
<ul>
<li>react推荐的行内样式 css in js；</li>
<li>方便前端同学的写法 可以完全使用CSS的书写习惯</li>
</ul>
<p>缺点和原始写法的差不多，还对本身不是前端开发的人来说带来额外的学习成本…… 所以还是不推荐……</p>
<p><strong><em>参考链接：</em></strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/29344146" target="_blank" rel="noopener">styled-components React 中的 CSS 最佳实践 | zhihu</a></li>
<li><a href="https://www.styled-components.com/" target="_blank" rel="noopener">styled-components | 官方文档</a></li>
<li><a href="http://www.alloyteam.com/2017/05/guide-styled-components/" target="_blank" rel="noopener">Styled Components：让样式也成为组件 | alloyteam.</a></li>
</ul>
<h3 id="4-改进写法二"><a href="#4-改进写法二" class="headerlink" title="4.改进写法二"></a>4.改进写法二</h3><blockquote>
<p>简单来讲 styled-components 就是生成一个带样式的组件，完全可以吸收这种写法 自己改进RN中 ，而不使用styled-components这个库</p>
</blockquote>
<p>结合 写法一 和 styled-components的想法，给出一个简单例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View,</span><br><span class="line">    Image</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stylesCreator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> width = <span class="number">360.0</span>, height = <span class="number">280.0</span>;</span><br><span class="line">    s.ListContainerView = &#123;</span><br><span class="line">        width:  width,</span><br><span class="line">        height: height,</span><br><span class="line">        backgroundColor: <span class="string">'#F0F2F5'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    s.ItemContainerView = &#123;</span><br><span class="line">        width:  width,</span><br><span class="line">        height: height,</span><br><span class="line">        backgroundColor: <span class="string">'#66CCFF'</span>,</span><br><span class="line">        flexDirection:<span class="string">'row'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'s.ItemContainerView :'</span>,s.ItemContainerView);</span><br><span class="line">    s.LeftImageContainerView = &#123;</span><br><span class="line">        height:height,</span><br><span class="line">        width:width / <span class="number">2</span>,</span><br><span class="line">        backgroundColor: <span class="string">'#77BB00'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    s.LeftImage = &#123;</span><br><span class="line">        marginTop:<span class="number">10</span>,</span><br><span class="line">        marginLeft:<span class="number">10</span>,</span><br><span class="line">        width: <span class="number">180</span> - <span class="number">10</span> *<span class="number">2</span>,</span><br><span class="line">        height: s.LeftImageContainerView.height - <span class="number">10</span>*<span class="number">2</span>,</span><br><span class="line">        backgroundColor: <span class="string">`#FFFFFF`</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    s.RightContainerView = &#123;</span><br><span class="line">        width: width / <span class="number">2</span>,</span><br><span class="line">        height: s.LeftImage.height,</span><br><span class="line">        backgroundColor: <span class="string">'#FF00CC'</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> styles = stylesCreator();</span><br><span class="line"><span class="comment">//const styles = StyleSheet.create(stylesCreator());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后再结合 styled-components：</span></span><br><span class="line"><span class="comment">// 模拟 styled-components API</span></span><br><span class="line"><span class="keyword">const</span> styled = <span class="function">(<span class="params">Component, styler</span>) =&gt;</span> (props) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="keyword">typeof</span> styler === <span class="string">'function'</span> ? styler(props) : styler;</span><br><span class="line">    <span class="keyword">return</span> &lt;Component &#123;...props&#125; style=&#123;[ style, props.style ]&#125; /&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// styled components</span><br><span class="line">//同样可以完成组件（带样式）的继承 const RightContainerView = styled(LeftImageContainerView,styles.RightContainerView);</span><br><span class="line"></span><br><span class="line">const ListContainerView = styled(View,styles.ListContainerView);</span><br><span class="line">const ItemContainerView = styled(View,styles.ItemContainerView);</span><br><span class="line">const LeftImageContainerView = styled(View,styles.LeftImageContainerView);</span><br><span class="line">const LeftImage = styled(Image,styles.LeftImage);</span><br><span class="line">const RightContainerView = styled(View,styles.RightContainerView);</span><br><span class="line"></span><br><span class="line">export default class MyApp extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;ItemContainerView &gt;</span><br><span class="line">                &lt;LeftImageContainerView primary&gt;</span><br><span class="line">                    &#123;console.log('LeftImageContainerView.style:',LeftImageContainerView)&#125;</span><br><span class="line">                    &lt;LeftImage source=&#123;&#123;uri:'http://static.runoob.com/images/demo/demo2.jpg'&#125;&#125;/&gt;</span><br><span class="line">                &lt;/LeftImageContainerView&gt;</span><br><span class="line">                &lt;RightContainerView&gt;&lt;/RightContainerView&gt;</span><br><span class="line">            &lt;/ItemContainerView&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent('MyApp', () =&gt; MyApp);</span><br></pre></td></tr></table></figure>
<p>emmm ，无需引入第三方库 感觉好多了。缺点当然是不支持原CSS写法。</p>
<h3 id="5-react-native-0-45"><a href="#5-react-native-0-45" class="headerlink" title="5. react native 0.45"></a>5. react native 0.45</h3><p>在0.45版本中运行改进写法一时，你可能看到style2在控制台的输出类似为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const style2 = StyleSheet.create(styles2Creator());</span></span><br><span class="line"></span><br><span class="line">  style2 : </span><br><span class="line">&#123;<span class="attr">item1</span>: <span class="number">12</span>, <span class="attr">item2</span>: <span class="number">13</span>, <span class="attr">item3</span>: <span class="number">14</span>, <span class="attr">item4</span>: <span class="number">15</span>, <span class="attr">item5</span>: <span class="number">16</span>, …&#125;</span><br><span class="line">	item1:<span class="number">12</span></span><br><span class="line">	item2:<span class="number">13</span></span><br><span class="line">	item3:<span class="number">14</span></span><br><span class="line">	item4:<span class="number">15</span></span><br><span class="line">	item5:<span class="number">16</span></span><br><span class="line">	item6:<span class="number">17</span></span><br><span class="line">__proto__:<span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p>这是怎么肥事！我的item对象怎么变成数字了！</p>
<p>别急，在0.45版本后StyleSheet代码有所改变（其实我没看具体哪个小版本改的 <code>_(:зゝ∠)_</code>）, StyleSheet.create改成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//react native : 0.45.1</span></span><br><span class="line">  create&lt;S: Styles&gt;(obj: S): StyleSheet&lt;S&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result: StyleSheet&lt;S&gt; = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      StyleSheetValidation.validateStyle(key, obj);</span><br><span class="line">      result[key] = ReactNativePropRegistry.register(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//react native0.45.1 ReactNativePropRegistry.js</span></span><br><span class="line"><span class="keyword">var</span> objects = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> uniqueID = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> emptyObject = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactNativePropRegistry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> register(object: <span class="built_in">Object</span>): number &#123;</span><br><span class="line">    <span class="keyword">var</span> id = ++uniqueID;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(object);</span><br><span class="line">    &#125;</span><br><span class="line">    objects[id] = object;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//多的就不看了……内容不多各位有兴趣自己看</span></span><br></pre></td></tr></table></figure>
<p>通过看ReactNativePropRegistry代码，StyleSheet将样式对象储存在<code>objects</code>中,并返回<code>uniqueID</code></p>
<p>比如取回原来的item，就可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactNativePropRegistry <span class="keyword">from</span> <span class="string">'../node_modules/react-native/Libraries/Renderer/src/renderers/native/ReactNativePropRegistry'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ReactNativePropRegistry.getByID(12): "</span>,ReactNativePropRegistry.getByID(<span class="number">12</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ReactNativePropRegistry.getByID(style2. item1): "</span>,ReactNativePropRegistry.getByID(style2. item1));</span><br></pre></td></tr></table></figure>
<p>就可以通过 <strong>ReactNativePropRegistry.getByID</strong>就可以取得样式对象了。这可能对于之前的改进写法造成了一点小麻烦，不过还可以用~</p>
<hr>
<blockquote>
<p>其他参考阅读：</p>
</blockquote>
<ul>
<li><a href="https://github.com/sabeurthabti/react-native-css" target="_blank" rel="noopener">react-native-css | github</a> css + sass in rn</li>
<li><a href="https://github.com/blackmiaool/rn-less" target="_blank" rel="noopener">rn-less | github</a> css + less in rn</li>
<li><a href="https://zhuanlan.zhihu.com/p/28060579" target="_blank" rel="noopener">React-Native 样式管理方案浅谈 | zhihu</a></li>
</ul>
]]></content>
      <categories>
        <category>essay</category>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux源码浅读</title>
    <url>/essay/Redux%E6%BA%90%E7%A0%81%E6%B5%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>本文是关于 redux（3.7.2）源代码的一些浅读</p>
</blockquote>
<p>在<a href="https://github.com/reactjs/redux/tree/master/src" target="_blank" rel="noopener">redux源码目录</a>中 ，可以看到以下文件目录：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-- utils/</span><br><span class="line">    |-- warning.js              <span class="comment">//打印error</span></span><br><span class="line">|-- <span class="number">1.</span> applyMiddleware.js          <span class="comment">// </span></span><br><span class="line">|-- <span class="number">2.</span> bindActionCreators.js       <span class="comment">//</span></span><br><span class="line">|-- <span class="number">3.</span> combineReducers.js          <span class="comment">//</span></span><br><span class="line">|-- <span class="number">4.</span> compose.js                  <span class="comment">//</span></span><br><span class="line">|-- <span class="number">5.</span> createStore.js              <span class="comment">//</span></span><br><span class="line">|-- index.js                    <span class="comment">//入口文件</span></span><br></pre></td></tr></table></figure>
<p>与文件对应的，主要也是介绍 createStore compose combineReducers bindActionCreators applyMiddleware这几个函数。</p>
<a id="more"></a>
<h3 id="1-compose"><a href="#1-compose" class="headerlink" title="1. compose"></a>1. compose</h3><p>先来看看compose函数，这个比较简单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//funcs保存着所有参数函数的数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, funcs = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">    funcs[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略一些逻辑判断……</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//reduce方法使用指定的函数将数组元素进行组合，生成单个值</span></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a(b.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中主要就是对 reduce 的理解了。reduce()方法使用指定的函数将数组元素进行组合（从左到右），生成单个值。具体可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">Array.prototype.reduce() | MDN</a></p>
<p>compose的功能为从右到左,组合参数(函数)。传递给compose方法的参数是函数类型的，</p>
<p><strong>compose(f, g, h) 相当于 (…args) =&gt; f(g(h(…args)))</strong></p>
<h3 id="2-applyMiddleware-与-中间件链"><a href="#2-applyMiddleware-与-中间件链" class="headerlink" title="2. applyMiddleware 与 中间件链"></a>2. applyMiddleware 与 中间件链</h3><p>故名思义这个函数就是应用中间件，一般使用方式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//thunk代表react-thunk中间件</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure>
<h4 id="2-1-中间件及react-thunk"><a href="#2-1-中间件及react-thunk" class="headerlink" title="2.1 中间件及react-thunk"></a>2.1 中间件及react-thunk</h4><p>在看applyMiddleware函数前，先来简单看一下中间件，redux中间件在发起action到达reducer之间扩展了一些功能。一般用于记录日志（reudx-logger）和增加异步调用（redux-thunk , redux-saga）等。这些中间件一般按照一定的格式书写，比如react-thunk2.2.0的源码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//react-thunk2.2.0的代码，很简单 只有十几行……</span></span><br><span class="line"><span class="comment">//外层函数可以传入多余的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//获取dispatch getState（是由applyMiddleware传入）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dispatch = _ref.dispatch,</span><br><span class="line">        getState = _ref.getState;</span><br><span class="line">    <span class="comment">//1. 如果这个中间件是调用链最内环的，next指原store.dispatch    </span></span><br><span class="line">    <span class="comment">//2. 其他next一般指上一个中间件的返回值 action =&gt; &#123;&#125;</span></span><br><span class="line">    <span class="comment">//对于这个next的赋值不清楚的话可以结合之后的applyMiddleware函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//1. 原action只是个普通的对象，thunk使action可以传入函数类型，并传入了dispatch, getState, extraArgument</span></span><br><span class="line">        <span class="comment">//2. 如果action是个异步函数，thunk会调用该函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 函数调用结束后，获取必要的数据再次触发dispatch由此实现异步效果。</span></span><br><span class="line">        <span class="keyword">return</span> next(action);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到react-thunk中间件是一个多层的高阶函数，格式大致为： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123;dispatch,getState&#125;) =&gt; <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;<span class="keyword">return</span> next(action)&#125;</span><br></pre></td></tr></table></figure>
<p>中间件的格式都要遵循这样相似的格式，这是由applyMiddleware函数决定的。接下来看下applyMiddleware的源码：</p>
<h4 id="2-2-applyMiddleware源码"><a href="#2-2-applyMiddleware源码" class="headerlink" title="2.2 applyMiddleware源码"></a>2.2 applyMiddleware源码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//applyMiddleware源码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//middlewares保存传进来的中间件</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> _len = <span class="built_in">arguments</span>.length, middlewares = <span class="built_in">Array</span>(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) &#123;</span><br><span class="line">    middlewares[_key] = <span class="built_in">arguments</span>[_key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//createStore是创建createStore的函数，会在下文解读，这里先不管</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">createStore</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//创建store 并获取了其dispatch方法</span></span><br><span class="line">      <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer);</span><br><span class="line">      <span class="keyword">var</span> _dispatch = store.dispatch;</span><br><span class="line">      <span class="keyword">var</span> chain = [];</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//用于传递给中间件第一层函数的参数，上文在thunk中有看到</span></span><br><span class="line">      <span class="keyword">var</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> _dispatch(action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//middlewares保存的是中间件，chain对应保存的就是中间件第二层函数组成的数组</span></span><br><span class="line">      <span class="comment">//形象点就是上文中间件格式去掉第一层：next =&gt; action =&gt; &#123;&#125;</span></span><br><span class="line">      chain = middlewares.map(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> middleware(middlewareAPI);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//1. componse的功能在上文说到，假设chain为[F1,F2,F3],compose之后变成了F1(F2(F3))</span></span><br><span class="line">      <span class="comment">//2. 与上文thunk中说到中间件格式对应，F3是中间件链的最内环 所以F3的next参数为store.dispatch</span></span><br><span class="line">      <span class="comment">//3. F2的next参数就是F3返回的 action =&gt; &#123;&#125;</span></span><br><span class="line">      <span class="comment">//4. 同样的F1的next参数就是F2返回的 action =&gt; &#123;&#125;      </span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//_dispatch就相当于F1(F2(F3(store.dispatch)))</span></span><br><span class="line">      <span class="comment">//这样多个中间件就组合到了一起，形成了中间件链</span></span><br><span class="line">      _dispatch = compose.apply(<span class="literal">undefined</span>, chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//新的dispatch会覆盖原dispatch，之后调用dispatch同时会调用中间件链</span></span><br><span class="line">      <span class="keyword">return</span> _extends(&#123;&#125;, store, &#123;</span><br><span class="line">        dispatch: _dispatch</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>_dispatch = compose.apply(undefined, chain)(store.dispatch);</code>组合后，中间件的next就是store.dispatch一路经过上一个中间件封装后的变种dispatch。</p>
<h4 id="2-3-中间件链的执行顺序"><a href="#2-3-中间件链的执行顺序" class="headerlink" title="2.3 中间件链的执行顺序"></a>2.3 中间件链的执行顺序</h4><p>光看代码可能对于中间件链的执行顺序的理解还是优点蒙，这里来做个实践加深一下理解。</p>
<blockquote>
<p><strong>一、</strong> 先按上文说的中间件格式<code>({dispatch,getState}) =&gt; next =&gt; action =&gt; {return next(action)}</code> 写三个中间件：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params">&#123;dispatch,getState&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'middleware1 next层 next:'</span>,next);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware1 action层 开始'</span>)</span><br><span class="line">            next(action)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware1 action层 结束'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params">&#123;dispatch,getState&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'middleware2 next层 next:'</span>,next);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware2 action层 开始'</span>)</span><br><span class="line">            next(action)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware2 action层 结束'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params">&#123;dispatch,getState&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'middleware3 next层 next:'</span>,next);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware3 action层 开始'</span>)</span><br><span class="line">            next(action)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'middleware3 action层 结束'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>二、</strong> 将它们和redux-thunk 和 redux-logger一起加入中间件链：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middlewares = [</span><br><span class="line">    middleware1,</span><br><span class="line">    thunkMiddleWare,</span><br><span class="line">    middleware2,</span><br><span class="line">    middleware3,</span><br><span class="line">    loggerMiddleWare,<span class="comment">//redux-logger需要放在最后面</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState, applyMiddleware(...middlewares));</span><br></pre></td></tr></table></figure>
<p>运行你的代码后在chrome控制台看到如下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">middleware3 next层 next: ƒ (l)&#123;<span class="keyword">if</span>(<span class="string">"function"</span>==<span class="keyword">typeof</span> …</span><br><span class="line"> </span><br><span class="line">middleware2 next层 next: ƒ (action)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'middleware3 action层 开始'</span>);</span><br><span class="line">next(action);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'middleware3 action层 结束'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">middleware1 next层 next: ƒ (action) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next(action);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>这也验证了上文对 <code>_dispatch = compose.apply(undefined, chain)(store.dispatch);</code>的理解。</p>
<p>这里的中间件链是由 <code>[m1,thunk,m2,m3,logger]</code>组成，在<code>compose</code>之后变成了 <code>m1(thunk(m2(m3(logger))))</code>,<br>所以</p>
<ul>
<li>m3的<em>next</em>参数是<strong>logger</strong>的action层函数（参数为action那层函数）</li>
<li>m2的<em>next</em>参数是<strong>m3</strong>的action层函数</li>
<li>m1的<em>next</em>参数是<strong>thunk</strong>的action层函数</li>
</ul>
<blockquote>
<p><strong>三、</strong> 执行一下 dispatch(action) :</p>
</blockquote>
<p>这时候分两种情况：</p>
<p>1、当action类型为对象时,在chrome控制台看到如下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">发起 dispatch(action) action类型为对象</span><br><span class="line"></span><br><span class="line">middleware1 action层 开始</span><br><span class="line">middleware2 action层 开始</span><br><span class="line">middleware3 action层 开始</span><br><span class="line">action SOME_OBJ_ACTION       redux-logger.js:<span class="number">1</span></span><br><span class="line">middleware3 action层 结束</span><br><span class="line">middleware2 action层 结束</span><br><span class="line">middleware1 action层 结束</span><br></pre></td></tr></table></figure>
<p>粗粗一看好像顺序不对啊，不该先执行middleware3的逻辑嘛？其实内层（位置靠后的中间件）只是返回了一个function，并没有执行其中的逻辑，不断由外层的中间件包裹形成了一个‘<strong>洋葱模型</strong>’。由外向内穿心而过，再由内向外完成流程。</p>
<p>这样子就很明确了，<strong>中间件的action层执行顺序为先加入中间件链的先执行！</strong>，更准确的说中间件中先执行从外层向内层中 <code>next(action)</code>之前的逻辑，然后执行从内层向外层中 <code>next(action)</code>之后的逻辑。</p>
<p>2、当action类型为函数时,在chrome控制台看到如下信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">发起  dispatch(action) action类型为函数</span><br><span class="line"></span><br><span class="line">middleware1 action层 开始</span><br><span class="line">middleware1 action层 结束</span><br></pre></td></tr></table></figure>
<p>可以看到只执行了 middleware1 和 thunk 两个中间件！<strong>这是因为thunk没有执行 <code>next(action)</code> 中断了中间件链！</strong> 当中间件没有执行next(action)时会导致中间件链中断，这是因为dispatch没有传递下去，所以中间件还可以捣乱咯～</p>
<h3 id="3-bindActionCreators"><a href="#3-bindActionCreators" class="headerlink" title="3. bindActionCreators"></a>3. bindActionCreators</h3><p>bindActionCreators的功能是为action creaters包装上dispatch，使其调用action时自动dispatch对应的action。</p>
<p>在bindActionCreators.js中只有两个函数 <code>bindActionCreator</code> 和 <code>bindActionCreators</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数的主要作用就是返回一个函数，当我们调用返回的这个函数的时候，就会自动的dispatch对应的action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略一些逻辑判断</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取所有action creater函数的名字</span></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(actionCreators);</span><br><span class="line">  <span class="comment">// 保存dispatch和action creater函数进行绑定之后的集合</span></span><br><span class="line">  <span class="keyword">var</span> boundActionCreators = &#123;&#125;;</span><br><span class="line">  <span class="comment">//为每个actionCreators 包装上 dispatch</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    <span class="keyword">var</span> actionCreator = actionCreators[key];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-combineReducers"><a href="#4-combineReducers" class="headerlink" title="4. combineReducers"></a>4. combineReducers</h3><p>Reducer只是一些纯函数，它接收之前的state和action，并返回新的state。当应用变大，我们可以拆分多个小的reducers，分别独立的操作state tree的不同部分。而combineReducers就是将多个不同的reducer合并成一个最终的reducer，用于赋值给createStore函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//combineReducers的代码比较简单，在省略一些错误判断的代码后：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers);</span><br><span class="line">  <span class="keyword">var</span> finalReducers = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = reducerKeys[i];</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从上面到这里都是为了保存finalReducerKeys 和 finalReducers</span></span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回的combination函数就相当于结合所有reducers之后新的reducer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> action = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> nextState = &#123;&#125;;</span><br><span class="line">    <span class="comment">//这里遍历了所有之前自定义的reducers，并记录下是否state有改变，并记录下改变的state</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; finalReducerKeys.length; _i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> _key = finalReducerKeys[_i];</span><br><span class="line">      <span class="keyword">var</span> reducer = finalReducers[_key];</span><br><span class="line">      <span class="keyword">var</span> previousStateForKey = state[_key];</span><br><span class="line">      <span class="comment">//遍历所有的reducer，若previousStateForKey匹配到则返回新的state</span></span><br><span class="line">      <span class="comment">//若匹配不到就在reducer中dufault中返回原state</span></span><br><span class="line">      <span class="keyword">var</span> nextStateForKey = reducer(previousStateForKey, action);</span><br><span class="line">      ......</span><br><span class="line">      nextState[_key] = nextStateForKey;</span><br><span class="line">      <span class="comment">//这里有点意思，并没有因为找到不同的state就直接返回</span></span><br><span class="line">      <span class="comment">//这意味着，多个子reducers可以对同个action返回自己的state</span></span><br><span class="line">      <span class="comment">//并且返回的state是依据靠后的reducer的返回值决定的</span></span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-createStore"><a href="#5-createStore" class="headerlink" title="5. createStore"></a>5. createStore</h3><p>现在来看下最重要的createStore函数：</p>
<!--preloadedState-->
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* redux有且仅有一个store，createStore函数就是用于创建一个store用来存放所有的state。</span></span><br><span class="line"><span class="comment">* @param &#123;Function&#125;  reducer</span></span><br><span class="line"><span class="comment">* @param &#123;any&#125; [preloadedState] 初始化state</span></span><br><span class="line"><span class="comment">* @param &#123;Function&#125; [enhancer] store的增强器，有applyMiddleware、时间旅行（time travel）、持久化（persistence）等。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面是createStore的参数，其中enhancer指的是store的增强器（对store API进行改造）。</p>
<ul>
<li>applyMiddleware在前面我们已经见过了，applyMiddleware是对store的dispatch函数的修改。</li>
<li><strong>时间旅行</strong>则是指redux可以回到任意以前的状态。<ul>
<li>这是因为Redux使用简单的对象来表示state状态，并使用纯函数计算下一个状态。这意味着如果给定一个特定state状态和一个特定action操作，那么下一个状态将始终完全相同。这种特性可以让我们将所有修改过的状态保存在一个状态历史对象中，通过指定恢复到状态历史对象中从前的状态，来完成时间旅行。</li>
<li>比较容易可以想到的应用就是一些撤销/重做操作。</li>
</ul>
</li>
<li><strong>持久化</strong>持久化这个概念肯定大家都熟悉，也有人做出了实现：<a href="https://github.com/rt2zz/redux-persist" target="_blank" rel="noopener">redux-persist</a></li>
</ul>
<p>介绍完enhancer，来接着看代码逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState;</span><br><span class="line">    preloadedState = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentReducer = reducer;      	<span class="comment">//</span></span><br><span class="line">  <span class="keyword">var</span> currentState = preloadedState; 	<span class="comment">//当前的state</span></span><br><span class="line">  <span class="keyword">var</span> currentListeners = [];           <span class="comment">//订阅函数</span></span><br><span class="line">  <span class="keyword">var</span> nextListeners = currentListeners;<span class="comment">//订阅函数备份，</span></span><br><span class="line">  <span class="comment">//用于解决listeners数组执行过程（for循环）中，取消订阅listener产生的listeners数组index错误。</span></span><br><span class="line">  <span class="comment">//这样保证在某个dispatch后，会保证在这个dispatch之前的所有事件监听器全部执行</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> isDispatching = <span class="literal">false</span>; 			  <span class="comment">//dispatch方法同步标志</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ensureCanMutateNextListeners</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @returns &#123;any&#125; 当前state</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 将一个订阅函数放到 listeners 队列里，当 dispatch 的时候，逐一调用 listeners 中的回调方法。    </span></span><br><span class="line"><span class="comment">  * @param &#123;Function&#125; listener函数</span></span><br><span class="line"><span class="comment">  * @return &#123;Function&#125; 解除绑定的方法</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> isSubscribed = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners();</span><br><span class="line">    nextListeners.push(listener);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解除订阅的方法，</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      isSubscribed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners();</span><br><span class="line">      <span class="keyword">var</span> index = nextListeners.indexOf(listener);</span><br><span class="line">      nextListeners.splice(index, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * dispatch方法,调用reducer</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; action </span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @returns &#123;Object&#125; 一般会返回action,</span></span><br><span class="line"><span class="comment">   * 如果使用了中间件，可能返回promise 或者function之类的（）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="comment">//dispatch是同步的，用isDispatching标志来判断</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用reducer</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">//更新state树</span></span><br><span class="line">      currentState = currentReducer(currentState, action);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用nextListeners中的监听方法</span></span><br><span class="line">    <span class="keyword">var</span> listeners = currentListeners = nextListeners;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> listener = listeners[i];</span><br><span class="line">      listener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 替换reducer</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replaceReducer</span>(<span class="params">nextReducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentReducer = nextReducer;</span><br><span class="line">    <span class="comment">//触发生成新的state树</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *略</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成初始state树</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _ref2 = &#123;</span><br><span class="line">    dispatch: dispatch,</span><br><span class="line">    subscribe: subscribe,</span><br><span class="line">    getState: getState,</span><br><span class="line">    replaceReducer: replaceReducer</span><br><span class="line">  &#125;, _ref2[$$observable] = observable, _ref2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>以上就是我个人的简单见解，如果有什么错误之处，敬请指导讨论</em></p>
<hr>
<p>参考资料：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法 | 阮一峰</a></li>
<li><a href="http://cn.redux.js.org/" target="_blank" rel="noopener">Redux 中文文档</a></li>
</ul>
]]></content>
      <categories>
        <category>essay</category>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS安装包瘦身</title>
    <url>/essay/ipa_size/</url>
    <content><![CDATA[<blockquote>
<p>refs <em> <a href="http://blog.cnbang.net/tech/2544/" target="_blank" rel="noopener">iOS可执行文件瘦身方法</a><br>refs </em> <a href="http://blog.lessfun.com/blog/2015/09/02/find-unused-resources-in-xcode-project/" target="_blank" rel="noopener">查找XCode工程中没被使用的图片资源</a></p>
</blockquote>
<p>Apple对安装包大小是有限制的，缩减iOS安装包大小是很多中大型APP都要做的事，一般首先会对资源文件下手，压缩图片/音频，去除不必要的资源。这些资源优化做完后，我们还可以尝试对可执行文件进行瘦身，项目越大，可执行文件占用的体积越大，又因为AppStore会对可执行文件加密，导致可执行文件的压缩率低，压缩后可执行文件占整个APP安装包的体积比例大约有80%~90%，还是挺值得优化的。下面介绍一下在研究可执行文件过程中发现的可以优化的点。</p>
<a id="more"></a>
<h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><p><strong>1.删除无用资源</strong></p>
<p>解压ipa文件，检查是否有无用资源存在。</p>
<p>现在应该没有APP需要支持iPhone4以下的机型了，所以1X的图片可以全部删掉。3X的图片是保留还是删掉看具体情况。</p>
<p>重复的图片分两种，一种是名字一样的图片，如果你使用.xcassets来管理图片，那么Xcode的左边栏会有警告提示图片名字重复，直接按提示一一处理即可</p>
<p><strong>2.资源压缩</strong></p>
<p>首先是<em>图片压缩</em>，ImageOptim/TinyPNG/ImageAlapha 工具可以实现无损压缩。</p>
<p>其实在我们使用这些图片的时候,我们其实是用的一些图片,但是像图片的创建日期,创建人之类的信息其实在我们项目中是没有用到的.这些信息我们可以通过一些工具进行删除,这里给大家推荐款工具ImageOptim.另外关于图片，建议使用Apple推荐的.xcassets来管理，它会把里边的所有png格式的图片压缩成一个Assets.car文件，压缩比率比其他方式管理图片要高。不过测试发现jpg图片不会在Assets.car文件里。</p>
<p>尽量使用<em>8-bit图片</em></p>
<p>使用8-bit的PNG图片，比32-bit的图片能减少4倍的压缩率。由于8-bit的图片支持最多256种不同的颜色，所以8-bit的图片一般只应该用于一小部分的颜se图片。例如灰度图片最好使用8-bit。</p>
<p><em>音频的压缩</em></p>
<p>参考WWDC中的<a href="https://developer.apple.com/videos/play/wwdc2011/404/" target="_blank" rel="noopener">Audio Development for Games</a>，里面介绍了如何有效的处理音频。常规来说，我们要使用AAC或MP3来压缩音频，并且可以尝试降低一下音频的比特率。有时候44.1khz的采样是没有必要的，稍微低一点的比特率也不会降低音频的质量。</p>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p><strong>1.编译器优化级别</strong></p>
<p>Build Settings-&gt;Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</p>
<p><strong>2.去除符号信息</strong></p>
<p>Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，详细信息见官方文档。</p>
<p>这些选项目前都是XCode里release的默认选项，但旧版XCode生成的项目可能不是，可以检查一下。其他优化还可以参考官方文档—<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.html" target="_blank" rel="noopener">Introduction to Code Size Performance Guidelines</a></p>
<h2 id="可执行文件优化"><a href="#可执行文件优化" class="headerlink" title="可执行文件优化"></a>可执行文件优化</h2><p><strong>1.静态库统计</strong></p>
<p>项目里会引入很多第三方静态库，如果能知道这些第三方库在可执行文件里占用的大小，就可以评估是否值得去找替代方案去掉这个第三方库。我们可以从linkmap中统计出这个信息，可以通过linkmap统计每个.o目标文件占用的体积和每个.a静态库占用的体积</p>
<p><strong>2.ARC转MRC</strong></p>
<p>有人提出用ARC写的代码编译出来的可执行文件是会比用MRC大的，原因大致是ARC代码会在某些情况多出一些retain和release的指令，例如调用一个方法，它返回的对象会被retain，退出作用域后会被release，MRC就不需要，汇编指令变多，机器码变多，可执行文件就变大了。还有其他细节实现的区别，先不纠结了。</p>
<p>那用ARC究竟会增大多少体积？我觉得从汇编指令的增多减少去算是很难算准确的，这东西涉及细节太多，还是得从统计的角度计算。做了几个对比试验，统计了几个同时支持ARC/MRC的开源项目在开启/关闭ARC的情况下<strong>TEXT代码段的大小对比。只对比</strong>TEXT代码段是因为：</p>
<p>ARC对可执行文件大小的影响几乎都是在代码段ARC大概会使代码段增加10%的size，考虑代码段占可执行文件大约有80%，估计对整个可执行文件的影响会是8%。</p>
<p>可以评估一下8%的体积下降是不是值得把项目里某些模块改成MRC，这样程序的维护成本上升了，一般不到特殊情况不建议这么做。</p>
<p><strong>3.无用代码</strong></p>
<p>在项目里新建一个类，给它添加几个方法，但不要在任何地方import它，build完项目后观察linkmap，你会发现这个类还是被编译进可执行文件了。</p>
<p>因为object-c的动态特性，它可以通过类和方法名反射获得这个类和方法进行调用，所以就算在代码里某个类没被使用到，编译器也没法保证这个类不会在运行时通过反射去调用，所以只要是在项目里的文件，无论是否又被使用到都会被编译进可执行文件。</p>
<p>对此我们可以通过脚本，遍历整个项目的文件，找出所有没有被引用的类文件和没有被调用的方法，在保证没有其他地方动态调用的情况下把它们去掉。如果整个项目历时很长，历时代码遗留较多，这个清理对可执行文件省出的空间还是挺可观的。</p>
<p><strong>4.类/方法名长度</strong></p>
<p>观察linkmap可以发现每个类和方法名都在__cstring段里都存了相应的字符串值，所以类和方法名的长短也是对可执行文件大小是有影响的，原因还是object-c的动态特性，因为需要通过类/方法名反射找到这个类/方法进行调用，object-c对象模型会把类/方法名字符串都保存下来。</p>
<p>对此我们可以考虑在编译前把所有类和方法名进行混淆，跟压缩js一样，把长名字替换成短名字，这样做的好处除了缩小体积外，还对安全性有很大提升，别人拿到可执行文件对它class-dump出来的结果都是混淆后的类和方法名，就无法从类和方法名中猜出某个方法是做什么的，就难以挂钩子进行hack。不过这样做有个缺点，就是crash堆栈反解出来的堆栈方法名会是混淆后的，需要再加一层混淆-&gt;原名的转换，实现和使用成本有点高。</p>
<p>实际上这部分占用的长度比较小，中型项目也就几百K，对安全性要求高的情况可以试试。</p>
<p><strong>5.冗余字符串</strong></p>
<p>代码上定义的所有静态字符串都会记录在在可执行文件的__cstring段，如果项目里Log非常多，这个空间占用也是可观的，也有几百K的大小，可以考虑清理所有冗余的字符串。另外如果有特别长的字符串，建议抽离保存成静态文件，因为AppStore对可执行文件加密导致压缩率低，特别长的字符串抽离成静态资源文件后压缩率会比在可执行文件里高很多。</p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite3-简介.md</title>
    <url>/essay/sqlite3-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在iOS中操作SQLite数据库可以分为以下几步（注意先在项目中导入libsqlite3框架）：</p>
<ol>
<li>添加libsqlite3.tbd</li>
<li>打开数据库，利用sqlite3_open()打开数据库会指定一个数据库文件保存路径，如果文件存在则直接打开，否则创建并打开。打开数据库会得到一个sqlite3类型的对象，后面需要借助这个对象进行其他操作</li>
<li>执行SQL语句，执行SQL语句又包括有返回值的语句和无返回值语句。<ul>
<li>对于无返回值的语句（如增加、删除、修改等）直接通过sqlite3_exec()函数执行；</li>
<li>对于有返回值的语句则首先通过sqlite3_prepare_v2()进行sql语句评估（语法检测），然后通过sqlite3_step()依次取出查询结果的每一行数据，对于每行数据都可以通过对应的sqlite3_column_类型()方法获得对应列的数据，如此反复循环直到遍历完成。当然，最后需要释放句柄。</li>
</ul>
</li>
</ol>
<a id="more"></a>
<p>在整个操作过程中无需管理数据库连接，对于嵌入式SQLite操作是持久连接（尽管可以通过sqlite3_close()关闭），不需要开发人员自己释放连接。纵观整个操作过程，其实与其他平台的开发没有明显的区别，较为麻烦的就是数据读取，在iOS平台中使用C进行数据读取采用了游标的形式，每次只能读取一行数据，较为麻烦。</p>
<h3 id="添加framework"><a href="#添加framework" class="headerlink" title="添加framework"></a>添加framework</h3><p>需要添加libsqlite3.tbd（老版本xocde中叫libsqlite3.dylib）</p>
<h3 id="打开-创建数据库："><a href="#打开-创建数据库：" class="headerlink" title="打开/创建数据库："></a>打开/创建数据库：</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) sqlite3 *database;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">BOOL</span>)openDb:(<span class="built_in">NSString</span> *)dbname&#123;</span><br><span class="line">   <span class="comment">//取得数据库保存路径，通常保存沙盒Documents目录</span></span><br><span class="line">   <span class="built_in">NSString</span> *directory=[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) firstObject];</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"数据库db储存路径 ： %@"</span>,directory);</span><br><span class="line">   <span class="built_in">NSString</span> *filePath=[directory stringByAppendingPathComponent:dbname];</span><br><span class="line">   <span class="comment">//如果有数据库则直接打开，否则创建并打开（注意filePath是ObjC中的字符串，需要转化为C语言字符串类型）</span></span><br><span class="line">   <span class="keyword">if</span> (SQLITE_OK ==sqlite3_open(filePath.UTF8String, &amp;_database)) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"数据库打开成功!"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败!"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行语句"><a href="#执行语句" class="headerlink" title="执行语句"></a>执行语句</h2><h3 id="执行插入、修改、删除语句"><a href="#执行插入、修改、删除语句" class="headerlink" title="执行插入、修改、删除语句"></a>执行插入、修改、删除语句</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)executeNonQuery:(<span class="built_in">NSString</span> *)sql&#123;</span><br><span class="line">   <span class="keyword">char</span> *error;</span><br><span class="line">   <span class="comment">//单步执行sql语句，用于插入、修改、删除</span></span><br><span class="line">   <span class="keyword">if</span> (SQLITE_OK!=sqlite3_exec(_database, sql.UTF8String, <span class="literal">NULL</span>, <span class="literal">NULL</span>,&amp;error)) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"执行SQL语句过程中发生错误！错误信息：%s"</span>,error);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行查询语句"><a href="#执行查询语句" class="headerlink" title="执行查询语句"></a>执行查询语句</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="built_in">NSArray</span> *)executeQuery:(<span class="built_in">NSString</span> *)sql&#123;</span><br><span class="line">   <span class="built_in">NSMutableArray</span> *rows=[<span class="built_in">NSMutableArray</span> array];<span class="comment">//数据行</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//评估语法正确性</span></span><br><span class="line">   sqlite3_stmt *stmt;</span><br><span class="line">   <span class="comment">//检查语法正确性</span></span><br><span class="line">   <span class="keyword">if</span> (SQLITE_OK==sqlite3_prepare_v2(_database, sql.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">       <span class="comment">//单步执行sql语句</span></span><br><span class="line">       <span class="keyword">while</span> (SQLITE_ROW==sqlite3_step(stmt)) &#123;</span><br><span class="line">           <span class="keyword">int</span> columnCount= sqlite3_column_count(stmt);</span><br><span class="line">           <span class="built_in">NSMutableDictionary</span> *dic=[<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;columnCount; i++) &#123;</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">char</span> *name= sqlite3_column_name(stmt, i);<span class="comment">//取得列名</span></span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *value= sqlite3_column_text(stmt, i);<span class="comment">//取得某列的值</span></span><br><span class="line">               dic[[<span class="built_in">NSString</span> stringWithUTF8String:name]]=[<span class="built_in">NSString</span> stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)value];</span><br><span class="line">           &#125;</span><br><span class="line">           [rows addObject:dic];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//释放句柄</span></span><br><span class="line">   sqlite3_finalize(stmt);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="一些方法："><a href="#一些方法：" class="headerlink" title="一些方法："></a>一些方法：</h3><ul>
<li>sqlite3          *db, 数据库句柄，跟文件句柄FILE很类似</li>
<li>sqlite3_stmt      *stmt, 这个相当于ODBC的Command对象，用于保存编译好的SQL语句</li>
<li>sqlite3_open(),   打开数据库，没有数据库时创建。</li>
<li>sqlite3_exec(),   执行非查询的sql语句</li>
<li>sqlite3_step(), 在调用sqlite3_prepare后，使用这个函数在记录集中移动。</li>
<li>sqlite3_close(), 关闭数据库文件</li>
<li>还有一系列的函数，用于从记录集字段中获取数据，如<ul>
<li>sqlite3_column_text(), 取text类型的数据。</li>
<li>sqlite3_column_blob（），取blob类型的数据</li>
<li>sqlite3_column_int(), 取int类型的数据</li>
</ul>
</li>
</ul>
<h3 id="sqlite3数据库打开时的返回值及其所代表的含义"><a href="#sqlite3数据库打开时的返回值及其所代表的含义" class="headerlink" title="sqlite3数据库打开时的返回值及其所代表的含义:"></a>sqlite3数据库打开时的返回值及其所代表的含义:</h3><ul>
<li>SQLITE_OK=0 返回成功</li>
<li>SQLITE_FULL=13 数据库满，插入失败</li>
<li>SQLITE_ERROR=1 Sql错误或错误的数据库</li>
<li>SQLITE_CANTOPEN=14 不能打开数据库文件</li>
<li>SQLITE_INTERNAL=2 Sqlite的内部逻辑错误</li>
<li>SQLITE_PROTOCOL=15 数据库锁定协议错误</li>
<li>SQLITE_PERM=3 拒绝访问</li>
<li>SQLITE_EMPTY=16 数据库表为空</li>
<li>SQLITE_ABORT=4 回调函数请求中断</li>
<li>SQLITE_SCHEMA=17 数据库模式改变</li>
<li>SQLITE_BUSY=5 数据库文件被锁</li>
<li>SQLITE_TOOBIG=18 一个表数据行过多</li>
<li>SQLITE_LOCKED=6 数据库中的一个表被锁</li>
<li>SQLITE_CONSTRAINT=19 由于约束冲突而中止</li>
<li>SQLITE_NOMEN=7 内存分配失败</li>
<li>SQLITE_MISMATCH=20 数据类型不匹配</li>
<li>SQLITE_READONLY=8 试图对一个只读数据库进行写操作</li>
<li>SQLITE_MISUSE=21 数据库错误使用</li>
<li>SQLITE_INTERRUPT=9 由sqlite_interrupt()结束操作</li>
<li>SQLITE_NOLFS=22 使用主机操作系统不支持的特性</li>
<li>SQLITE_IOERR=10 磁盘I/O发生错误</li>
<li>SQLITE_AUTH=23 非法授权</li>
<li>SQLITE_CORRUPT=11 数据库磁盘镜像畸形</li>
<li>SQLITE_FORMAT=24 辅助数据库格式错误</li>
<li>SQLITE_NOTFOUND=12（Internal Only）表或记录不存在</li>
<li>SQLITE_NOTADB=26 打开的不是一个数据库文件</li>
</ul>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub精选分享第一期</title>
    <url>/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<p>记录这周值得分享的事，主要是GitHub精选 前端相关~</p>
<h3 id="向你的Hexo里放上一只萌萌哒二次元看板娘"><a href="#向你的Hexo里放上一只萌萌哒二次元看板娘" class="headerlink" title="向你的Hexo里放上一只萌萌哒二次元看板娘!"></a><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">向你的Hexo里放上一只萌萌哒二次元看板娘!</a></h3><p><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener"><img src="https://huaji8.top/img/hexo%E7%9A%84live2d%E6%8F%92%E4%BB%B6/live2d%20z16.jpg" alt></a></p>
<blockquote class="blockquote-center"><p>可以在hexo博客右下角添加live2D角色<br><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">看板娘列表</a></p>
</blockquote>
<a id="more"></a>
<h3 id="How-JavaScript-works"><a href="#How-JavaScript-works" class="headerlink" title="How JavaScript works"></a><a href="https://blog.sessionstack.com/tagged/tutorial" target="_blank" rel="noopener">How JavaScript works</a></h3><p><a href="https://blog.sessionstack.com/tagged/tutorial" target="_blank" rel="noopener"><img src="https://cdn-images-1.medium.com/max/800/1*lMBu87MtEsVFqqbfMum-kA.png" alt></a></p>
<p>系列博客包含：语言引擎，运行时和调用栈概述；如何在 V8 引擎中书写最优代码的 5 条小技巧；内存管理及如何处理 4 类常见的内存泄漏；事件循环及异步编程的出现和 5 种更好的 async/await 编程方式；深入理解 WebSockets 和带有 SSE 机制的HTTP/2 以及正确的使用姿势；WebAssembly 对比 JavaScript 及其使用场景；Web Workers 分类及 5 个使用场景；Service Workers，生命周期及其使用场景；网页消息推送通知机制；使用 MutationObserver 监测 DOM 变化；渲染引擎及性能优化小技巧；解析，语法抽象树及最小化解析时间的 5 条小技巧 ……</p>
<h3 id="构建时预渲染：网页首帧优化实践"><a href="#构建时预渲染：网页首帧优化实践" class="headerlink" title="构建时预渲染：网页首帧优化实践"></a><a href="https://tech.meituan.com/first_contentful_paint_practice.html" target="_blank" rel="noopener">构建时预渲染：网页首帧优化实践</a></h3><p><a href="https://tech.meituan.com/first_contentful_paint_practice.html" target="_blank" rel="noopener"><img src="https://tech.meituan.com/img/shanghanyang/03.png" alt></a></p>
<blockquote class="blockquote-center"><p>美团技术团队在“首屏白屏”问题上的优化实践</p>
</blockquote>
<h3 id="style2paints-自动上色"><a href="#style2paints-自动上色" class="headerlink" title="style2paints 自动上色"></a><a href="https://github.com/lllyasviel/style2paints" target="_blank" rel="noopener">style2paints 自动上色</a></h3><p><a href="https://github.com/lllyasviel/style2paints" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/lllyasviel/style2paints/master/temps/show/5.jpg" alt></a></p>
<p>AI 漫画稿在线上色工具，通过人工智能，将线稿的风格转换为彩色漫画风格。该项目同时提供了在线体验网站根据不同的涂色风格，获得各种上色图片。特别值得关注的是该项目由苏州大学发布，是中国科研机构在本列表中排名最高的项目。</p>
<h3 id="深度学习助力前端开发：自动生成GUI图代码"><a href="#深度学习助力前端开发：自动生成GUI图代码" class="headerlink" title="深度学习助力前端开发：自动生成GUI图代码"></a><a href="https://github.com/tonybeltramelli/pix2code" target="_blank" rel="noopener">深度学习助力前端开发：自动生成GUI图代码</a></h3><p><a href="https://github.com/tonybeltramelli/pix2code" target="_blank" rel="noopener"><img src="http://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9RgiagIibfo1J7QcMtpOpVmrnM15s2ynV7Vbd2QnRrhibUYWFibSicaJTSNYxVyxHoxQO9tfN7OXWOM2A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt></a></p>
<p>哥本哈根的一家初创公司 UIzard Technologies 训练了一个神经网络，能够把图形用户界面的截图转译成代码行，成功为开发者们分担了部分网站设计流程。令人惊叹的是，同一个模型能跨平台工作，包括 iOS、Android 和 Web 界面，从目前的研发水平来看，该算法的准确率达到了 77%。 详细可以看这篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&amp;mid=2650728064&amp;idx=1&amp;sn=adb744e599299916faa23545c2ab436e&amp;chksm=871b22feb06cabe83ba0e3268a7a8c0c486cf6f42427ab41814e69242f919b25bc7de06ea258&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器之心-深度学习助力前端开发：自动生成GUI图代码（附试用地址）</a></p>
<h3 id="深度学习500问"><a href="#深度学习500问" class="headerlink" title="深度学习500问"></a><a href="https://github.com/scutan90/DeepLearning-500-questions" target="_blank" rel="noopener">深度学习500问</a></h3><p><a href="https://github.com/scutan90/DeepLearning-500-questions" target="_blank" rel="noopener"><img src="/res/weeklyshare/DeepLearning-500-questions.png" alt></a></p>
<p>深度学习500问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。 全书分为18个章节，近30万字。由于水平有限，书中不妥之处恳请广大读者批评指正。 未完待续…..</p>
]]></content>
      <categories>
        <category>每周分享</category>
      </categories>
  </entry>
  <entry>
    <title>InjectionIII 使用原理介绍</title>
    <url>/essay/injectIII/</url>
    <content><![CDATA[<blockquote>
<p>iOS 原生代码的编译调试，都是通过一遍又一遍地编译重启 APP来进行的。所以项目代码量越大，编译时间就越长。虽然我们可以将部分代码先编译成二进制集成到工程里，来避免每次都全量编译来加快编译速度，但即使这样，每次编译都还是需要重启App，需要再走一遍调试流程。</p>
</blockquote>
<p>幸运的是，John Holdsworth 开发了一个叫做 InjectionIII 的工具可以动态地将 Swift 或 Objective-C 的代码在已运行的程序中执行，以加快调试速度，同时保证程序不用重启。</p>
<a id="more"></a>
<h3 id="InjectionIII下载使用"><a href="#InjectionIII下载使用" class="headerlink" title="InjectionIII下载使用"></a>InjectionIII下载使用</h3><h4 id="下载InjectionIII"><a href="#下载InjectionIII" class="headerlink" title="下载InjectionIII"></a>下载InjectionIII</h4><p>如果仅用于使用的话在mac appStore下载就可以了：</p>
<p><img src="/res/InjectionIII/1.png" width="50%"></p>
<h4 id="在项目中添加代码"><a href="#在项目中添加代码" class="headerlink" title="在项目中添加代码"></a>在项目中添加代码</h4><p>在 - (BOOL)application:(UIApplication <em>)application willFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 方法里添加如下代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    [[<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@"/Applications/InjectionIII.app/Contents/Resources/iOSInjection.bundle"</span>] load;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//成功时控制台会打印：</span><br><span class="line">💉 Injection connected 👍</span><br><span class="line"></span><br><span class="line">//没有运行InjectionIII 控制台会打印</span><br><span class="line">💉 Injection loaded but could not connect. Is InjectionIII.app running?</span><br></pre></td></tr></table></figure>
<h4 id="运行InjectionIII-并选择项目目录"><a href="#运行InjectionIII-并选择项目目录" class="headerlink" title="运行InjectionIII 并选择项目目录"></a>运行InjectionIII 并选择项目目录</h4><p>使用的时候会让你选择项目目录，InjectionIII 就是监控的这个目录，里面文件变动会有通知。</p>
<p><img src="/res/InjectionIII/2.png" width="50%"></p>
<h4 id="使用InjectionIII-并测试几种场景"><a href="#使用InjectionIII-并测试几种场景" class="headerlink" title="使用InjectionIII 并测试几种场景:"></a>使用InjectionIII 并测试几种场景:</h4><p>你可以在在对应的VC控制器中实现 - (void)injected 编写代码，写完后，command+s 保存切执行代码，Injjection就开始编译修改过的文件为动态库，然后我们在Injected方法内做UI reload工作，即可重绘UI。</p>
<p>也可以直接修改你想测试的VC代码，然后退出重进即可重载VC。</p>
<p>测试一下四种场景： </p>
<ul>
<li>修改方法</li>
<li>新增方法</li>
<li>新增属性</li>
<li>新增类</li>
</ul>
<p>其中 修改方法/新增方法/新增类 都可以动态修改</p>
<p><img src="/res/InjectionIII/3.gif" alt></p>
<p>而当动态添加属性时则会报错</p>
<p><img src="/res/InjectionIII/4.png" width="50%"></p>
<p>我们很自然的想到因为不能向已有类动态添加属性，但是InjectionIII到底做了什么呢？让我们带着疑问来看看InjectionIII的原理</p>
<blockquote>
<p>没有看到效果的问题?</p>
</blockquote>
<ul>
<li>确认 Injection 监听的目录和 Xcode 项目目录是否一致。</li>
<li>再看下有没有保存成功，也就是针筒的颜色由绿色变成红色。</li>
<li>确认上面那句话有没有打印，也就是说有没有真的运行这个工具。</li>
<li>如果修改的是 cell / item 上面的内容，需要上下滚动才能看到效果。</li>
<li>如果修改的是一个普通页面的内容，最好是退出这个页面，再进入这个页面。</li>
<li>确认 Xcode 的版本和启动时添加的代码是否匹配，Xcode10 需要 iOSInjection10.bundle 才能生效</li>
</ul>
<h3 id="InjectionIII原理"><a href="#InjectionIII原理" class="headerlink" title="InjectionIII原理"></a>InjectionIII原理</h3><h4 id="大致流程梳理"><a href="#大致流程梳理" class="headerlink" title="大致流程梳理"></a>大致流程梳理</h4><p><img src="/res/InjectionIII/8.png" alt></p>
<ul>
<li>InjectionIII 分为server 和 client部分，</li>
<li>client部分在你的项目启动的时候会作为 bundle load 进去，server部分在Mac App那边，server 和 client 都会在后台发送和监听 Socket 消息，实现逻辑分别在 InjectionServer.mm 和 InjectionClient.mm 里的 runInBackground 方法里面。</li>
<li>InjectionIII 会监听源代码文件的变化，如果文件被改动了，server 就会通过 Socket 通知 client 进行 rebuildClass 重新对该文件进行编译，打包成动态库，也就是 .dylib 文件。</li>
<li>然后通过 dlopen 把动态库文件载入运行的 App 里，接下来 dlsym 会得到动态库的符号地址，然后就可以处理类的替换工作。</li>
<li>当类的方法被替换后，我们就可以开始重新绘制界面了。整个过程无需重新编译和重载 App，使用动态库方式极速调试的目的就达成了。</li>
</ul>
<p>这里有一点需要说明一下，模拟器下iOS可加载Mac任意文件，而真机设备如果加载动态库，只能加载App.content目录下的，换句话说，这个工具只支持模拟器。</p>
<h4 id="编译InjectionIII工程"><a href="#编译InjectionIII工程" class="headerlink" title="编译InjectionIII工程"></a>编译InjectionIII工程</h4><p>要了解一个工具，最好的方式当然直接看源码了。InjectionIII 的源代码链接如下：<a href="https://github.com/johnno1962/InjectionIII" target="_blank" rel="noopener">https://github.com/johnno1962/InjectionIII</a>，可以下载下来对着源码分析。</p>
<p><img src="/res/InjectionIII/5.png" width="50%"></p>
<p>下载/clone InjectionIII 主工程代码，子工程 remote SwiftTrace XprobePlugin 也一并点进链接下载到对应目录。</p>
<p>然后解决下证书问题 ，直接勾选 Automatically manage signing，同时选择一下团队，注意 InjectionIII 和 InjectionBundle 两个 target 都要选择好。就可以愉快的编译了~</p>
<p>最后说一下，如果我们要用源码分析，当然要将源码编译起来，打断点看流程。这样的话就在 willFinishLaunchingWithOptions 里面加载的路径就要相应修改了，我这边是这样的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#if DEBUG</span></span><br><span class="line">    [[<span class="built_in">NSBundle</span> bundleWithPath:<span class="string">@"/Users/suntongsheng/Library/Developer/Xcode/DerivedData/InjectionIII-aornltecfreqqwezgayglgjnnckg/Build/Products/Debug/InjectionIII.app/Contents/Resources/iOSInjection.bundle"</span>] load];</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="一、初始化Server和Client并通过Socket建立链接"><a href="#一、初始化Server和Client并通过Socket建立链接" class="headerlink" title="一、初始化Server和Client并通过Socket建立链接"></a>一、初始化Server和Client并通过Socket建立链接</h5><p><code>Server端 即是InjectionIII工程中的Target-InjectionIII</code> 初始化调用 SimpleSocket 的 startServer 方法并传入端口号 在后台运行开启服务端socket 服务用于和客户端的通讯，并运行 InjectionServer 类的 runInBackground 方法进行初始化操作，弹出选择项目目录对话框，如果之前选择过的话就不会弹出。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">+ (void)startServer:(<span class="type">NSString</span> *)address &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">" %s %p "</span>,__func__,<span class="keyword">self</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:@selector(runServer:) withObject:address];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)runServer:(<span class="type">NSString</span> *)address &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">serverAddr</span>;</span></span><br><span class="line"><span class="class">    [<span class="title">self</span> <span class="title">parseV4Address</span>:<span class="title">address</span> <span class="title">into</span>:&amp;<span class="title">serverAddr</span>];</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">serverSocket</span> = [<span class="title">self</span> <span class="title">newSocket</span>:<span class="title">serverAddr</span>.<span class="title">ss_family</span>];</span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">serverSocket</span> &lt; 0)</span></span><br><span class="line"><span class="class">        <span class="title">return</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">if</span> (<span class="title">bind</span>(<span class="title">serverSocket</span>, (<span class="title">struct</span> <span class="title">sockaddr</span> *)&amp;<span class="title">serverAddr</span>, <span class="title">serverAddr</span>.<span class="title">ss_len</span>) &lt; 0)</span></span><br><span class="line"><span class="class">        [<span class="title">self</span> <span class="title">error</span>:@"<span class="title">Could</span> <span class="title">not</span> <span class="title">bind</span> <span class="title">service</span> <span class="title">socket</span>: %<span class="title">s</span>"];</span></span><br><span class="line"><span class="class">    <span class="title">else</span> <span class="title">if</span> (<span class="title">listen</span>(<span class="title">serverSocket</span>, 5) &lt; 0)</span></span><br><span class="line"><span class="class">        [<span class="title">self</span> <span class="title">error</span>:@"<span class="title">Service</span> <span class="title">socket</span> <span class="title">would</span> <span class="title">not</span> <span class="title">listen</span>: %<span class="title">s</span>"];</span></span><br><span class="line"><span class="class">    <span class="title">else</span></span></span><br><span class="line"><span class="class">        <span class="title">while</span> (<span class="title">TRUE</span>) </span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class">            <span class="title">socklen_t</span> <span class="title">addrLen</span> = <span class="title">sizeof</span> <span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">            <span class="title">int</span> <span class="title">clientSocket</span> = <span class="title">accept</span>(<span class="title">serverSocket</span>, (<span class="title">struct</span> <span class="title">sockaddr</span> *)&amp;<span class="title">clientAddr</span>, &amp;<span class="title">addrLen</span>);</span></span><br><span class="line"><span class="class">            <span class="title">if</span> (<span class="title">clientSocket</span> &gt; 0) </span>&#123;</span><br><span class="line">                @autoreleasepool &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">v4Addr</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)&amp;<span class="title">clientAddr</span>;</span></span><br><span class="line"><span class="class">                    <span class="title">NSLog</span>(@"<span class="title">Connection</span> <span class="title">from</span> %<span class="title">s</span>:%<span class="title">d</span>\<span class="title">n</span>",</span></span><br><span class="line"><span class="class">                          <span class="title">inet_ntoa</span>(<span class="title">v4Addr</span>-&gt;<span class="title">sin_addr</span>), <span class="title">ntohs</span>(<span class="title">v4Addr</span>-&gt;<span class="title">sin_port</span>));</span></span><br><span class="line"><span class="class">                    [[[<span class="title">self</span> <span class="title">alloc</span>] <span class="title">initSocket</span>:<span class="title">clientSocket</span>] <span class="title">run</span>];</span></span><br><span class="line"><span class="class">                &#125;</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            <span class="title">else</span></span></span><br><span class="line"><span class="class">                [<span class="title">NSThread</span> <span class="title">sleepForTimeInterval</span>:.5];</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Client端 即是InjectionIII工程中的Target-InjectionBundle</code> 会在我们的demo工程中加载，项目启动以后可以在控制台执行 image list -o -f 查看加载的动态库，可以看到 iOSInjection.bundle 确实已经以动态库的形式加载进来了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">image list -o -f</span><br><span class="line"></span><br><span class="line">[377] 0x0000000102b13000 /Users/suntongsheng/Library/Developer/Xcode/DerivedData/InjectionIII-aornltecfreqqwezgayglgjnnckg/Build/Products/Debug/InjectionIII.app/Contents/Resources/iOSInjection.bundle/iOSInjection</span><br></pre></td></tr></table></figure>
<p>其初始化在InjectionClient 类的 +load 方法。在 InjectionClient 类的 +load 方法里会调用其 connectTo 方法传入对应的端口号来连接服务端的 socket 服务用于通讯，并运行其runInBackground 方法进行初始化操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">" %s %p "</span>,__func__,<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// connect to InjectionIII.app using socket</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">InjectionClient</span> *client = [<span class="keyword">self</span> connectTo:<span class="type">INJECTION_ADDRESS</span>])</span><br><span class="line">        [client run];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">"💉 Injection loaded but could not connect. Is InjectionIII.app running?\n"</span>);</span><br><span class="line">#ifndef __IPHONE_OS_VERSION_MIN_REQUIRED</span><br><span class="line">        printf(<span class="string">"⚠️ For a macOS app you need to turn off the sandbox to connect. ⚠️\n"</span>);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InjectionIII 运行以后会在后台监听 socket 消息，每隔0.5秒检查一次是否有客户端连接过来，等我们app 启动以后加载了 iOSInjection.bundle，就会启动 client 跟 server 建立连接，然后就可以发送消息了。</p>
<h5 id="二、监听文件修改"><a href="#二、监听文件修改" class="headerlink" title="二、监听文件修改"></a>二、监听文件修改</h5><p>当我们在调试工程中修改了代码并保存后，FileWatcher 会立即收到文件改变的回调，FileWatcher 使用 Mac OS 上的 FSEvents 框架实现，<code>FileWatcher</code> 中通过 <code>filesChanged</code> 告诉回调方法即<code>InjectionServer</code>中的<code>fileChangeHandler</code>方法</p>
<p><img src="/res/InjectionIII/6.png" alt></p>
<p>在<code>InjectionServer</code>方法中会判断是否为自动注入，如果是则执行 injectPending 方法，通过 socket 对客户端下发InjectionInject 代码注入命令并传入需要代码注入的文件名物理路径。如果不是自动注入那么就在控制台输出“xx文件已保存，输入ctrl-=进行注入”告诉我们手动注入的触发方式。</p>
<h5 id="三、重新编译、打包动态库和签名"><a href="#三、重新编译、打包动态库和签名" class="headerlink" title="三、重新编译、打包动态库和签名"></a>三、重新编译、打包动态库和签名</h5><p>文件修改后若是自动注入<code>injectPending</code>方法会调用 <code>recompileAndInject</code>方法实际上会调用 SwiftEval 单例的 rebuildClass 方法来进行修改文件的重新编译、打包动态库和签名：</p>
<p>首先根据修改的类文件名在 Injection App 的沙盒路径生成对应的编译脚本，脚本命名为eval+数字，数字以100为基数，每次递增1。脚本生成调用方法如下图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">injectionNumber += <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> tmpfile = <span class="type">URL</span>(fileURLWithPath: tmpDir)</span><br><span class="line">    .appendingPathComponent(<span class="string">"eval\(injectionNumber)"</span>).path</span><br><span class="line"><span class="keyword">let</span> logfile = <span class="string">"\(tmpfile).log"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">var</span> (compileCommand, sourceFile) = <span class="keyword">try</span> compileByClass[classNameOrFile] ??</span><br><span class="line">    findCompileCommand(logsDir: logsDir, classNameOrFile: classNameOrFile, tmpfile: tmpfile) ??</span><br><span class="line">    <span class="type">SwiftEval</span>.longTermCache[classNameOrFile].flatMap(&#123; ($<span class="number">0</span> <span class="keyword">as</span>! <span class="type">String</span>, classNameOrFile) &#125;) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> evalError(<span class="string">"""</span></span><br><span class="line"><span class="string">        Could not locate compile command for \(classNameOrFile).</span></span><br><span class="line"><span class="string">        This could be due to one of the following:</span></span><br><span class="line"><span class="string">        1. Injection does not work with Whole Module Optimization.</span></span><br><span class="line"><span class="string">        2. There are restrictions on characters allowed in paths.</span></span><br><span class="line"><span class="string">        3. File paths in the simulator paths are case sensitive.</span></span><br><span class="line"><span class="string">        Try a build clean then rebuild to make logs available or</span></span><br><span class="line"><span class="string">        consult: "\(commandFile)".</span></span><br><span class="line"><span class="string">        """</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 findCompileCommand 为生成 sh 脚本的具体方法，主要是针对当前修改类设置对应的编译脚本命令。由于脚本太长，这里就不贴上来了，有兴趣的同学可以自行查看。</p>
<p>使用改动类的编译脚本可以生成其.o文件，具体如下图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> toolchain = ((<span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: <span class="string">"\\s*(\\S+?\\.xctoolchain)"</span>, options: []))</span><br><span class="line">    .firstMatch(<span class="keyword">in</span>: compileCommand, options: [], range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, compileCommand.utf16.<span class="built_in">count</span>))?</span><br><span class="line">    .range(at: <span class="number">1</span>)).flatMap &#123; compileCommand[$<span class="number">0</span>] &#125; ?? <span class="string">"\(xcodeDev)/Toolchains/XcodeDefault.xctoolchain"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> osSpecific: <span class="type">String</span></span><br><span class="line"><span class="keyword">if</span> compileCommand.<span class="built_in">contains</span>(<span class="string">"iPhoneSimulator.platform"</span>) &#123;</span><br><span class="line">    osSpecific = <span class="string">"-isysroot \(xcodeDev)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk -mios-simulator-version-min=9.0 -L\(toolchain)/usr/lib/swift/iphonesimulator -undefined dynamic_lookup"</span><span class="comment">// -Xlinker -bundle_loader -Xlinker \"\(Bundle.main.executablePath!)\""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里针对模拟器环境进行脚本配置，配置完成后使用 clang 命令把对应的.o文件生成相同名字的动态库，具体如下图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> shell(command: <span class="string">"""</span></span><br><span class="line"><span class="string">    \(xcodeDev)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch "\(arch)" -bundle \(osSpecific) -dead_strip -Xlinker -objc_abi_version -Xlinker 2 -fobjc-arc -fprofile-instr-generate \"\(tmpfile).o\" -L "\(frameworks)" -F "\(frameworks)" -rpath "\(frameworks)" -o \"\(tmpfile).dylib\" &gt;&gt;\"\(logfile)\" 2&gt;&amp;1</span></span><br><span class="line"><span class="string">    """</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> evalError(<span class="string">"Link failed, check \(commandFile)\n\(try! String(contentsOfFile: logfile))"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程中产生的产物如下：</p>
<p><img src="/res/InjectionIII/7.png" width="50%"></p>
<p>苹果会对加载的动态库进行签名校验，所以下一步需要对这个动态库签名,由于签名需要使用 Xcode 环境，所以客户端是无法进行的，只能通过 socket 告诉服务端来进行操作。当服务端收到 InjectionSign 签名命令后会调用 SignerService 类的 codesignDylib 来对相应的动态库进行签名操作</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@implementation <span class="type">SignerService</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)codesignDylib:(<span class="type">NSString</span> *)dylib identity:(<span class="type">NSString</span> *)identity &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">NSString</span> *adhocSign = @<span class="string">"-"</span>;</span><br><span class="line">    <span class="type">NSString</span> *command = [<span class="type">NSString</span> stringWithFormat:@<span class="string">""</span></span><br><span class="line">                         <span class="string">"(export CODESIGN_ALLOCATE=/Applications/Xcode.app"</span></span><br><span class="line">                         <span class="string">"/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate; "</span></span><br><span class="line">                         <span class="string">"if /usr/bin/file \"%@\" | grep ' bundle ' &gt;/dev/null;"</span></span><br><span class="line">                         <span class="string">"then /usr/bin/codesign --force -s \"%@\" \"%@\";"</span></span><br><span class="line">                         <span class="string">"else exit 1; fi)"</span>,</span><br><span class="line">                         dylib, identity ?: adhocSign, dylib];</span><br><span class="line">    <span class="keyword">return</span> system(command.<span class="type">UTF8String</span>) &gt;&gt; <span class="number">8</span> == <span class="type">EXIT_SUCCESS</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)runInBackground &#123;</span><br><span class="line">    char __unused skip, buffer[<span class="number">1000</span>];</span><br><span class="line">    buffer[read(clientSocket, buffer, <span class="built_in">sizeof</span> buffer-<span class="number">1</span>)] = '\<span class="number">000</span>';</span><br><span class="line">    <span class="type">NSString</span> *path = [[<span class="type">NSString</span> stringWithUTF8String:buffer] componentsSeparatedByString:@<span class="string">" "</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">codesignDylib</span>:<span class="title">path</span> <span class="title">identity</span>:<span class="title">nil</span>]) </span>&#123;</span><br><span class="line">        snprintf(buffer, <span class="built_in">sizeof</span> buffer, <span class="string">"HTTP/1.0 200 OK\r\n\r\n"</span>);</span><br><span class="line">        write(clientSocket, buffer, strlen(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>至此修改文件的重新编译、打包动态库和签名操作就全部完成了，接下来就是我们最熟悉的加载动态库进行方法替换了。</p>
<h5 id="四、加载动态库进行方法替换"><a href="#四、加载动态库进行方法替换" class="headerlink" title="四、加载动态库进行方法替换"></a>四、加载动态库进行方法替换</h5><p>在生成动态库后 先使用dlopen方法把对应的动态库加载到当前运行的调试工程的进程中 并拿到返回的指针dl，然后使用dlsym拿到动态库的符号地址。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">loadAndInject</span><span class="params">(tmpfile: String, oldClass: AnyClass? = <span class="literal">nil</span>)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyClass</span>] &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> dl = dlopen(<span class="string">"\(tmpfile).dylib"</span>, <span class="type">RTLD_NOW</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> oldClass != <span class="literal">nil</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// grep out symbols for classes being injected from object file</span></span><br><span class="line">        <span class="comment">//正常流程会走到这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> extractClasses(dl: dl, tmpfile: tmpfile)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overridden by SwiftInjectionEval subclass for injection</span></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">extractClasses</span><span class="params">(dl: UnsafeMutableRawPointer,</span></span></span><br><span class="line"><span class="function"><span class="params">                          tmpfile: String)</span></span> <span class="keyword">throws</span> -&gt; [<span class="type">AnyClass</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> shell(command: <span class="string">"""</span></span><br><span class="line"><span class="string">        \(xcodeDev)/Toolchains/XcodeDefault.xctoolchain/usr/bin/nm \(tmpfile).o | grep -E ' S _OBJC_CLASS_\\$_| _(_T0|\\$S|\\$s).*CN$' | awk '&#123;print $3&#125;' &gt;\(tmpfile).classes</span></span><br><span class="line"><span class="string">        """</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> evalError(<span class="string">"Could not list class symbols"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">var</span> classSymbolNames = (<span class="keyword">try</span>? <span class="type">String</span>(contentsOfFile: <span class="string">"\(tmpfile).classes"</span>))?.components(separatedBy: <span class="string">"\n"</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> evalError(<span class="string">"Could not load class symbol list"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    classSymbolNames.removeLast()</span><br><span class="line">    <span class="keyword">let</span> result =  <span class="type">Set</span>(classSymbolNames.compactMap &#123;</span><br><span class="line">        dlsym(dl, <span class="type">String</span>($<span class="number">0</span>.<span class="built_in">dropFirst</span>())) &#125;)</span><br><span class="line">        .<span class="built_in">map</span> &#123; <span class="built_in">unsafeBitCast</span>($<span class="number">0</span>, to: <span class="type">AnyClass</span>.<span class="keyword">self</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码所示，dlopen 会把 tmpfile 动态库文件载入运行的 App 里，返回指针 dl。回到测试工程使用 <code>lldb image list -o -f</code> 确实看到eval101.dylib 被加载进来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[408] 0x0000000111bfe000 /var/folders/tw/nl7v5_cd577bbdzfgxjy63bw0000gn/T/com.johnholdsworth.InjectionIII/eval101.dylib</span><br></pre></td></tr></table></figure>
<p>接下来， dlsym 会得到 tmpfile 动态库的符号地址，然后就可以处理类的替换工作了。在拿到新类的符号地址后，我们把新类里所有的类方法和实例方法都替换到对应的旧类中，使用的是SwiftInjection 的 injection 方法，通过OC runtime 的class_replaceMethod把整个类的实现方法都替换了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">injection</span><span class="params">(swizzle newClass: AnyClass?, onto oldClass: AnyClass?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> methodCount: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> methods = class_copyMethodList(newClass, &amp;methodCount) &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="type">Int</span>(methodCount) &#123;</span><br><span class="line">            <span class="keyword">let</span> method = method_getName(methods[i])</span><br><span class="line">            <span class="keyword">var</span> replacement = method_getImplementation(methods[i])</span><br><span class="line">            <span class="keyword">if</span> traceInjection, <span class="keyword">let</span> tracer = <span class="type">SwiftTrace</span></span><br><span class="line">                .trace(name: injectedPrefix+<span class="type">NSStringFromSelector</span>(method),</span><br><span class="line">                objcMethod: methods[i], objcClass: newClass,</span><br><span class="line">                original: autoBitCast(replacement)) &#123;</span><br><span class="line">                replacement = autoBitCast(tracer)</span><br><span class="line">            &#125;</span><br><span class="line">            class_replaceMethod(oldClass, method, replacement,</span><br><span class="line">                                method_getTypeEncoding(methods[i]))</span><br><span class="line">        &#125;</span><br><span class="line">        free(methods)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub精选分享第二期</title>
    <url>/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
    <content><![CDATA[<p>记录这周值得分享的事，主要是GitHub精选 前端相关~</p>
<h3 id="edex-ui，一个到随处运行的科幻桌面"><a href="#edex-ui，一个到随处运行的科幻桌面" class="headerlink" title="edex-ui，一个到随处运行的科幻桌面"></a><a href="https://github.com/GitSquared/edex-ui" target="_blank" rel="noopener">edex-ui，一个到随处运行的科幻桌面</a></h3><p><a href="https://github.com/GitSquared/edex-ui" target="_blank" rel="noopener"><img src="https://github.com/GitSquared/edex-ui/raw/master/media/screenshot_default.png"></a></p>
<blockquote class="blockquote-center"><p>eDEX-UI 是一个全屏桌面应用程序，类似于科幻电脑界面，<br>其灵感来自于DEX-UI和TRON Legacy电影特效。<br>它在真实终端中运行您选择的shell，并显示有关系统的实时信息。</p>
</blockquote>
<a id="more"></a>
<h3 id="Howler-js-JavaScript-开发跨平台音频相关的开发"><a href="#Howler-js-JavaScript-开发跨平台音频相关的开发" class="headerlink" title="Howler.js - JavaScript 开发跨平台音频相关的开发 "></a><a href="https://howlerjs.com/" target="_blank" rel="noopener">Howler.js - JavaScript 开发跨平台音频相关的开发 </a></h3><p><a href="https://howlerjs.com/" target="_blank" rel="noopener"><img src="https://howlerjs.com/assets/images/logo-big.svg" width="50%"></a></p>
<blockquote class="blockquote-center"><p>Howler.js提供了一个现代音频库，支持Web Audio API和HTML5 Audio的回退机制。<br>该项目致力于简化与使用 JavaScript 开发跨平台音频相关的开发工作。<br>几家大型技术和媒体公司正在使用 Howler.js，包括谷歌、迪士尼、Mozilla 和乐高。</p>
</blockquote>
<h3 id="NES-css-一款像素风格css库"><a href="#NES-css-一款像素风格css库" class="headerlink" title="NES.css - 一款像素风格css库"></a><a href="https://github.com/BcRikko/NES.css" target="_blank" rel="noopener">NES.css - 一款像素风格css库</a></h3><p><a href="https://github.com/BcRikko/NES.css" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/5305599/49061716-da649680-f254-11e8-9a89-d95a7407ec6a.png" alt></a></p>
<h3 id="33-js-concepts-每个-JavaScript-工程师都应懂的33个概念"><a href="#33-js-concepts-每个-JavaScript-工程师都应懂的33个概念" class="headerlink" title="33-js-concepts  每个 JavaScript 工程师都应懂的33个概念"></a><a href="https://github.com/stephentian/33-js-concepts" target="_blank" rel="noopener">33-js-concepts  每个 JavaScript 工程师都应懂的33个概念</a></h3><p><a href="https://github.com/stephentian/33-js-concepts" target="_blank" rel="noopener"><img src="https://github.com/stephentian/33-js-concepts/raw/master/33_js_concepts.jpg" alt></a></p>
<blockquote class="blockquote-center"><p>这个项目是为了帮助开发者掌握 JavaScript 概念而创立的。<br>在学习（JavaScript）中，可以作为一篇指南。<br>从 调用堆栈 / 原始类型 到 设计模式/代码整洁之道</p>
</blockquote>
<h3 id="30-seconds-of-code-有趣的JS代码片段集合"><a href="#30-seconds-of-code-有趣的JS代码片段集合" class="headerlink" title="30-seconds-of-code 有趣的JS代码片段集合"></a><a href="https://github.com/30-seconds/30-seconds-of-code" target="_blank" rel="noopener">30-seconds-of-code 有趣的JS代码片段集合</a></h3><p><a href="https://github.com/30-seconds/30-seconds-of-code" target="_blank" rel="noopener"><img src="https://github.com/30-seconds/30-seconds-of-code/raw/master/logo.png" alt></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//摘取一段 ： Adapter-ary</span></span><br><span class="line"><span class="comment">//Creates a function that accepts up to n arguments, ignoring any additional arguments.</span></span><br><span class="line"><span class="comment">//Call the provided function, fn, with up to n arguments, </span></span><br><span class="line"><span class="comment">//using Array.prototype.slice(0,n) and the spread operator (...).</span></span><br><span class="line"><span class="keyword">const</span> ary = <span class="function">(<span class="params">fn, n</span>) =&gt;</span> (...args) =&gt; fn(...args.slice(<span class="number">0</span>, n));</span><br></pre></td></tr></table></figure>
<h3 id="scrcpy，-Android屏幕分享与控制"><a href="#scrcpy，-Android屏幕分享与控制" class="headerlink" title="scrcpy， Android屏幕分享与控制"></a><a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener">scrcpy， Android屏幕分享与控制</a></h3><p><a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener"><img src="https://github.com/Genymobile/scrcpy/raw/master/assets/screenshot-debian-600.jpg"></a></p>
<blockquote class="blockquote-center"><p>由 Genymobile 推出的可跨平台的、可自定义码率的、开源的屏幕共享工具。<br>提供了在 USB (或 TCP/IP )上连接的 Android 设备的显示和控制，<br>适用于 GNU/Linux、Windows 和 MacOS 。</p>
</blockquote>
<h3 id="css-animation-101，-css动画示例"><a href="#css-animation-101，-css动画示例" class="headerlink" title="css-animation-101， css动画示例"></a><a href="https://github.com/cssanimation/css-animation-101" target="_blank" rel="noopener">css-animation-101， css动画示例</a></h3><p><a href="https://github.com/cssanimation/css-animation-101" target="_blank" rel="noopener"><img src="https://github.com/cssanimation/css-animation-101/raw/master/images/cover-small.png" alt></a></p>
<blockquote class="blockquote-center"><p>从零开始介绍 CSS 动画开源电子书<br><a href="https://cssanimation.rocks/" target="_blank" rel="noopener">https://cssanimation.rocks/</a></p>
</blockquote>
<h3 id="Dan-Abramov-个人博客"><a href="#Dan-Abramov-个人博客" class="headerlink" title="Dan Abramov 个人博客"></a><a href="https://overreacted.io/" target="_blank" rel="noopener">Dan Abramov 个人博客</a></h3><blockquote class="blockquote-center"><p>Dan Abramov 参与开发过react, redux create-react-app的作者之一</p>
</blockquote>]]></content>
      <categories>
        <category>每周分享</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub精选分享第三期</title>
    <url>/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E4%B8%89%E6%9C%9F/</url>
    <content><![CDATA[<p>记录这周看到值得分享的事，本期就分享点前端可视化相关吧~</p>
<h3 id="lianjia-scrawler-链家二手房租房在线数据，存量房交易服务平台数据"><a href="#lianjia-scrawler-链家二手房租房在线数据，存量房交易服务平台数据" class="headerlink" title="lianjia-scrawler 链家二手房租房在线数据，存量房交易服务平台数据"></a><a href="https://github.com/XuefengHuang/lianjia-scrawler" target="_blank" rel="noopener">lianjia-scrawler 链家二手房租房在线数据，存量房交易服务平台数据</a></h3><a id="more"></a>
<p><a href="https://github.com/XuefengHuang/lianjia-scrawler" target="_blank" rel="noopener"><img src="https://github.com/XuefengHuang/lianjia-scrawler/raw/master/screenshots/homepage_1.png" width="50%"></a></p>
<blockquote class="blockquote-center"><p>该项目提供一个链家网全国房源爬虫工具，数据存储目前支持Mysql,Sqlite和Postgres。非常方便转化成csv等格式文件。<br>详细数据分析教程 <a href="http://www.ershoufangdata.com" target="_blank" rel="noopener">http://www.ershoufangdata.com</a></p>
</blockquote>
<h3 id="D3-一个基于web标准的JavaScript可视化库"><a href="#D3-一个基于web标准的JavaScript可视化库" class="headerlink" title="D3 一个基于web标准的JavaScript可视化库"></a><a href="https://github.com/d3/d3" target="_blank" rel="noopener">D3 一个基于web标准的JavaScript可视化库</a></h3><p><a href="https://github.com/d3/d3" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/722a5cc12c7d40231ebeb8ca6facdc8547e2abf7/68747470733a2f2f64336a732e6f72672f6c6f676f2e737667" alt></a></p>
<blockquote class="blockquote-center"><p>D3 (或者叫 D3.js )是一个基于 web 标准的 JavaScript 可视化库.<br>D3 可以借助 SVG, Canvas 以及 HTML 将你的数据生动的展现出来.<br>D3 结合了强大的可视化交互技术以及数据驱动 DOM 的技术结合起来,<br>让你可以借助于现代浏览器的强大功能自由的对数据进行可视化。</p>
</blockquote>
<h3 id="G2-一套基于可视化编码的图形语法"><a href="#G2-一套基于可视化编码的图形语法" class="headerlink" title="G2 一套基于可视化编码的图形语法"></a><a href="https://github.com/antvis/g2" target="_blank" rel="noopener">G2 一套基于可视化编码的图形语法</a></h3><p><a href="https://github.com/antvis/g2" target="_blank" rel="noopener"><img src="https://antv.alipay.com/assets/image/home/g2/case3.png" alt></a></p>
<blockquote class="blockquote-center"><p>G2 是一套基于可视化编码的图形语法，<br>以数据驱动，具有高度的易用性和扩展性，<br>用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表</p>
</blockquote>
<h3 id="echarts-一个使用JavaScript实现的开源可视化库"><a href="#echarts-一个使用JavaScript实现的开源可视化库" class="headerlink" title="echarts 一个使用JavaScript实现的开源可视化库"></a><a href="https://github.com/apache/incubator-echarts" target="_blank" rel="noopener">echarts 一个使用JavaScript实现的开源可视化库</a></h3><p><a href="https://github.com/apache/incubator-echarts" target="_blank" rel="noopener"><img src="https://github.com/apache/incubator-echarts/raw/master/asset/logo.png?raw=true" alt=" "></a></p>
<blockquote class="blockquote-center"><p>ECharts，一个使用 JavaScript 实现的开源可视化库，<br>可以流畅的运行在 PC 和移动设备上，<br>兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），<br>底层依赖轻量级的矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p>
</blockquote>
<h3 id="three-js-JavaScript-3D-library"><a href="#three-js-JavaScript-3D-library" class="headerlink" title="three.js JavaScript 3D library"></a><a href="https://github.com/mrdoob/three.js" target="_blank" rel="noopener">three.js JavaScript 3D library</a></h3><p><a href="https://github.com/mrdoob/three.js" target="_blank" rel="noopener"><img src="https://threejs.org/files/projects/infinitown.png" alt=" "></a></p>
<blockquote class="blockquote-center"><p>three.js是JavaScript编写的WebGL第三方库。提供了非常多的3D显示功能。T<br>hree.js 是一款运行在浏览器中的 3D 引擎，<br>你可以用它创建各种三维场景，包括了摄影机、光影、材质等各种对象。<br>你可以在它的主页上看到许多精采的演示。</p>
</blockquote>
<h3 id="highcharts-HTML5交互性图表库"><a href="#highcharts-HTML5交互性图表库" class="headerlink" title="highcharts HTML5交互性图表库"></a><a href="https://github.com/highcharts/highcharts" target="_blank" rel="noopener">highcharts HTML5交互性图表库</a></h3><p><a href="https://github.com/highcharts/highcharts" target="_blank" rel="noopener"><img src="https://shop.highsoft.com/media/highsoft/highchart-in-laptop-960x552-optimized.png" alt=" "></a></p>
<blockquote class="blockquote-center"><p>兼容 IE6+、完美支持移动端、图表类型丰富、方便快捷的 HTML5 交互性图表库</p>
</blockquote>
<h3 id="Leaflet-互动地图"><a href="#Leaflet-互动地图" class="headerlink" title="Leaflet 互动地图"></a><a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="noopener">Leaflet 互动地图</a></h3><p><a href="https://github.com/Leaflet/Leaflet" target="_blank" rel="noopener"><img src="https://leafletjs.com/docs/images/logo.png" alt=" "></a></p>
<blockquote class="blockquote-center"><p>Leaflet 是一个为建设移动设备友好的互动地图,而开发的现代的、开源的 JavaScript 库</p>
</blockquote>
<h3 id="mxgraph"><a href="#mxgraph" class="headerlink" title="mxgraph "></a><a href="https://github.com/jgraph/mxgraph" target="_blank" rel="noopener">mxgraph </a></h3><p><a href="https://github.com/jgraph/mxgraph" target="_blank" rel="noopener"><img src="https://jgraph.github.io/mxgraph/docs/images/mxgraph_logo.gif" alt=" "></a></p>
<blockquote class="blockquote-center"><p>mxGraph客户端功能是 一个JavaScript库，<br>通过浏览器与您的图表显示和交互，提供通常所需的所有应用程序 功能以及方便添加自定义功能的高扩展性。<br>mxGraph是专为使用客户端 - 服务器架构而设计，<br>其中的JavaScript库负责与服务器通信交流以及更新图表的状态信息</p>
</blockquote>]]></content>
      <categories>
        <category>每周分享</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub精选分享第四期</title>
    <url>/weekly-share/GitHub%E7%B2%BE%E9%80%89%E5%88%86%E4%BA%AB%E7%AC%AC%E5%9B%9B%E6%9C%9F/</url>
    <content><![CDATA[<p>记录这周看到值得分享的事，本期就分享点图片压缩工具类吧~</p>
<p><img src="/res/weeklyshare/image-tool-stack.png" alt="image-tool-stack"></p>
<p>上图是我的图片处理工具栈，矢量原型 Sketch，位图编辑 Pixelmator，搜集管理 Inboard，压缩优化 JPEGmini、ImageAlpha、ImageOptim。前四个是付费 App，后两个自由开源。</p>
<p>本次主要分享<strong>ImageOptim</strong> <strong>ImageAlpha</strong> <strong>ImageOptim-CLI</strong> 和 <strong>Squoosh</strong><br><a id="more"></a></p>
<h3 id="ImageOptim-JPG图片压缩利器"><a href="#ImageOptim-JPG图片压缩利器" class="headerlink" title="ImageOptim JPG图片压缩利器"></a><a href="https://github.com/ImageOptim/ImageOptim" target="_blank" rel="noopener">ImageOptim JPG图片压缩利器</a></h3><blockquote class="blockquote-center"><p><a href="https://imageoptim.com/mac" target="_blank" rel="noopener">ImageOptim下载链接</a><br>如果你是Mac OS X电脑的使用者，也可试试看另外这一套图片减肥、最佳化工具ImageOptim，它可以支持PNG，JPEG跟GIF等格式的图档，通过内置的PNGOUT、AdvPNG、Pngcrush、OptiPNG、JpegOptim、jpegrescan、jpegtran与Gifsicle等图片最佳化工具，帮我们全自动压缩、缩减图片的大小。</p>
<p>ImageOptim的使用方法也很简单，就是把图片拉到ImageOptim窗口中，它会自动执行最佳化，然后就没了。</p>
</blockquote>
<h3 id="ImageAlpha-PNG图片有损压缩"><a href="#ImageAlpha-PNG图片有损压缩" class="headerlink" title="ImageAlpha PNG图片有损压缩"></a><a href="https://pngmini.com/" target="_blank" rel="noopener">ImageAlpha PNG图片有损压缩</a></h3><blockquote class="blockquote-center"><p><a href="https://pngmini.com/" target="_blank" rel="noopener">ImageAlpha 下载链接</a><br>通过应用有损压缩和转换为更高效的PNG8 + alpha格式，mageAlpha大大减少了24位PNG文件的文件大小（包括alpha透明度）。这些图像与iOS，所有浏览器兼容，甚至在IE6中降级。</p>
<p>通过使用最新的pngquant和pngnq-s9以及Alpha通道感知后处理器，ImageAlpha可以在MacromediaAdobe Fireworks中获得比类似功能更好的质量。</p>
</blockquote>
<h3 id="ImageOptim-CLI-图片压缩工具调用"><a href="#ImageOptim-CLI-图片压缩工具调用" class="headerlink" title="ImageOptim-CLI 图片压缩工具调用"></a><a href="https://github.com/JamieMason/ImageOptim-CLI" target="_blank" rel="noopener">ImageOptim-CLI 图片压缩工具调用</a></h3><p>今天处理的图片较多，想能不能有个自动工作流来解放双手。一搜，恰巧找到了 <a href="https://github.com/JamieMason/ImageOptim-CLI" target="_blank" rel="noopener">JamieMason/ImageOptim-CLI</a> 这个 macOS 项目。一句话描述就是，它会根据你的指定，选择性调用 JPEGmini、ImageAlpha、ImageOptim 等工具，来处理图片压缩问题。开始敲一行命令，中间过程全自动。</p>
<p>79% TypeScript + 21% AppleScript，分发为可执行的二进制包，所以不依赖 Node.js，并且支持 Homebrew 安装。</p>
<p>使用也非常方便，终端输入 imageoptim –help 即可得到说明，只需注意三个事项：第一、终端要取得 Accessibility 权限；第二、调用的 App 要自己另外下载安装；第三、顾名思义，它默认调用 ImageOptim，如果不用，可通过 –no-imageoptim 参数 disable 它。</p>
<p>支持的调用的 3 个 App 如下，JPEGmini Lite 免费，标准和 Pro 均需付费：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Supported Apps:</span><br><span class="line"></span><br><span class="line">  ImageAlpha: https://pngmini.com</span><br><span class="line">  ImageOptim: https://imageoptim.com</span><br><span class="line">  JPEGmini Lite: https://itunes.apple.com/us/app/jpegmini-lite/id525742250</span><br><span class="line">  JPEGmini Pro: https://itunes.apple.com/us/app/jpegmini-pro/id887163276</span><br><span class="line">  JPEGmini: https://itunes.apple.com/us/app/jpegmini/id498944723</span><br></pre></td></tr></table></figure>
<p>如需组合其他工具，添加对应参数即可，比如添加 –jpegmini 参数调用 JPEGmini：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">  # Run ImageOptim.app over every image in current directory</span><br><span class="line">  imageoptim</span><br><span class="line"></span><br><span class="line">  # Run ImageAlpha.app and ImageOptim.app over every PNG in current directory</span><br><span class="line">  imageoptim --imagealpha &apos;**/*.png&apos;</span><br><span class="line"></span><br><span class="line">  # Run JPEGmini.app and ImageOptim.app over every JPG in current directory</span><br><span class="line">  imageoptim --jpegmini &apos;**/*.jpg&apos; &apos;**/*.jpeg&apos;</span><br><span class="line"></span><br><span class="line">  # Run JPEGmini.app over every JPG in current directory</span><br><span class="line">  imageoptim --jpegmini --no-imageoptim &apos;**/*.jpg&apos; &apos;**/*.jpeg&apos;</span><br><span class="line"></span><br><span class="line">  # Run ImageOptim.app over every image in a specific directory</span><br><span class="line">  imageoptim &apos;~/Desktop&apos;</span><br></pre></td></tr></table></figure>
<p>那么，这几个工具是单干还是组合好呢，哪个搭配压缩和质量最合理呢？针对这个问题，ImageOptim-CLI 贴心地给出了 GIF、JPEG、PNG 各个格式各个工具及组合的<a href="https://jamiemason.github.io/ImageOptim-CLI/comparison/all/photoshop/desc/" target="_blank" rel="noopener">压缩效果对比</a></p>
<p><img src="/res/weeklyshare/imageoptim-cli-comparison.png" alt="imageoptim-cli-comparison"></p>
<p>先看 JPEG 项目，果不其然，JPEGmini &amp; ImageOptim 组合几无敌手，只在蓝天白云和 bril 人像上输给了 Kraken，当然，这个成绩主要是 JPEGmini 的功劳。</p>
<p>再看 PNG 项目，悬念只在 ImageOptim 单干以及与 ImageOptim 搭配两个方案之间。考虑到 24 位色的天际线、雀斑脸、蓝天白云等图片上，ImageOptim 单干弱势明显，还是建议二者无脑搭配。ImageAlpha则又是明显。</p>
<p>综合以上两个项目来看，如果能接受较高的图片质量损耗（注意表格中无底色的红字），Kraken 也是非常有竞争力的单一优化工具。</p>
<h3 id="Squoosh-是-Google-推出的一款在线简单高效的图片压缩工具"><a href="#Squoosh-是-Google-推出的一款在线简单高效的图片压缩工具" class="headerlink" title="Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具"></a><a href="https://github.com/GoogleChromeLabs/squoosh" target="_blank" rel="noopener">Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具</a></h3><blockquote class="blockquote-center"><p><a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh在线链接</a><br>Squoosh 是 Google 推出的一款在线简单高效的图片压缩工具，支持 JPG、PNG 和 WebP 格式，可让您深入了解各种图像压缩器提供的高级选项</p>
</blockquote>]]></content>
      <categories>
        <category>每周分享</category>
      </categories>
  </entry>
  <entry>
    <title>重学iOS-知识树大纲</title>
    <url>/quick-start/ReLearning-iOS/</url>
    <content><![CDATA[<p>来京东一年多了，从预想的ipad业务到RN业务，再到现在的iphone业务加RN业务。学习了很多RN、前端相关的知识也遗忘了部分iOS的相关逻辑。<br>现在打算重新回顾学习一下iOS,做一个系列帮助自己重学iOS,带自己还有你重新认识iOS。</p>
<p>在开始画知识树大纲之前，我想先来为这个系列定下一个小规范。本身我们可以网上找到很多参考资料，比如官方开发者文档这样的参考手册。苹果的参考手册做的是很好好全面，但这并不是我们所期望学习的，我想尽量和你一起打造一个iOS知识框架，再把主要的知识点做个遍历，其中主要探讨原理和背景相关的知识点。这样就算遇到了不认识的API知识点，也可以很容易地查阅开发者文档来解决。<br><a id="more"></a><br>我简单做个了一个划分，将iOS知识在总体上分为三个部分：<br><strong>一是基础部分，主要探讨初学者在业务中常遇见知识点和疑惑；</strong><br><img src="/res/reLearningiOS/重学iOS-基础.png" width="80%"></p>
<p><strong>二是深入部分，主要探讨iOS机制原理和比较具体业务倾向的框架应用；</strong><br><img src="/res/reLearningiOS/重学iOS-深入.png" width="80%"><br><strong>三是进阶实践部分，主要探讨业务开发中的难点疑点。</strong><br><img src="/res/reLearningiOS/重学iOS-进阶.png" width="80%"></p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app教程-使用篇</title>
    <url>/quick-start/create-react-app%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>是不是厌倦了每次新建web项目繁琐的配置，想不想只用10秒搭建就搭建一个完整的react项目？ </p>
</blockquote>
<p><img src="/res/create-react-app/1.svg" alt><br><a id="more"></a><br>create-react-app 分为两个部分</p>
<ul>
<li>其中 <code>create-react-app</code>是创建单页面的react脚手架项目脚本 ；</li>
<li>而<code>react-scripts</code>则管理着工程的依赖。</li>
</ul>
<p>如果我们手动创建react web应用程序的时候,要自己通过 npm 或者 yarn 安装项目的全部依赖，再写webpack.config.js,一系列复杂的配置,搭建好开发环境后写src源代码。使用 create-react-app 去自动构建你的app程序, 你的项目无需配置，也没有复杂的目录结构，只有你构建应用所需的文件。省去了很多精力，最适合快速上手一个demo了。</p>
<h2 id="create-react-app-使用"><a href="#create-react-app-使用" class="headerlink" title="create-react-app 使用"></a>create-react-app 使用</h2><p>先来看看如何十秒上手create-react-app!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//my-app 是你要创建的web单页面项目名字</span></span><br><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="comment">//npx 需要 npm 5.2+ </span></span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>输入上述命令后，打开 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 就可以看到初始页面了~</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>接着上面的命令，可以看到生成了如下文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my-app</span><br><span class="line">├── README.md</span><br><span class="line">├── node_modules</span><br><span class="line">├── package.json</span><br><span class="line">├── .gitignore</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">└── src</span><br><span class="line">    ├── App.css</span><br><span class="line">    ├── App.js</span><br><span class="line">    ├── App.test.js</span><br><span class="line">    ├── index.css</span><br><span class="line">    ├── index.js</span><br><span class="line">    ├── logo.svg</span><br><span class="line">    └── serviceWorker.js</span><br></pre></td></tr></table></figure>
<p>public/index.html 是页面模板,src/index.js 则是入口JS文件</p>
<p>其中<code>src</code>目录和 <code>public</code>目录需要注意下。只有在<code>src</code>目录下的文件才会被webpack编译，js和css文件都建议放在此处；而<code>public</code>文件夹则存放着被 public/index.html使用的资源。</p>
<h3 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h3><p>对于喜欢手动创建web项目的人来说，没有webpack的配置很是不习惯啊！我就是要手动配置webpack怎么办？</p>
<p>那就是使用 <a href="https://github.com/timarney/react-app-rewired" target="_blank" rel="noopener">https://github.com/timarney/react-app-rewired</a> 使用<code>react-app-rewired</code> 需要三步：</p>
<p><strong>1)</strong> 安装 react-app-rewired</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install react-app-rewired --save-dev</span><br></pre></td></tr></table></figure>
<p><strong>2)</strong> 在项目根目录创建 <code>config-overrides.js</code>文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* config-overrides.js */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//console.log('原webpack配置 config:',config)</span></span><br><span class="line">  <span class="comment">//在这里修改config就行</span></span><br><span class="line">  <span class="comment">//console.log('修改后webpack配置 config:',config)</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）</strong> 修改package.json中script:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* package.json */</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="comment">//   "start": "react-scripts start",</span></span><br><span class="line">   <span class="string">"start"</span>: <span class="string">"react-app-rewired start"</span>,</span><br><span class="line"><span class="comment">//    "build": "react-scripts build",</span></span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"react-app-rewired build"</span>,</span><br><span class="line"><span class="comment">//   "test": "react-scripts test --env=jsdom",</span></span><br><span class="line">   <span class="string">"test"</span>: <span class="string">"react-app-rewired test --env=jsdom"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="那么如何查看create-react-app自带的依赖配置呢？"><a href="#那么如何查看create-react-app自带的依赖配置呢？" class="headerlink" title="那么如何查看create-react-app自带的依赖配置呢？"></a>那么如何查看<code>create-react-app</code>自带的依赖配置呢？</h4><p>答案就是使用<code>npm run eject</code> 。<code>npm run eject</code>的作用就是将原有隐藏的依赖（比如Webpack, Babel, ESLint等）暴露出来， 请注意这是不可逆的行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//npm run eject执行后 项目下多了这样的文件</span><br><span class="line">//我的create-react-app版本为1.5.2</span><br><span class="line">|-config</span><br><span class="line">    |-jest</span><br><span class="line">        |-cssTransform.js</span><br><span class="line">        |-fileTransform.js</span><br><span class="line">    |-env.js</span><br><span class="line">    |-paths.js</span><br><span class="line">    |-webpack.config.dev.js</span><br><span class="line">    |-webpack.config.prod.js</span><br><span class="line">    |-webpackDevServer.config.js</span><br></pre></td></tr></table></figure>
<p>查看 <code>webpack.config.dev.js</code> 和 <code>webpack.config.prod.js</code> 支持的支持的依赖大致有：</p>
<ul>
<li>React, JSX, ES6, TypeScript 和 Flow 语法支持<ul>
<li><a href="https://facebook.github.io/react/docs/introducing-jsx.html" target="_blank" rel="noopener">JSX</a>, </li>
<li><a href="https://facebook.github.io/create-react-app/docs/adding-flow" target="_blank" rel="noopener">Flow</a></li>
<li><a href="https://facebook.github.io/create-react-app/docs/adding-typescript" target="_blank" rel="noopener">TypeScript</a>.</li>
</ul>
</li>
<li>ES6以外的特性<ul>
<li><a href="https://github.com/rwaldron/exponentiation-operator" target="_blank" rel="noopener">Exponentiation Operator</a> (ES2016).</li>
<li><a href="https://github.com/tc39/ecmascript-asyncawait" target="_blank" rel="noopener">Async/await</a> (ES2017).</li>
<li><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">Object Rest/Spread Properties</a> (ES2018).</li>
<li><a href>Dynamic import() </a>(stage 3 proposal)</li>
<li><a href="https://github.com/tc39/proposal-class-public-fields" target="_blank" rel="noopener">Class Fields and Static Properties</a> (part of stage 3 proposal).</li>
</ul>
</li>
<li>通过Autoprefixer 帮你的css文件自动添加浏览器兼容前缀</li>
<li>快速交互式单元测试运行程序，内置对覆盖率报告的支持。</li>
<li>一个能检查常见错误的实时服务器</li>
<li>打包脚本 能输出带 hashes 和 sourcemaps信息.</li>
<li>使用单个react-script脚本对上面依赖无侵入更新</li>
</ul>
<h3 id="使用sass样式"><a href="#使用sass样式" class="headerlink" title="使用sass样式"></a>使用sass样式</h3><p>在create-react-app中使用 Sass需要以下步骤：</p>
<p><strong>1)</strong> 安装 <code>node-sass</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install node-sass --save</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn add node-sass</span><br></pre></td></tr></table></figure>
<p>现在你可以重命名 <code>src/App.css</code> 为 <code>src/App.scss</code>然后在 <code>src/App.js</code>中更新为 <code>import src/App.scss</code> ,.scss 或 .sass 后缀的文件会自动被编译。</p>
<h3 id="使用-Bootstrap"><a href="#使用-Bootstrap" class="headerlink" title="使用 Bootstrap"></a>使用 Bootstrap</h3><p>你可以尝试使用下<a href="https://reactstrap.github.io/" target="_blank" rel="noopener">reactstrap</a>, 这是一个流行的整合bootstrap和react的库。</p>
<p><strong>1）</strong> 安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save reactstrap bootstrap@4</span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">yarn add bootstrap@4 reactstrap</span><br></pre></td></tr></table></figure>
<p><strong>2）</strong> 在你的src/index.js 文件内容的顶部，导入 Bootstrap CSS 和可选的 Bootstrap theme CSS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'bootstrap/dist/css/bootstrap.css'</span>;  <span class="comment">// 必须的 </span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'bootstrap/dist/css/bootstrap-theme.css'</span>;  <span class="comment">//  可选的</span></span><br></pre></td></tr></table></figure>
<p><strong>3）</strong> 使用 reactstrap 组件 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Grid, Navbar, Jumbotron, Button &#125; <span class="keyword">from</span> <span class="string">'react-bootstrap'</span>;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center"><p>会在之后的 <a href="../create-react-app教程-源码篇/">create-react-app教程-源码篇</a> 中介绍create-react-app的源码</p>
</blockquote>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>create-react-app教程</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>create-react-app教程-源码篇</title>
    <url>/quick-start/create-react-app%E6%95%99%E7%A8%8B-%E6%BA%90%E7%A0%81%E7%AF%87/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>之前在 <a href="../create-react-app教程-使用篇/">create-react-app教程-使用篇</a> 中介绍了create-react-app的基本使用，<br>为了便于理解一个脚手架脚本是如何运作的，现在来看一下 create-react-app v1.5.2 的源码</p>
</blockquote>
<h2 id="入口index-js"><a href="#入口index-js" class="headerlink" title="入口index.js"></a>入口index.js</h2><p>create-react-app 一般会作为全局命令，因为便于更新等原因，create-react-app 只会做初始化仓库 执行当前版本命令等操作。</p>
<p>找到 <code>create-react-app</code> 入口index文件：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="comment">// 返回Node版本信息，如果有多个版本返回多个版本</span></span><br><span class="line"><span class="keyword">var</span> currentNodeVersion = process.versions.node; </span><br><span class="line"><span class="keyword">var</span> semver = currentNodeVersion.split(<span class="string">'.'</span>);</span><br><span class="line"><span class="keyword">var</span> major = semver[<span class="number">0</span>];<span class="comment">// 取出第一个Node版本信息</span></span><br><span class="line"><span class="comment">//小于 4.x的提示并终止程序</span></span><br><span class="line"><span class="keyword">if</span> (major &lt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    chalk.red(</span><br><span class="line">      <span class="string">'You are running Node '</span> +</span><br><span class="line">        currentNodeVersion +</span><br><span class="line">        <span class="string">'.\n'</span> +</span><br><span class="line">        <span class="string">'Create React App requires Node 4 or higher. \n'</span> +</span><br><span class="line">        <span class="string">'Please update your version of Node.'</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有小于4就引入以下文件继续执行</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./createReactApp'</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到 index 文件没有做什么，只是做为一个入口文件判断一下 node版本，小于 4.x的提示并终止程序， 如果正常则加载 ./createReactApp 这个文件，主要的逻辑在该文件实现。</p>
<h2 id="createReactApp-js"><a href="#createReactApp-js" class="headerlink" title="createReactApp.js"></a>createReactApp.js</h2><p>虽然 createReactApp.js 有751行，但是里面有一大半是注释和错误友好信息。</p>
<p>除了声明的依赖。跟着执行顺序先看到的是第56行 <code>program</code>  ，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> commander.Command(packageJson.name)</span><br><span class="line">  .version(packageJson.version)<span class="comment">// create-react-app -v 时输出 $&#123;packageJson.version&#125;</span></span><br><span class="line">  .arguments(<span class="string">'&lt;project-directory&gt;'</span>)<span class="comment">// 这里用&lt;&gt; 包着project-directory 表示 project-directory为必填项</span></span><br><span class="line">  .usage(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span> [options]`</span>)<span class="comment">// 用绿色字体输出 &lt;project-directory&gt;</span></span><br><span class="line">  .action(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    projectName = name;</span><br><span class="line">  &#125;)<span class="comment">// 获取用户传入的第一个参数作为 projectName</span></span><br><span class="line">  .option(<span class="string">'--verbose'</span>, <span class="string">'print additional logs'</span>)</span><br><span class="line">  <span class="comment">// option用于配置`create-react-app -[option]`的选项，</span></span><br><span class="line">  <span class="comment">//比如这里如果用户参数带了 --verbose， 会自动设置program.verbose = true;</span></span><br><span class="line">  .option(<span class="string">'--info'</span>, <span class="string">'print environment debug info'</span>)</span><br><span class="line">  <span class="comment">// info，用于打印出环境调试的版本信息</span></span><br><span class="line">  .option(</span><br><span class="line">    <span class="string">'--scripts-version &lt;alternative-package&gt;'</span>,</span><br><span class="line">    <span class="string">'use a non-standard version of react-scripts'</span></span><br><span class="line">  )</span><br><span class="line">  .option(<span class="string">'--use-npm'</span>)<span class="comment">// 默认使用`yarn`，指定使用`npm`</span></span><br><span class="line">  .allowUnknownOption()</span><br><span class="line">  .on(<span class="string">'--help'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//help 信息</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .parse(process.argv);<span class="comment">// 解析传入的参数</span></span><br></pre></td></tr></table></figure>
<p>这里用到 <code>commander</code> 的依赖，这是 node.js 命令行接口的解决方案，正如我们所看到的 处理用户输入的参数，输出友好的提示信息等。</p>
<p>接着到了第109行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有输入projectName的话,输出一些提示信息就终止程序</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> projectName === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (program.info) &#123;<span class="comment">// 如果参数输入了 --info,就会进入这里</span></span><br><span class="line">    envinfo.print(&#123;<span class="comment">// envinfo 是一个用来输出当前环境系统的而一些系统信息</span></span><br><span class="line">      packages: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-scripts'</span>],</span><br><span class="line">      noNativeIDE: <span class="literal">true</span>,</span><br><span class="line">      duplicates: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//略去部分log...</span></span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 projectName 就是我们要创建的web应用名称，如果没有输入的话,输出一些提示信息就终止程序。</p>
<h3 id="createApp-检测判断"><a href="#createApp-检测判断" class="headerlink" title="createApp 检测判断"></a>createApp 检测判断</h3><p>然后到了第148行 执行<code>createApp</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createApp(</span><br><span class="line">  projectName,<span class="comment">//项目名称 </span></span><br><span class="line">  program.verbose, <span class="comment">//是否暑促额外信息</span></span><br><span class="line">  program.scriptsVersion, <span class="comment">//传入的脚本版本</span></span><br><span class="line">  program.useNpm, <span class="comment">//是否使用npm</span></span><br><span class="line">  hiddenProgram.internalTestingTemplate <span class="comment">//调试的模板路径，这个不管它，给开发人员调试用的……</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">name, verbose, version, useNpm, template</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = path.resolve(name);<span class="comment">// 获取当前进程运行的位置，也就是文件目录的绝对路径</span></span><br><span class="line">  <span class="keyword">const</span> appName = path.basename(root);<span class="comment">// 返回root路径下最后一部分</span></span><br><span class="line"></span><br><span class="line">  checkAppName(appName);<span class="comment">// 检查传入的项目名合法性</span></span><br><span class="line">  fs.ensureDirSync(name);<span class="comment">//这里的 fs = require('fs-extra');</span></span><br><span class="line">  <span class="keyword">if</span> (!isSafeToCreateProjectIn(root, name)) &#123;</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入 package.json 文件</span></span><br><span class="line">  <span class="keyword">const</span> packageJson = &#123;</span><br><span class="line">    name: appName,</span><br><span class="line">    version: <span class="string">'0.1.0'</span>,</span><br><span class="line">    private: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    path.join(root, <span class="string">'package.json'</span>),</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(packageJson, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> useYarn = useNpm ? <span class="literal">false</span> : shouldUseYarn();</span><br><span class="line">  <span class="keyword">const</span> originalDirectory = process.cwd();</span><br><span class="line">  process.chdir(root);<span class="comment">// 在这里就把进程目录修改为了我们创建的目录</span></span><br><span class="line">  <span class="comment">// 如果是使用npm，检查npm是否能正常执行</span></span><br><span class="line">  <span class="keyword">if</span> (!useYarn &amp;&amp; !checkThatNpmCanReadCwd()) &#123;</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这里的 semver = require('semver'); 做版本处理的</span></span><br><span class="line">  <span class="comment">//如果node版本不符合要求就使用旧版本的 react-scripts</span></span><br><span class="line">  <span class="keyword">if</span> (!semver.satisfies(process.version, <span class="string">'&gt;=6.0.0'</span>)) &#123;</span><br><span class="line">    <span class="comment">//略去log信息...</span></span><br><span class="line">    <span class="comment">// Fall back to latest supported react-scripts on Node 4</span></span><br><span class="line">    version = <span class="string">'react-scripts@0.9.x'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果npm版本小于3.x，使用旧版的 react-scripts</span></span><br><span class="line">  <span class="keyword">if</span> (!useYarn) &#123;</span><br><span class="line">    <span class="keyword">const</span> npmInfo = checkNpmVersion();</span><br><span class="line">    <span class="keyword">if</span> (!npmInfo.hasMinNpm) &#123;</span><br><span class="line">      <span class="comment">//略去log信息...</span></span><br><span class="line">      <span class="comment">// Fall back to latest supported react-scripts for npm 3</span></span><br><span class="line">      version = <span class="string">'react-scripts@0.9.x'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断结束之后，执行 run 方法</span></span><br><span class="line">  run(root, appName, version, verbose, originalDirectory, template, useYarn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以了解到 createApp 主要做的事情就是做一些安全判断比如：检查项目名是否合法，检查新建的话是否安全，检查npm版本，处理react-script的版本兼容。然后看下在<code>createApp</code>中用到的 <code>checkAppName</code></p>
<h4 id="checkAppName-检查项目名"><a href="#checkAppName-检查项目名" class="headerlink" title="checkAppName 检查项目名"></a>checkAppName 检查项目名</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAppName</span>(<span class="params">appName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里 validateProjectName = require('validate-npm-package-name');</span></span><br><span class="line">  <span class="comment">//可以用来判断当前的项目名是否符合npm规范 比如不能大写等</span></span><br><span class="line">  <span class="keyword">const</span> validationResult = validateProjectName(appName);</span><br><span class="line">  <span class="comment">// 判断是否符合npm规范如果不符合，输出提示并结束任务</span></span><br><span class="line">  <span class="keyword">if</span> (!validationResult.validForNewPackages) &#123;</span><br><span class="line">    <span class="comment">//略去log信息...</span></span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dependencies = [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-scripts'</span>].sort();</span><br><span class="line">  <span class="comment">// 判断是否重名，如果重名则输出提示并结束任务</span></span><br><span class="line">  <span class="keyword">if</span> (dependencies.indexOf(appName) &gt;= <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="comment">//略去log信息...</span></span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="run-安装依赖拷贝模版"><a href="#run-安装依赖拷贝模版" class="headerlink" title="run 安装依赖拷贝模版"></a>run 安装依赖拷贝模版</h3><p>在 createApp 方法体内调用了run方法，run方法体内完成主要的安装依赖 拷贝模板等功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">root,appName,version,verbose,originalDirectory,template,useYarn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里获取要安装的package，</span></span><br><span class="line">  <span class="comment">//    getInstallPackage 默认情况下packageToInstall是 `react-scripts`。</span></span><br><span class="line">  <span class="comment">//    也可能是根据去本地拿到对应的package</span></span><br><span class="line">  <span class="comment">//    react-scripts是一系列的webpack配置与模版</span></span><br><span class="line">  <span class="keyword">const</span> packageToInstall = getInstallPackage(version, originalDirectory);</span><br><span class="line">  <span class="comment">// 需要安装所有的依赖</span></span><br><span class="line">  <span class="keyword">const</span> allDependencies = [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, packageToInstall];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getPackageName 获取依赖包原始名称并返回</span></span><br><span class="line">  getPackageName(packageToInstall)</span><br><span class="line">    .then(<span class="function"><span class="params">packageName</span> =&gt;</span></span><br><span class="line">      <span class="comment">// 如果是yarn,判断是否在线模式（对应的就是离线模式），处理完判断就返回给下一个then处理</span></span><br><span class="line">      checkIfOnline(useYarn).then(<span class="function"><span class="params">isOnline</span> =&gt;</span> (&#123;</span><br><span class="line">        isOnline: isOnline,</span><br><span class="line">        packageName: packageName,</span><br><span class="line">      &#125;))</span><br><span class="line">    )</span><br><span class="line">    .then(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> isOnline = info.isOnline;</span><br><span class="line">      <span class="keyword">const</span> packageName = info.packageName;</span><br><span class="line">      <span class="comment">//略去log信息...      </span></span><br><span class="line">      <span class="comment">//传参数给install 负责安装 allDependencies</span></span><br><span class="line">      <span class="keyword">return</span> install(root, useYarn, allDependencies, verbose, isOnline).then(</span><br><span class="line">        () =&gt; packageName</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">packageName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//检查当前环境运行的node版本是否符合要求</span></span><br><span class="line">      checkNodeVersion(packageName);</span><br><span class="line">      <span class="comment">//修改react, react-dom的版本信息，将准确版本信息改为高于等于版本</span></span><br><span class="line">      <span class="comment">//    例如 15.0.0 =&gt; ^15.0.0</span></span><br><span class="line">      setCaretRangeForRuntimeDeps(packageName);</span><br><span class="line">      <span class="comment">// `react-scripts`脚本的目录</span></span><br><span class="line">      <span class="keyword">const</span> scriptsPath = path.resolve(</span><br><span class="line">        process.cwd(),</span><br><span class="line">        <span class="string">'node_modules'</span>,</span><br><span class="line">        packageName,</span><br><span class="line">        <span class="string">'scripts'</span>,</span><br><span class="line">        <span class="string">'init.js'</span></span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> init = <span class="built_in">require</span>(scriptsPath);</span><br><span class="line">      <span class="comment">//调用安装了的 react-scripts/script/init 去拷贝模版</span></span><br><span class="line">      init(root, appName, verbose, originalDirectory, template);</span><br><span class="line">      <span class="comment">//略去log信息...  </span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 出错的话，把安装了的文件全删了 并输出一些日志信息等</span></span><br><span class="line">      <span class="comment">// 错误处理 略</span></span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以猜到其中最重要的逻辑是 <code>install</code> 安装依赖和 <code>init</code> 拷贝模板。</p>
<h3 id="install-安装依赖"><a href="#install-安装依赖" class="headerlink" title="install  安装依赖"></a>install  安装依赖</h3><p>install 方法体中是根据参数拼装命令行，然后用node去跑安装脚本 ，执行完成后返回一个 Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">root, useYarn, dependencies, verbose, isOnline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> command;</span><br><span class="line">    <span class="keyword">let</span> args;</span><br><span class="line">    <span class="comment">// 参数拼装命令行，</span></span><br><span class="line">    <span class="comment">//    例如 使用yarn ： `yarn add react react-dom`</span></span><br><span class="line">    <span class="comment">//    或 使用npm ： `npm install react react-dom --save` </span></span><br><span class="line">    <span class="keyword">if</span> (useYarn) &#123;</span><br><span class="line">      command = <span class="string">'yarnpkg'</span>;</span><br><span class="line">      args = [<span class="string">'add'</span>, <span class="string">'--exact'</span>];</span><br><span class="line">      <span class="keyword">if</span> (!isOnline) &#123;</span><br><span class="line">        args.push(<span class="string">'--offline'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      [].push.apply(args, dependencies);</span><br><span class="line">      args.push(<span class="string">'--cwd'</span>);</span><br><span class="line">      args.push(root);</span><br><span class="line">      <span class="comment">//略去log信息... </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      command = <span class="string">'npm'</span>;</span><br><span class="line">      args = [</span><br><span class="line">        <span class="string">'install'</span>,</span><br><span class="line">        <span class="string">'--save'</span>,</span><br><span class="line">        <span class="string">'--save-exact'</span>,</span><br><span class="line">        <span class="string">'--loglevel'</span>,</span><br><span class="line">        <span class="string">'error'</span>,</span><br><span class="line">      ].concat(dependencies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">      args.push(<span class="string">'--verbose'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后用node去跑安装脚本 </span></span><br><span class="line">    <span class="comment">//这里 spawn = require('cross-spawn'); 出来处理平台差异</span></span><br><span class="line">    <span class="keyword">const</span> child = spawn(command, args, &#123; <span class="attr">stdio</span>: <span class="string">'inherit'</span> &#125;);</span><br><span class="line">    child.on(<span class="string">'close'</span>, code =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">        reject(&#123;</span><br><span class="line">          command: <span class="string">`<span class="subst">$&#123;command&#125;</span> <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>`</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="init-拷贝模板"><a href="#init-拷贝模板" class="headerlink" title="init 拷贝模板"></a><code>init</code> 拷贝模板</h3><p>init 方法默认是在 【当前web项目路径】/node_modules/react-scripts/script/init.js 中 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  appPath,</span></span></span><br><span class="line"><span class="function"><span class="params">  appName,</span></span></span><br><span class="line"><span class="function"><span class="params">  verbose,</span></span></span><br><span class="line"><span class="function"><span class="params">  originalDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">  template</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ownPath = path.dirname(</span><br><span class="line">    <span class="built_in">require</span>.resolve(path.join(__dirname, <span class="string">'..'</span>, <span class="string">'package.json'</span>))</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> appPackage = <span class="built_in">require</span>(path.join(appPath, <span class="string">'package.json'</span>));</span><br><span class="line">  <span class="keyword">const</span> useYarn = fs.existsSync(path.join(appPath, <span class="string">'yarn.lock'</span>));</span><br><span class="line">  appPackage.dependencies = appPackage.dependencies || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> useTypeScript = appPackage.dependencies[<span class="string">'typescript'</span>] != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置package.json 中 scripts/eslint/browserslist 信息</span></span><br><span class="line">  appPackage.scripts = &#123;</span><br><span class="line">    start: <span class="string">'react-scripts start'</span>,</span><br><span class="line">    build: <span class="string">'react-scripts build'</span>,</span><br><span class="line">    test: <span class="string">'react-scripts test'</span>,</span><br><span class="line">    eject: <span class="string">'react-scripts eject'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  appPackage.eslintConfig = &#123;</span><br><span class="line">    extends: <span class="string">'react-app'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  appPackage.browserslist = defaultBrowsers;</span><br><span class="line"></span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    path.join(appPath, <span class="string">'package.json'</span>),</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(appPackage, <span class="literal">null</span>, <span class="number">2</span>) + os.EOL</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已有 README.md 则重命名</span></span><br><span class="line">  <span class="keyword">const</span> readmeExists = fs.existsSync(path.join(appPath, <span class="string">'README.md'</span>));</span><br><span class="line">  <span class="keyword">if</span> (readmeExists) &#123;</span><br><span class="line">    fs.renameSync(</span><br><span class="line">      path.join(appPath, <span class="string">'README.md'</span>),</span><br><span class="line">      path.join(appPath, <span class="string">'README.old.md'</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把预设的模版拷贝到项目下</span></span><br><span class="line">  <span class="comment">//  可以在 react-scripts/template 看到这些文件 public目录 src目录 gitignore README.md</span></span><br><span class="line">  <span class="keyword">const</span> templatePath = template</span><br><span class="line">    ? path.resolve(originalDirectory, template)</span><br><span class="line">    : path.join(ownPath, useTypeScript ? <span class="string">'template-typescript'</span> : <span class="string">'template'</span>);</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(templatePath)) &#123;</span><br><span class="line">    fs.copySync(templatePath, appPath);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Could not locate supplied template: <span class="subst">$&#123;chalk.green(templatePath)&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果发现没有安装react和react-dom,重新安装一次 代码略</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install additional template dependencies, if present</span></span><br><span class="line">  <span class="comment">//略去log信息... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简化一下逻辑这里的主要内容就是 修改package.json信息和拷贝模板文件</p>
<p>~END~</p>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>create-react-app教程</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化D3教程-快速开始</title>
    <url>/quick-start/d3-tutorials-quickstart/</url>
    <content><![CDATA[<blockquote>
<p>最近想开个可视化的坑，就看到了 <a href="https://github.com/d3/d3" target="_blank" rel="noopener">D3</a> , 别问为什么不选择echarts、Highcharts之类的，老夫写代码就看star数最多的……<br>D3 的全称是（Data-Driven Documents）, D3 将生成可视化的复杂步骤精简到了几个简单的函数，你只需要输入几个简单的数据，就能够转换为各种绚丽的图形。<br>咋一看d3首页 被其凌乱的文档折服了 差点就完成了就入门到放弃，于是做个学习过程记录，帮助一起入门d3的大家^_^</p>
</blockquote>
<a id="more"></a>
<p>本文快速上手先来画出这样一个图形：</p>
<p><img src="/res/d3/quick-start-2.png" width="33%"></p>
<p>迫于只会 React  之后的代码里可能会出现 react相关知识，但是只会vue的同学不用着急 重点相关的都是 d3 ，都可以看得懂得啦~ 废话不多说，让我们快速上手d3吧。</p>
<h3 id="引入d3"><a href="#引入d3" class="headerlink" title="引入d3"></a>引入d3</h3><p>引入d3的方式很多，我是用create-react-app创建示例工程，所以这里用npm引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install d3</span><br><span class="line"><span class="comment">//安装后得到的d3版本 之后都会依据这个版本做示例： "d3": "^5.7.0",</span></span><br><span class="line"><span class="comment">//d3 4/5 版本之间的API会略有不同</span></span><br><span class="line"><span class="comment">//然后在js文件中</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> d3 <span class="keyword">from</span> <span class="string">'d3'</span></span><br></pre></td></tr></table></figure>
<h3 id="准备根视图和数据"><a href="#准备根视图和数据" class="headerlink" title="准备根视图和数据"></a>准备根视图和数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//之后会在这里加入画布</span></span><br><span class="line">&lt;div id=<span class="string">"graph"</span> /&gt;</span><br><span class="line"><span class="comment">//本次最后会画出一个“柱状图”，简单准备下这样的数据源</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">2500</span>, <span class="number">2100</span>, <span class="number">1700</span>, <span class="number">1300</span>, <span class="number">900</span>]</span><br></pre></td></tr></table></figure>
<h3 id="设置画布"><a href="#设置画布" class="headerlink" title="设置画布"></a>设置画布</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在之前准备的div下插入svg</span></span><br><span class="line"><span class="keyword">let</span> svg = d3.select(<span class="string">"#graph"</span>) <span class="comment">// d3.select()：是选择所有指定元素的第一个</span></span><br><span class="line">    .append(<span class="string">"svg"</span>)<span class="comment">//获取到画布</span></span><br><span class="line">    .attr(<span class="string">"width"</span>, <span class="number">500</span>)<span class="comment">//设置宽度</span></span><br><span class="line">    .attr(<span class="string">"height"</span>, <span class="number">500</span>);<span class="comment">//设置高度</span></span><br></pre></td></tr></table></figure>
<p>D3 虽然没有明文规定一定要在 SVG 中绘图，但是 D3 提供了众多的 SVG 图形的生成器，它们都是只支持 SVG 的。因此，建议使用 SVG 画布。        </p>
<p>SVG，指可缩放矢量图形（Scalable Vector Graphics），是用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开放标准。SVG 使用 XML 格式来定义图形，可将 SVG 文本直接嵌入 HTML 中显示。</p>
<p>SVG 有如下特点：</p>
<ul>
<li>SVG 绘制的是矢量图，因此对图像进行放大不会失真。</li>
<li>基于 XML，可以为每个元素添加 JavaScript 事件处理器。</li>
<li>每个图形均视为对象，更改对象的属性，图形也会改变。</li>
<li>不适合游戏应用。</li>
</ul>
<h3 id="设置比例尺"><a href="#设置比例尺" class="headerlink" title="设置比例尺"></a>设置比例尺</h3><p>为什么要设置比例尺？直接使用输入的数值当成矩形的长度 如果数值过大或过小 可能画布没有这么大，或者根本看不见。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> linear = d3.scaleLinear()<span class="comment">//返回线性比例尺</span></span><br><span class="line">    .domain([<span class="number">0</span>, <span class="number">2500</span>])<span class="comment">// 0-2500 映射到 0-100</span></span><br><span class="line">    .range([<span class="number">0</span>, <span class="number">250</span>]);<span class="comment">//这里0 2500对应输入数据的最小最大值</span></span><br></pre></td></tr></table></figure>
<h3 id="画出矩形"><a href="#画出矩形" class="headerlink" title="画出矩形"></a>画出矩形</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加了与 data 数组的长度相同数量的矩形</span></span><br><span class="line">svg.selectAll(<span class="string">"rect"</span>)   <span class="comment">//选择svg内所有的矩形</span></span><br><span class="line">    .data(<span class="keyword">this</span>.props.data)  <span class="comment">//绑定数组</span></span><br><span class="line">    .enter()        <span class="comment">//指定选择集的enter部分</span></span><br><span class="line">    .append(<span class="string">"rect"</span>) <span class="comment">//添加足够数量的矩形元素 rect表示矩形</span></span><br><span class="line">    <span class="comment">//设置各个矩形的坐标和长宽</span></span><br><span class="line">    .attr(<span class="string">"x"</span>, <span class="number">25</span>) <span class="comment">//每个矩形的x坐标</span></span><br><span class="line">    .attr(<span class="string">"y"</span>, (d, i) =&gt; i * <span class="number">40</span>) <span class="comment">//每个矩形的y坐标</span></span><br><span class="line">    <span class="comment">//将比例尺应用到width</span></span><br><span class="line">    .attr(<span class="string">"width"</span>, (d, i) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"&#123;d,i&#125;"</span>, &#123; d, i &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"linear(d)"</span>, linear(d))</span><br><span class="line">        <span class="keyword">return</span> linear(d);</span><br><span class="line">        &#125;)</span><br><span class="line">    .attr(<span class="string">"height"</span>, <span class="number">25</span>)</span><br><span class="line">    <span class="comment">//设置颜色</span></span><br><span class="line">    .attr(<span class="string">"fill"</span>, <span class="string">"#66ccff"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="画出坐标轴"><a href="#画出坐标轴" class="headerlink" title="画出坐标轴"></a>画出坐标轴</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g = svg.append(<span class="string">"g"</span>);</span><br><span class="line">    <span class="comment">//设置x轴</span></span><br><span class="line">    g.append(<span class="string">"g"</span>)<span class="comment">//定义了坐标轴之后，只需要在 SVG 中添加一个分组元素 &lt;g&gt;，再将坐标轴的其他元素添加到这个 &lt;g&gt; 里即可</span></span><br><span class="line">        .attr(<span class="string">"transform"</span>, <span class="string">"translate(25,0)"</span>)<span class="comment">//坐标轴的位置，可以通过 transform 属性来设定。</span></span><br><span class="line">        .call(</span><br><span class="line">            d3.axisBottom(linear)<span class="comment">//axisBottom表示刻度向下的坐标轴</span></span><br><span class="line">            .ticks(<span class="number">5</span>)<span class="comment">//刻度的数量</span></span><br><span class="line">        );</span><br><span class="line">    <span class="comment">//设置y轴</span></span><br><span class="line">    <span class="comment">// 	svg.append("g").call(axis); 等价于  axis(svg.append(g));</span></span><br><span class="line">    g.append(<span class="string">"g"</span>)</span><br><span class="line">        .attr(<span class="string">"transform"</span>, <span class="string">"translate(25,0)"</span>)</span><br><span class="line">        .call(d3.axisLeft(linear).ticks(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>看到这里或许你会对 react/g 、 x/y/width/height/fill 以及 svg坐标系产生好奇,这里就推荐 MDN 的文档了 :</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element" target="_blank" rel="noopener">SVG元素参考</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute" target="_blank" rel="noopener">SVG属性参考</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial" target="_blank" rel="noopener">SVG教程</a></li>
</ul>
<p>完整代码 ： <a href="https://github.com/sunyanyan/d3-start/blob/master/src/View/D3/QuickStart.js" target="_blank" rel="noopener">QuickStart.js</a></p>
<p>在线演示 ： <a href="/d3start/#/quick-start">可视化学习-quick-start</a></p>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>可视化D3教程</category>
      </categories>
      <tags>
        <tag>可视化</tag>
        <tag>D3</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS直播教程</title>
    <url>/quick-start/iOS%E7%9B%B4%E6%92%AD%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="直播原理"><a href="#直播原理" class="headerlink" title="直播原理"></a>直播原理</h2><p>一个简单的直播流程是: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app        -&gt; 视频采集   -&gt;  编码    -&gt; 推流     -&gt; 服务器</span><br><span class="line">服务器      -&gt; 拉流      -&gt;  解码    -&gt; 播放     -&gt; app</span><br></pre></td></tr></table></figure>
<p>其中涉及到的技术点比较多:</p>
<p><img src="/res/live/直播技术点.png" alt></p>
<a id="more"></a>
<h3 id="流媒体传输协议"><a href="#流媒体传输协议" class="headerlink" title="流媒体传输协议"></a>流媒体传输协议</h3><h4 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h4><ul>
<li>RTMP:实时消息传输协议,Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议，因为是开放协议所以都可以使用了。<ul>
<li>RTMP协议用于对象、视频、音频的传输。<ul>
<li>这个协议建立在TCP协议或者轮询HTTP协议之上。</li>
<li>RTMP协议就像一个用来装数据包的容器，这些数据可以是FLV中的视音频数据。一个单一的连接可以通过不同的通道传输多路网络流，这些通道中的包都是按照固定大小的包传输的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS (HTTP Live Streaming)"></a>HLS (HTTP Live Streaming)</h4><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播，主要应用在iOS系统，为iOS设备（如iPhone、iPad）提供音视频直播和点播方案。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。</p>
<p>相对于常见的流媒体直播协议，例如RTMP协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p>
<p>m3u8，是HTTP Live Streaming直播的索引文件。</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008332-CH1-SW1" target="_blank" rel="noopener">Apple: HTTP Live Streaming Overview </a></li>
<li><a href="https://developer.apple.com/streaming/" target="_blank" rel="noopener">Apple: HTTP Live Streaming(HLS) Overview</a></li>
</ul>
<h2 id="直播iOS实战"><a href="#直播iOS实战" class="headerlink" title="直播iOS实战"></a>直播iOS实战</h2><h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><h4 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h4><blockquote>
<p>使用HomeBrew 安装 nginx<br>没安装过HomwBrew的 看一下 <a href="https://brew.sh/" target="_blank" rel="noopener">HomeBrew主页</a> 安装一下</p>
</blockquote>
<p><strong>一：</strong> <em>增加home-brew对nginx的扩展</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/nginx</span><br></pre></td></tr></table></figure>
<p><strong>二：</strong> <em>安装Nginx服务器和rtmp模块</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install nginx-full --with-rtmp-module</span><br></pre></td></tr></table></figure>
<p><strong>三：</strong> <em>查看是否安装成功</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew info nginx-full</span><br></pre></td></tr></table></figure>
<p><img src="/res/live/brewInfoNginx.png" alt>    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf （配置文件路径）</span><br><span class="line">/usr/local/var/www （服务器默认路径）</span><br><span class="line">/usr/local/Cellar/ （安装路径）</span><br><span class="line">open -t /usr/local/etc/nginx/nginx.conf 可以用文本编辑器打开配置文件</span><br><span class="line">nginx -s reload 重新加载配置</span><br><span class="line">nginx -s reopen 重新打开log</span><br><span class="line">nginx -s stop 停止nginx</span><br><span class="line">nginx -s quit 退出nginx</span><br></pre></td></tr></table></figure>
<p><strong>四：</strong> <em>启动nginx</em></p>
<p>输入 开启服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>在浏览器中 输入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>如果出现下图, 则表示安装成功:</p>
<p><img src="/res/live/welcomeNginx.png" alt></p>
<h4 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h4><p><strong>一：</strong> <em>配置Nginx，支持http协议拉流</em></p>
<p>在终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -t  /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>打开nginx配置文件,在http属性下找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下面添加，成为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">	root   html;</span><br><span class="line">	index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /hls &#123; </span><br><span class="line">	#支持http协议拉流</span><br><span class="line">	types &#123; </span><br><span class="line">		application/vnd.apple.mpegurl m3u8; </span><br><span class="line">		video/mp2t ts; </span><br><span class="line">	&#125; </span><br><span class="line">	root /usr/local/var/www; </span><br><span class="line">	add_header Cache-Control no-cache; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二：</strong> <em>配置Nginx，支持rtmp协议推流</em></p>
<p>在终端输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open -t  /usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>打开nginx配置文件, 文件的末尾(最后一个 “}” 下一行 )添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1990;</span><br><span class="line">        </span><br><span class="line">        application hls&#123;</span><br><span class="line"></span><br><span class="line">          live on;</span><br><span class="line">          record off;</span><br><span class="line">          hls on;</span><br><span class="line">          hls_path /usr/local/var/www/hls;</span><br><span class="line">          hls_fragment 1s;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三：</strong> 应用配置</p>
<p>重启下nginx就行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h4 id="使用-ffmepg-测试推流"><a href="#使用-ffmepg-测试推流" class="headerlink" title="使用 ffmepg 测试推流"></a>使用 ffmepg 测试推流</h4><h3 id="在iOS端使用-LFLiveKit-推流"><a href="#在iOS端使用-LFLiveKit-推流" class="headerlink" title="在iOS端使用 LFLiveKit 推流"></a>在iOS端使用 LFLiveKit 推流</h3><blockquote>
<p>LFLiveKit它已经帮我们实现了视频采集、后台录制、美颜功能、支持h264、AAC编码，动态改变速率，RTMP传输等<br><a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit主页</a></p>
</blockquote>
<h4 id="使用LFLiveKit-demo-推流"><a href="#使用LFLiveKit-demo-推流" class="headerlink" title="使用LFLiveKit demo 推流"></a>使用LFLiveKit demo 推流</h4><p>下载源代码后，进入sample/LFLiveKitDemo 目录，运行下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure></p>
<p>打开LFLiveKitDemo.xcworkspace 工程</p>
<p>将<strong>LFLivePreview.m</strong>文件的362行改为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">stream.url = <span class="string">@"rtmp://10.45.33.96:1990/hls/abc"</span>;</span><br></pre></td></tr></table></figure>
<p>url对应的是 rtmp://[nginx服务器地址] : [端口] / [配置的应用] / 随便写</p>
<p>然后真机运行效果如下:</p>
<p><img src="/res/live/LFLiveKitPreview.png" width="50%"></p>
<h4 id="测试LFLiveKit-demo-推流"><a href="#测试LFLiveKit-demo-推流" class="headerlink" title="测试LFLiveKit demo 推流"></a>测试LFLiveKit demo 推流</h4><blockquote>
<p>保证nginx服务器是开启状态<br>点击上面demo中的开始直播后：</p>
</blockquote>
<p>在mac <strong>Safari</strong> 浏览器中输入 <a href="http://localhost:8080/hls/abc.m3u8" target="_blank" rel="noopener">http://localhost:8080/hls/abc.m3u8</a> 查看效果：</p>
<p><img src="/res/live/LFLiveKitTest.png" width="80%"></p>
<p>相对应的，直接使用iOS自带的AVPlayer就可以播放该链接。</p>
]]></content>
      <categories>
        <category>quick-start</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>xcodebuild命令</title>
    <url>/quick-start/xcodebuild%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>xcodebuild 生成app以及生成ipa文件 </p>
</blockquote>
<a id="more"></a>
<h1 id="xcodebuild命令"><a href="#xcodebuild命令" class="headerlink" title="xcodebuild命令"></a>xcodebuild命令</h1><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="查看xcode的版本号和build版本"><a href="#查看xcode的版本号和build版本" class="headerlink" title="查看xcode的版本号和build版本"></a>查看xcode的版本号和build版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -version</span><br></pre></td></tr></table></figure>
<h3 id="显示当前系统的sdk、及其版本"><a href="#显示当前系统的sdk、及其版本" class="headerlink" title="显示当前系统的sdk、及其版本"></a>显示当前系统的sdk、及其版本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -showsdks</span><br></pre></td></tr></table></figure>
<h3 id="显示工程项目信息"><a href="#显示工程项目信息" class="headerlink" title="显示工程项目信息"></a>显示工程项目信息</h3><p>先cd到工程目录下（有＊.xcodeproj的目录，比如MakeFileTest.xcodeproj），然后输入命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -list</span><br></pre></td></tr></table></figure></p>
<p>如果未指定Configurations，默认为release</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -sdk iphonesimulator5.0</span><br></pre></td></tr></table></figure>
<p>输出一堆编译过程，最后输出<code>** BUILD SUCCEEDED **</code> 表示创建成功；若输出 <code>** BUILD FAILED **</code>表示创建失败</p>
<blockquote>
<p>与在xcode中编译不同 ，成功后会在当前工程目录下创建build目录<br>默认是Release工程</p>
</blockquote>
<h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild clean -sdk iphonesimulator5.0</span><br></pre></td></tr></table></figure>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><blockquote>
<p>未指定target默认编译第一个<br>未指定sdk默认编译iphoneos版本</p>
</blockquote>
<p>指定Target,指定Debug模式,指定真机<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -sdk iphoneos9.3 -target LAIQUSDKRes -configuration Debug</span><br></pre></td></tr></table></figure></p>
<p>指定所有target，指定Debug,指定真机<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -sdk iphoneos9.3 -alltargets -configuration Debug</span><br></pre></td></tr></table></figure></p>
<p>指定工程,指定target,指定arch<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -project wlle.xcodeproj -target LAIQUSDK -configuration Debug -sdk iphoneos9.3 ARCHS=<span class="string">'armv7 arm64'</span> VALID_ARCHS=<span class="string">'armv7 arm64'</span></span><br></pre></td></tr></table></figure></p>
<p>高级用法:给应用签名。上面两个命令都可以给应用签名的，格式分别是:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -target targetName CODE_SIGN_IDENTITY=”iPhone Distribution:XXXXXX”</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v 源app路径 -o 输出的ipa路径 –sign “iPhone Distribution:XXXXXX”</span><br></pre></td></tr></table></figure></p>
<h3 id="若工程含有pod"><a href="#若工程含有pod" class="headerlink" title="若工程含有pod"></a>若工程含有pod</h3><p>参考<a href="http://stackoverflow.com/questions/23344617/xcodebuild-of-cocoapods-project-with-product-name-fails" target="_blank" rel="noopener">http://stackoverflow.com/questions/23344617/xcodebuild-of-cocoapods-project-with-product-name-fails</a></p>
<p>先编译pods工程所有target</p>
<p>再编译目标target</p>
<h1 id="生成ipa"><a href="#生成ipa" class="headerlink" title="生成ipa"></a>生成ipa</h1><p>查到有三种方式：</p>
<h2 id="将build生成app文件压缩成ipa文件"><a href="#将build生成app文件压缩成ipa文件" class="headerlink" title="将build生成app文件压缩成ipa文件"></a>将build生成app文件压缩成ipa文件</h2><p>参考: <a href="http://www.apblog.cn/blog/2013/10/18/ioskai-fa-zi-dong-gou-jian-zi-dong-da-bao/" target="_blank" rel="noopener">http://www.apblog.cn/blog/2013/10/18/ioskai-fa-zi-dong-gou-jian-zi-dong-da-bao/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROOT_DIR=$(<span class="built_in">pwd</span>)/../Build    <span class="comment"># build目录</span></span><br><span class="line">APP_PATH=<span class="variable">$ROOT_DIR</span>/Release-iphoneos/XCToolDemo.app</span><br><span class="line"><span class="comment"># 压缩成ipa安装包</span></span><br><span class="line"><span class="keyword">if</span> [ -a <span class="variable">$APP_PATH</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"[ Start ZIP To ipa ]"</span></span><br><span class="line">    mkdir <span class="string">"<span class="variable">$ROOT_DIR</span>/Payload"</span></span><br><span class="line">    rm <span class="string">"<span class="variable">$ROOT_DIR</span>/Demo.ipa"</span></span><br><span class="line">    cp -r <span class="string">"<span class="variable">$APP_PATH</span>"</span> <span class="string">"<span class="variable">$ROOT_DIR</span>/Payload"</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">"<span class="variable">$ROOT_DIR</span>"</span></span><br><span class="line">    zip -r <span class="string">"<span class="variable">$ROOT_DIR</span>/Demo.ipa"</span> <span class="string">"Payload"</span></span><br><span class="line">    rm -rf <span class="string">"<span class="variable">$ROOT_DIR</span>/Payload"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"[ ZIP To ipa SUCCESS!! ]"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">".app file <span class="variable">$APP_PATH</span> not exist!!"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h2 id="通过-xcrun负责给xxx-app-签名并-打包成xxx-ipa"><a href="#通过-xcrun负责给xxx-app-签名并-打包成xxx-ipa" class="headerlink" title="通过 xcrun负责给xxx.app(签名并)打包成xxx.ipa"></a>通过 xcrun负责给xxx.app(签名并)打包成xxx.ipa</h2><p>参考:<a href="http://121.199.54.6/wordpress/?p=865" target="_blank" rel="noopener">http://121.199.54.6/wordpress/?p=865</a></p>
<p>第一步清理:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/xcodebuild -target targetName clean</span><br></pre></td></tr></table></figure></p>
<p>第二步编译:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/xcodebuild -target targetName</span><br></pre></td></tr></table></figure></p>
<p>第三步打包:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/xcrun -sdk iphoneos PackageApplication -v path/To/xxx.app -o xxx.ipa</span><br></pre></td></tr></table></figure></p>
<h2 id="先生成archive包再生成ipa包"><a href="#先生成archive包再生成ipa包" class="headerlink" title="先生成archive包再生成ipa包"></a>先生成archive包再生成ipa包</h2><p>参考 :<a href="http://www.voidcn.com/blog/potato512/article/p-6150876.html" target="_blank" rel="noopener">http://www.voidcn.com/blog/potato512/article/p-6150876.html</a></p>
<p>1、生成archive包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用pod管理第三方</span><br><span class="line">xcodebuild archive -workspace 项目名称.xcworkspace -scheme 项目名称 -configuration Release -archivePath archive包存储路径 CODE_SIGN_IDENTITY=证书 PROVISIONING_PROFILE=描述文件UUID</span><br><span class="line">// 未使用pod管理第三方</span><br><span class="line">xcodebuild archive -project 项目名称.xcodeproj -scheme 项目名称 -configuration Release -archivePath archive包存储路径 CODE_SIGN_IDENTITY=证书 PROVISIONING_PROFILE=描述文件UUID</span><br></pre></td></tr></table></figure></p>
<p>2、生成ipa包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcodebuild -exportArchive -exportFormat ipa文件格式 -archivePath archive包存储路径 -exportPath ipa包存储路径  -exportProvisioningProfile 描述文件名称</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>(转)浏览器的工作原理-现代浏览器幕后</title>
    <url>/essay/(%E8%BD%AC)%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E7%8E%B0%E4%BB%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%95%E5%90%8E/</url>
    <content><![CDATA[<blockquote>
<p>原文地址： <a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">How Browsers Work: Behind the scenes of modern web browsers</a></p>
</blockquote>
<center><strong>序言</strong></center>

<p>这是一篇全面介绍 WebKit 和 Gecko 内部操作的入门文章，是以色列开发人员塔利·加希尔大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数据（请参见资源），并花了很多时间来研读网络浏览器的源代码。她写道：</p>
<p>在 IE 占据 90% 市场份额的年代，我们除了把浏览器当成一个“黑箱”，什么也做不了。但是现在，开放源代码的浏览器拥有了过半的市场份额，因此，是时候来揭开神秘的面纱，一探网络浏览器的内幕了。呃，里面只有数以百万行计的 C++ 代码…</p>
<p>塔利在她的网站上公布了自己的研究成果，但是我们觉得它值得让更多的人来了解，所以我们在此重新整理并公布。</p>
<p>作为一名网络开发人员，学习浏览器的内部工作原理将有助于您作出更明智的决策，并理解那些最佳开发实践的个中缘由。尽管这是一篇相当长的文档，但是我们建议您花些时间来仔细阅读；读完之后，您肯定会觉得所费不虚。</p>
<p align="right">保罗·爱丽诗 (Paul Irish)，Chrome 浏览器开发人员事务部</p>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p>
<a id="more"></a>
<h3 id="我们要讨论的浏览器"><a href="#我们要讨论的浏览器" class="headerlink" title="我们要讨论的浏览器"></a>我们要讨论的浏览器</h3><p>目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 StatCounter 浏览器统计数据，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。</p>
<h3 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h3><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</p>
<p>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</p>
<p>浏览器的用户界面有很多彼此相同的元素，其中包括：</p>
<ul>
<li>用来输入 URI 的地址栏</li>
<li>前进和后退按钮</li>
<li>书签设置选项</li>
<li>用于刷新和停止加载当前文档的刷新和停止按钮</li>
<li>用于返回主页的主页按钮</li>
</ul>
<p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p>
<h3 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="headerlink" title="浏览器的高层结构"></a>浏览器的高层结构</h3><p>浏览器的主要组件为 (1.1)：</p>
<ol>
<li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>
</ol>
<ul>
<li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li>
<li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li>
<li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>
<li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li>
<li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png" alt></p>
<center><strong>图：浏览器的主要组件</strong></center>

<p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>
<h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>呈现引擎的作用嘛…当然就是“呈现”了，也就是在浏览器的屏幕上显示请求的内容。</p>
<p>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</p>
<h3 id="呈现引擎-1"><a href="#呈现引擎-1" class="headerlink" title="呈现引擎"></a>呈现引擎</h3><p>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</p>
<p>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。</p>
<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p>
<p>然后进行如下所示的基本流程：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png" alt></p>
<center><strong>图：呈现引擎的基本流程。</strong></center>

<p>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</p>
<p>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</p>
<p>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</p>
<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>
<h3 id="主流程示例"><a href="#主流程示例" class="headerlink" title="主流程示例"></a>主流程示例</h3><p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt></p>
<center><strong>图：WebKit 主流程</strong></center>


<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image008.jpg" alt></p>
<center><strong>图：Mozilla 的 Gecko 呈现引擎主流程 (3.6)</strong></center>

<p>从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</p>
<p>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>
<h2 id="解析和-DOM-树构建"><a href="#解析和-DOM-树构建" class="headerlink" title="解析和 DOM 树构建"></a>解析和 DOM 树构建</h2><h3 id="解析-综述"><a href="#解析-综述" class="headerlink" title="解析 - 综述"></a>解析 - 综述</h3><p>解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。</p>
<p>解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。</p>
<p>示例 - 解析 <code>2 + 3 - 1</code> 这个表达式，会返回下面的树：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png" alt></p>
<center><strong>图：数学表达式树节点</strong></center>

<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。</p>
<h4 id="解析器和词法分析器的组合"><a href="#解析器和词法分析器的组合" class="headerlink" title="解析器和词法分析器的组合"></a>解析器和词法分析器的组合</h4><p>解析的过程可以分成两个子过程：词法分析和语法分析。</p>
<p>词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。</p>
<p>语法分析是应用语言的语法规则的过程。</p>
<p>解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png" alt></p>
<center><strong>图：从源文档到解析树</strong></center>

<p>解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。</p>
<p>如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。</p>
<h4 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h4><p>很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png" alt></p>
<center><strong>图：编译流程</strong></center>

<h4 id="解析示例"><a href="#解析示例" class="headerlink" title="解析示例"></a>解析示例</h4><p>在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。</p>
<p>词汇：我们用的语言可包含整数、加号和减号。</p>
<p>语法：</p>
<ol>
<li>构成语言的语法单位是表达式、项和运算符。</li>
</ol>
<ul>
<li>我们用的语言可以包含任意数量的表达式。</li>
<li>表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。</li>
<li>运算符是加号或减号。</li>
<li>项是一个整数或一个表达式。</li>
</ul>
<p>让我们分析一下 <code>2 + 3 - 1</code>。 </p>
<p>匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。</p>
<h4 id="词汇和语法的正式定义"><a href="#词汇和语法的正式定义" class="headerlink" title="词汇和语法的正式定义"></a>词汇和语法的正式定义</h4><p>词汇通常用正则表达式表示。</p>
<p>例如，我们的示例语言可以定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTEGER :0|[1-9][0-9]*</span><br><span class="line">PLUS : +</span><br><span class="line">MINUS: -</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，这里用正则表达式给出了整数的定义。<br>语法通常使用一种称为 BNF 的格式来定义。我们的示例语言可以定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression :=  term  operation  term</span><br><span class="line">operation :=  PLUS | MINUS</span><br><span class="line">term := INTEGER | expression</span><br></pre></td></tr></table></figure>
<p>之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅关于与上下文无关的语法的维基百科文章。</p>
<h4 id="解析器类型"><a href="#解析器类型" class="headerlink" title="解析器类型"></a>解析器类型</h4><p>有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。</p>
<p>让我们来看看这两种解析器会如何解析我们的示例：</p>
<p>自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。</p>
<p>自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆栈	         输入</span><br><span class="line"> 	              2 + 3 - 1</span><br><span class="line">项	            + 3 - 1</span><br><span class="line">项运算	        3 - 1</span><br><span class="line">表达式	        - 1</span><br><span class="line">表达式运算符	    1</span><br><span class="line">表达式</span><br></pre></td></tr></table></figure>
<p>这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。</p>
<h4 id="自动生成解析器"><a href="#自动生成解析器" class="headerlink" title="自动生成解析器"></a>自动生成解析器</h4><p>有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。</p>
<p>WebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 Flex 以及用于创建解析器的 Bison（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。</p>
<h3 id="HTML-解析器"><a href="#HTML-解析器" class="headerlink" title="HTML 解析器"></a>HTML 解析器</h3><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p>
<h4 id="HTML-语法定义"><a href="#HTML-语法定义" class="headerlink" title="HTML 语法定义"></a>HTML 语法定义</h4><p>HTML 的词汇和语法在 W3C 组织创建的规范中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。</p>
<h4 id="非与上下文无关的语法"><a href="#非与上下文无关的语法" class="headerlink" title="非与上下文无关的语法"></a>非与上下文无关的语法</h4><p>正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。</p>
<p>很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。</p>
<p>有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。</p>
<p>这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？</p>
<p>区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。</p>
<p>显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。</p>
<h4 id="HTML-DTD"><a href="#HTML-DTD" class="headerlink" title="HTML DTD"></a>HTML DTD</h4><p>HTML 的定义采用了 DTD 格式。此格式可用于定义 SGML 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。</p>
<p>DTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：<a href="http://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="noopener">www.w3.org/TR/html4/strict.dtd</a></p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。<br>解析树的根节点是“Document”对象。</p>
<p>DOM 与标记之间几乎是一一对应的关系。比如下面这段标记：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      Hello World</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可翻译成如下的 DOM 树：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png" alt></p>
<center><strong>图：示例标记的 DOM 树</strong></center>

<p>和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 <a href="http://www.w3.org/DOM/DOMTR" target="_blank" rel="noopener">www.w3.org/DOM/DOMTR</a>。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：<a href="http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html" target="_blank" rel="noopener">www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html</a>。</p>
<p>我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。</p>
<h4 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h4><p>我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。</p>
<p>原因在于：</p>
<ol>
<li>语言的宽容本质。</li>
</ol>
<ul>
<li>浏览器历来对一些常见的无效 HTML 用法采取包容态度。</li>
<li>解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。</li>
</ul>
<p>由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。</p>
<p>HTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。</p>
<p>标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。</p>
<p>标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png" alt></p>
<center><strong>图：HTML 解析流程（摘自 HTML5 规范）</strong></center>

<h4 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h4><p>该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。</p>
<p>基本示例 - 将下面的 HTML 代码标记化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello world</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>初始状态是数据状态。遇到字符 &lt; 时，状态更改为“标记打开状态”。接收一个 a-z 字符会创建“起始标记”，状态更改为“标记名称状态”。这个状态会一直保持到接收 &gt; 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。</p>
<p>遇到 &gt; 标记时，会发送当前的标记，状态改回“数据状态”。<body> 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到“数据状态”。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":100,"height":200,"position":"right","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body> 中的 &lt;。我们将为 Hello world 中的每个字符都发送一个字符标记。</p>
<p>现在我们回到“标记打开状态”。接收下一个输入字符 / 时，会创建 end tag token 并改为“标记名称状态”。我们会再次保持这个状态，直到接收 &gt;。然后将发送新的标记，并回到“数据状态”。 输入也会进行同样的处理。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png" alt></p>
<center><strong>图：对示例输入进行标记化</strong></center>

<h4 id="树构建算法"><a href="#树构建算法" class="headerlink" title="树构建算法"></a>树构建算法</h4><p>在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p>
<p>让我们来看看示例输入的树构建过程：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Hello world</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“initial mode”。接收 HTML 标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p>
<p>然后状态将改为“before head”。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p>
<p>现在我们进入了“in head”模式，然后转入“after head”模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为“in body”。</p>
<p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p>
<p>接收 body 结束标记会触发“after body”模式。现在我们将接收 HTML 结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif" alt></p>
<center><strong>图：示例 HTML 的树构建</strong></center>

<h4 id="解析结束后的操作"><a href="#解析结束后的操作" class="headerlink" title="解析结束后的操作"></a>解析结束后的操作</h4><p>在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。</p>
<p>您可以在 HTML5 规范中查看标记化和树构建的完整算法</p>
<h4 id="浏览器的容错机制"><a href="#浏览器的容错机制" class="headerlink" title="浏览器的容错机制"></a>浏览器的容错机制</h4><p>您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。</p>
<p>以下面的 HTML 代码为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mytag</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    Really lousy HTML</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。</p>
<p>不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。</p>
<p>HTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。</p>
<blockquote>
<p>解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。<br>遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。<br>我们至少要能够处理以下错误情况：</p>
<ol>
<li>明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。</li>
<li>我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。</li>
<li>向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。</li>
<li>如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。</li>
</ol>
</blockquote>
<p>让我们看一些 WebKit 容错的示例：</p>
<h5 id="使用了-lt-br-gt-而不是-lt-br-gt"><a href="#使用了-lt-br-gt-而不是-lt-br-gt" class="headerlink" title="使用了 &lt;/br&gt; 而不是 &lt;br&gt;"></a><code>使用了 &lt;/br&gt; 而不是 &lt;br&gt;</code></h5><p>有些网站使用了 <code>&lt;/br&gt;</code> 而不是 <code>&lt;br&gt;</code>。为了与 IE 和 Firefox 兼容，WebKit 将其与 <code>&lt;br&gt;</code> 做同样的处理。<br>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</span><br><span class="line">     reportError(MalformedBRError);</span><br><span class="line">     t-&gt;beginTag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，错误处理是在内部进行的，用户并不会看到这个过程。</p>
<h5 id="离散表格"><a href="#离散表格" class="headerlink" title="离散表格"></a><code>离散表格</code></h5><p>离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。<br>比如以下的示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>WebKit 会将其层次结构更改为两个同级表格：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</span><br><span class="line">        popBlock(tableTag);</span><br></pre></td></tr></table></figure>
<p>WebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。</p>
<h5 id="嵌套的表单元素"><a href="#嵌套的表单元素" class="headerlink" title="嵌套的表单元素"></a><code>嵌套的表单元素</code></h5><p>如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。<br>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</span><br><span class="line">        m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,    m_document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="过于复杂的标记层次结构"><a href="#过于复杂的标记层次结构" class="headerlink" title="过于复杂的标记层次结构"></a><code>过于复杂的标记层次结构</code></h5><p>代码的注释已经说得很清楚了。 </p>
<blockquote>
<p>示例网站 <a href="http://www.liceo.edu.mx" target="_blank" rel="noopener">www.liceo.edu.mx</a> 嵌套了约 1500 个标记，全都来自一堆 <b> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。</b></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">unsigned i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</span><br><span class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</span><br><span class="line">     curr = curr-&gt;next, i++) &#123; &#125;</span><br><span class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="放错位置的-html-或者-body-结束标记"><a href="#放错位置的-html-或者-body-结束标记" class="headerlink" title="放错位置的 html 或者 body 结束标记"></a><code>放错位置的 html 或者 body 结束标记</code></h5><p>同样，代码的注释已经说得很清楚了。</p>
<blockquote>
<p>支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。</p>
<h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><p>还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，CSS 规范定义了 CSS 的词法和语法。</p>
<p>让我们来看一些示例：<br>词法语法（词汇）是针对各个标记用正则表达式定义的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment   \/\*[^*]*\*+([^/*][^*]*\*+)*\/</span><br><span class="line">num   [0-9]+|[0-9]*&quot;.&quot;[0-9]+</span><br><span class="line">nonascii  [\200-\377]</span><br><span class="line">nmstart   [_a-z]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">nmchar    [_a-z0-9-]|&#123;nonascii&#125;|&#123;escape&#125;</span><br><span class="line">name    &#123;nmchar&#125;+</span><br><span class="line">ident   &#123;nmstart&#125;&#123;nmchar&#125;*</span><br></pre></td></tr></table></figure>
<p>“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。</p>
<p>语法是采用 BNF 格式描述的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br><span class="line">selector</span><br><span class="line">  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?</span><br><span class="line">  ;</span><br><span class="line">simple_selector</span><br><span class="line">  : element_name [ HASH | class | attrib | pseudo ]*</span><br><span class="line">  | [ HASH | class | attrib | pseudo ]+</span><br><span class="line">  ;</span><br><span class="line">class</span><br><span class="line">  : &apos;.&apos; IDENT</span><br><span class="line">  ;</span><br><span class="line">element_name</span><br><span class="line">  : IDENT | &apos;*&apos;</span><br><span class="line">  ;</span><br><span class="line">attrib</span><br><span class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</span><br><span class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</span><br><span class="line">  ;</span><br><span class="line">pseudo</span><br><span class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>解释：这是一个规则集的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.error , a.error &#123;</span><br><span class="line">  color:red;</span><br><span class="line">  font-weight:bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>div.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruleset</span><br><span class="line">  : selector [ &apos;,&apos; S* selector ]*</span><br><span class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。</p>
<h4 id="WebKit-CSS-解析器"><a href="#WebKit-CSS-解析器" class="headerlink" title="WebKit CSS 解析器"></a>WebKit CSS 解析器</h4><p>WebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image023.png" alt></p>
<center><strong>图：解析 CSS</strong></center>

<h3 id="处理脚本和样式表的顺序"><a href="#处理脚本和样式表的顺序" class="headerlink" title="处理脚本和样式表的顺序"></a>处理脚本和样式表的顺序</h3><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>网络的模型是同步的。网页作者希望解析器遇到 <code>&lt;script&gt;</code> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。</p>
<h4 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h4><p>WebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>
<h4 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h4><p>另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。</p>
<h2 id="呈现树构建"><a href="#呈现树构建" class="headerlink" title="呈现树构建"></a>呈现树构建</h2><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p>
<p>Firefox 将呈现树中的元素称为“框架”。WebKit 使用的术语是呈现器或呈现对象。<br>呈现器知道如何布局并将自身及其子元素绘制出来。<br>WebKits RenderObject 类是所有呈现器的基类，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RenderObject&#123;</span><br><span class="line">  virtual void layout();</span><br><span class="line">  virtual void paint(PaintInfo);</span><br><span class="line">  virtual void rect repaintRect();</span><br><span class="line">  Node* node;  //the DOM node</span><br><span class="line">  RenderStyle* style;  // the computed style</span><br><span class="line">  RenderLayer* containgLayer; //the containing z-index layer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个呈现器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。<br>框的类型会受到与节点相关的“display”样式属性的影响（请参阅样式计算章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的呈现器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)</span><br><span class="line">&#123;</span><br><span class="line">    Document* doc = node-&gt;document();</span><br><span class="line">    RenderArena* arena = doc-&gt;renderArena();</span><br><span class="line">    ...</span><br><span class="line">    RenderObject* o = 0;</span><br><span class="line"></span><br><span class="line">    switch (style-&gt;display()) &#123;</span><br><span class="line">        case NONE:</span><br><span class="line">            break;</span><br><span class="line">        case INLINE:</span><br><span class="line">            o = new (arena) RenderInline(node);</span><br><span class="line">            break;</span><br><span class="line">        case BLOCK:</span><br><span class="line">            o = new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case INLINE_BLOCK:</span><br><span class="line">            o = new (arena) RenderBlock(node);</span><br><span class="line">            break;</span><br><span class="line">        case LIST_ITEM:</span><br><span class="line">            o = new (arena) RenderListItem(node);</span><br><span class="line">            break;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。<br>在 WebKit 中，如果一个元素需要创建特殊的呈现器，就会替换 createRenderer 方法。呈现器所指向的样式对象中包含了一些和几何无关的信息。</p>
<h3 id="呈现树和-DOM-树的关系"><a href="#呈现树和-DOM-树的关系" class="headerlink" title="呈现树和 DOM 树的关系"></a>呈现树和 DOM 树的关系</h3><p>呈现器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。<br>有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。<br>另一个关于多呈现器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 呈现器，以包裹 inline 元素。</p>
<p>有一些呈现对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。</p>
<p> <img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png" alt></p>
<center><strong>图：呈现树及其对应的 DOM 树 (3.1)。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。</strong></center>



<h3 id="构建呈现树的流程"><a href="#构建呈现树的流程" class="headerlink" title="构建呈现树的流程"></a>构建呈现树的流程</h3><p>在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。</p>
<p>在 WebKit 中，解析样式和创建呈现器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。</p>
<p>处理 html 和 body 标记就会构建呈现树根节点。这个根节点呈现对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的呈现对象。呈现树的其余部分以 DOM 树节点插入的形式来构建。</p>
<p>请参阅关于处理模型的 CSS2 规范。</p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>构建呈现树时，需要计算每一个呈现对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p>
<p>样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。</p>
<p>样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。</p>
<p>样式计算存在以下难点：</p>
<ol>
<li>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</li>
<li><p>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</p>
<p>例如下面这个组合选择器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div div div div&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着规则适用于作为 3 个 div 元素的子代的 <div>。如果您要检查规则是否适用于某个指定的 <div> 元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。</div></div></p>
</li>
<li><p>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。</p>
</li>
</ol>
<p>让我们来看看浏览器是如何处理这些问题的：</p>
<h4 id="共享样式数据"><a href="#共享样式数据" class="headerlink" title="共享样式数据"></a>共享样式数据</h4><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p>
<ol>
<li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li>
<li>任何元素都没有 ID</li>
<li>标记名称应匹配</li>
<li>类属性应匹配</li>
<li>映射属性的集合必须是完全相同的</li>
<li>链接状态必须匹配</li>
<li>焦点状态必须匹配</li>
<li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li>
<li>元素中不能有任何 inline 样式属性</li>
<li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li>
</ol>
<h4 id="Firefox-规则树"><a href="#Firefox-规则树" class="headerlink" title="Firefox 规则树"></a>Firefox 规则树</h4><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image035.png" alt></p>
<center><strong>图：Firefox 样式上下文树 (2.2)</strong></center>

<p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。</p>
<p>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p>
<p>这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/tree.png" alt><br>假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。<br>让我们看看规则树如何帮助我们减少工作。</p>
<h5 id="结构划分"><a href="#结构划分" class="headerlink" title="结构划分"></a>结构划分</h5><p>样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。</p>
<p>规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。</p>
<h5 id="使用规则树计算样式上下文"><a href="#使用规则树计算样式上下文" class="headerlink" title="使用规则树计算样式上下文"></a>使用规则树计算样式上下文</h5><p>在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。<br>如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。</p>
<p>如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。</p>
<p>如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。</p>
<p>如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。</p>
<p>让我们来看一个例子，假设我们有如下 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        this is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        this is also a</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> very  big  error<span class="tag">&lt;/<span class="name">span</span>&gt;</span> error</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有如下规则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</span><br><span class="line"><span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure>
<p>为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。<br>形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image027.png" alt></p>
<center><strong>图：规则树</strong></center>

<p>上下文树如下图所示（节点名 : 指向的规则节点）：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image029.png" alt></p>
<center><strong>图：上下文树</strong></center>

<p>假设我们解析 HTML 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</div></div></p>
<p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p>
<p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。</p>
<p>第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</span></p>
<p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。<br>例如，如果我们在某个段落中添加 font 规则：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">p &#123;font-family:Verdana;font size:10px;font-weight:bold&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font<br>结构（前提是该段落没有指定 font 规则）。</p>
<p>在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。 </p>
<p>因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 1 和问题 3。Firefox 规则树还有助于按照正确的顺序应用属性。</p>
<h4 id="对规则进行处理以简化匹配"><a href="#对规则进行处理以简化匹配" class="headerlink" title="对规则进行处理以简化匹配"></a>对规则进行处理以简化匹配</h4><p>样式规则有一些来源：</p>
<ul>
<li>外部样式表或样式元素中的 CSS 规则<br><code>p {color:blue}</code></li>
<li>inline 样式属性及类似内容<br><code>&lt;p style=&quot;color:blue&quot; /&gt;</code></li>
<li>HTML 可视化属性（映射到相关的样式规则）<br><code>&lt;p bgcolor=&quot;blue&quot; /&gt;</code></li>
</ul>
<p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p>
<p>我们之前在第 2 个问题中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。</p>
<p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。<br>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了 (4.1)。</p>
<p>我们以如下的样式规则为例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure>
<p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。<br>对于下面的 HTML 代码段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。<br>例如，如果 div 的对应规则如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。<br>WebKit 和 Firefox 都进行了这一处理。</p>
<h4 id="以正确的层叠顺序应用规则"><a href="#以正确的层叠顺序应用规则" class="headerlink" title="以正确的层叠顺序应用规则"></a>以正确的层叠顺序应用规则</h4><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p>
<p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p>
<h5 id="样式表层叠顺序"><a href="#样式表层叠顺序" class="headerlink" title="样式表层叠顺序"></a>样式表层叠顺序</h5><p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p>
<ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者重要声明</li>
<li>用户重要声明</li>
</ol>
<p>浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。</p>
<h5 id="特异性"><a href="#特异性" class="headerlink" title="特异性"></a>特异性</h5><p>选择器的特异性由 CSS2 规范定义如下：</p>
<ul>
<li>如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)</li>
<li>记为选择器中 ID 属性的个数 (= b)</li>
<li>记为选择器中其他属性和伪类的个数 (= c)</li>
<li>记为选择器中元素名称和伪元素的个数 (= d)</li>
</ul>
<p>将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。<br>您使用的进制取决于上述类别中的最高计数。<br>例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p …（在选择器中出现了 17 个标记，这样的可能性极低）。</p>
<p>一些示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span><br><span class="line">li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span><br><span class="line">li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span><br><span class="line">ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span><br><span class="line">h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span><br><span class="line">ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span><br><span class="line">li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span><br><span class="line">#x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span><br><span class="line">style=&quot;&quot;          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span><br></pre></td></tr></table></figure>
<h5 id="规则排序"><a href="#规则排序" class="headerlink" title="规则排序"></a>规则排序</h5><p>找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“&gt;”运算符来实现排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</span><br><span class="line">&#123;</span><br><span class="line">    int spec1 = r1.selector()-&gt;specificity();</span><br><span class="line">    int spec2 = r2.selector()-&gt;specificity();</span><br><span class="line">    return (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="渐进式处理"><a href="#渐进式处理" class="headerlink" title="渐进式处理"></a>渐进式处理</h3><p>WebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。</p>
<p>HTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历 (3.5)。</p>
<p>坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。</p>
<p>布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。</html></p>
<p>根呈现器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。<br>所有的呈现器都有一个“layout”或者“reflow”方法，每一个呈现器都会调用其需要进行布局的子代的 layout 方法。</p>
<h3 id="Dirty-位系统"><a href="#Dirty-位系统" class="headerlink" title="Dirty 位系统"></a>Dirty 位系统</h3><p>为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。</p>
<p>有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管呈现器自身没有变化，但它至少有一个子代需要布局。</p>
<h3 id="全局布局和增量布局"><a href="#全局布局和增量布局" class="headerlink" title="全局布局和增量布局"></a>全局布局和增量布局</h3><p>全局布局是指触发了整个呈现树范围的布局，触发原因可能包括：</p>
<ol>
<li>影响所有呈现器的全局样式更改，例如字体大小更改。</li>
<li>屏幕大小调整。</li>
</ol>
<p>布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。<br>当呈现器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的呈现器附加到了呈现树中。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/reflow.png" alt></p>
<center><strong>图：增量布局 - 只有 dirty 呈现器及其子代进行布局 (3.6)。</strong></center>

<h3 id="异步布局和同步布局"><a href="#异步布局和同步布局" class="headerlink" title="异步布局和同步布局"></a>异步布局和同步布局</h3><p>增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。<br>请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。<br>全局布局往往是同步触发的。<br>有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>如果布局是由“大小调整”或呈现器的位置（而非大小）改变而触发的，那么可以从缓存中获取呈现器的大小，而无需重新计算。<br>在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。</p>
<h3 id="布局处理"><a href="#布局处理" class="headerlink" title="布局处理"></a>布局处理</h3><p>布局通常具有以下模式：</p>
<ol>
<li>父呈现器确定自己的宽度。</li>
<li>父呈现器依次处理子呈现器，并且：<ol>
<li>放置子呈现器（设置 x,y 坐标）。</li>
<li>如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。</li>
</ol>
</li>
<li>父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。</li>
<li>将其 dirty 位设置为 false。</li>
</ol>
<p>Firefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父呈现器的宽度。<br>Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的呈现器高度。</p>
<h3 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h3><p>呈现器宽度是根据容器块的宽度、呈现器样式中的“width”属性以及边距和边框计算得出的。<br>例如以下 div 的宽度：</p>
<p><code>&lt;div style=&quot;width:30%&quot;/&gt;</code> 将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：</p>
<ul>
<li>容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：<br><code>clientWidth() - paddingLeft() - paddingRight()</code><br>clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。</li>
<li>元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。</li>
<li>然后加上水平方向的边框和补白。</li>
</ul>
<p>现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。<br>如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。<br>这些值会缓存起来，以用于需要布局而宽度不变的情况。</p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>如果呈现器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的呈现器，并对其调用布局。</p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p>
<h2 id="全局绘制和增量绘制"><a href="#全局绘制和增量绘制" class="headerlink" title="全局绘制和增量绘制"></a>全局绘制和增量绘制</h2><p>和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。在增量绘制中，部分呈现器发生了更改，但是不会影响整个树。更改后的呈现器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的呈现器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历呈现树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。</p>
<h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p>CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p>
<ol>
<li>背景颜色</li>
<li>背景图片</li>
<li>边框</li>
<li>子代</li>
<li>轮廓</li>
</ol>
<h3 id="Firefox-显示列表"><a href="#Firefox-显示列表" class="headerlink" title="Firefox 显示列表"></a>Firefox 显示列表</h3><p>Firefox 遍历整个呈现树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是呈现器的背景，然后是边框等等）包含了与矩形相关的呈现器。这样等到重新绘制的时候，只需遍历一次呈现树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。<br>Firefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。</p>
<h3 id="WebKit-矩形存储"><a href="#WebKit-矩形存储" class="headerlink" title="WebKit 矩形存储"></a>WebKit 矩形存储</h3><p>在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。 </p>
<h2 id="动态变化"><a href="#动态变化" class="headerlink" title="动态变化"></a>动态变化</h2><p>在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个呈现树都会进行重新布局和绘制。</p>
<h2 id="呈现引擎的线程"><a href="#呈现引擎的线程" class="headerlink" title="呈现引擎的线程"></a>呈现引擎的线程</h2><p>呈现引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。<br>网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (!mExiting)</span><br><span class="line">    NS_ProcessNextEvent(thread);</span><br></pre></td></tr></table></figure></p>
<h2 id="CSS2-可视化模型"><a href="#CSS2-可视化模型" class="headerlink" title="CSS2 可视化模型"></a>CSS2 可视化模型</h2><h3 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h3><p>根据 CSS2 规范，“画布”这一术语是指“用来呈现格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。</p>
<p>根据 <a href="http://www.w3.org/TR/CSS2/zindex.html" target="_blank" rel="noopener">www.w3.org/TR/CSS2/zindex.html</a>，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。</p>
<h3 id="CSS-框模型"><a href="#CSS-框模型" class="headerlink" title="CSS 框模型"></a>CSS 框模型</h3><p>CSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。<br>每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image046.jpg" alt></p>
<center><strong>图：CSS2 框模型</strong></center>

<p>每一个节点都会生成 0..n 个这样的框。<br>所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block  - generates a block box.</span><br><span class="line">inline - generates one or more inline boxes.</span><br><span class="line">none - no box is generated.</span><br></pre></td></tr></table></figure></p>
<p> 默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。<br>您可以在这里找到默认样式表示例：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="noopener">www.w3.org/TR/CSS2/sample.html</a></p>
<h3 id="定位方案"><a href="#定位方案" class="headerlink" title="定位方案"></a>定位方案</h3><p>有三种定位方案：</p>
<ol>
<li>普通：根据对象在文档中的位置进行定位，也就是说对象在呈现树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。</li>
<li>浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。</li>
<li>绝对：对象在呈现树中的位置和它在 DOM 树中的位置不同。</li>
</ol>
<p>定位方案是由“position”属性和“float”属性设置的。</p>
<ul>
<li>如果值是 static 和 relative，就是普通流</li>
<li>如果值是 absolute 和 fixed，就是绝对定位</li>
</ul>
<p>static 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。<br>框的布局方式是由以下因素决定的：</p>
<ul>
<li>框类型</li>
<li>框尺寸</li>
<li>定位方案</li>
<li>外部信息，例如图片大小和屏幕大小</li>
</ul>
<h3 id="框类型"><a href="#框类型" class="headerlink" title="框类型"></a>框类型</h3><p>block 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image057.png" alt></p>
<center><strong>图：block 框</strong></center>

<p>inline 框：没有自己的 block，但是位于容器 block 内。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image059.png" alt></p>
<center><strong>图：inline 框</strong></center>

<p>block 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image061.png" alt></p>
<center><strong>图：block 和 inline 格式</strong></center>

<p>inline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image063.png" alt></p>
<center><strong>图：行</strong></center>

<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><h4 id="相对"><a href="#相对" class="headerlink" title="相对"></a>相对</h4><p>相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image065.png" alt></p>
<center><strong>图：相对定位</strong></center>

<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"float:right"</span> <span class="attr">src</span>=<span class="string">"images/image.gif"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet, consectetuer...</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 显示效果如下：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image067.png" alt></p>
<center><strong>图：浮动</strong></center>

<h4 id="绝对定位和固定定位"><a href="#绝对定位和固定定位" class="headerlink" title="绝对定位和固定定位"></a>绝对定位和固定定位</h4><p>这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。</p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image069.png" alt></p>
<center><strong>图：固定定位</strong></center>

<p>请注意，即使在文档滚动时，固定框也不会移动。</p>
<h3 id="分层展示"><a href="#分层展示" class="headerlink" title="分层展示"></a>分层展示</h3><p>这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。</p>
<p>这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。<br>堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      div &#123;</span></span><br><span class="line"><span class="undefined">        position: absolute;</span></span><br><span class="line"><span class="undefined">        left: 2in;</span></span><br><span class="line"><span class="undefined">        top: 2in;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image071.png" alt></p>
<center><strong>图：固定定位</strong></center>

<p>虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking3源码阅读-NSURLSession</title>
    <url>/essay/AFNetworking/AFNetworking3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-NSURLSession/</url>
    <content><![CDATA[<blockquote>
<p>AFURLSessionManager 和 AFHTTPSessionManager 是AFNetworking的核心类<br>这里先阅读AFURLSessionManager。</p>
</blockquote>
<h2 id="使用-AFURLSessionManager-创建下载任务"><a href="#使用-AFURLSessionManager-创建下载任务" class="headerlink" title="使用 AFURLSessionManager 创建下载任务"></a>使用 AFURLSessionManager 创建下载任务</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</span><br><span class="line">&#125;];</span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="AFURLSessionManager-初始化"><a href="#AFURLSessionManager-初始化" class="headerlink" title="AFURLSessionManager 初始化"></a>AFURLSessionManager 初始化</h2><blockquote>
<p><code>initWithSessionConfiguration:</code> 创建和管理 NSURLSession</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration&#123;</span><br><span class="line">	<span class="number">1.</span> 初始化相应的属性</span><br><span class="line">	<span class="number">2.</span> 为task设置代理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.</strong> 初始化相应的属性</p>
<ul>
<li>初始化<strong>会话配置</strong>(NSURLSessionConfiguration),默认为<code>defaultSessionConfiguration</code></li>
<li>初始化<strong>会话</strong>(NSURLSession),设置会话的配置，代理以及队列</li>
<li>初始化<strong>响应序列化</strong>(AFJSONResponseSerializer),<strong>安全认证</strong>(AFSecurityPolicy),<strong>网络状态监控</strong>(AFNetworkReachabilityManager)</li>
<li>初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</li>
</ul>
<p><strong>2.</strong> 为task设置代理</p>
<p>使用<code>getTasksWithCompletionHandler</code>从session中取出task，并为task设置代理。</p>
<h2 id="管理NSURLSessionTask"><a href="#管理NSURLSessionTask" class="headerlink" title="管理NSURLSessionTask"></a>管理NSURLSessionTask</h2><blockquote>
<p>AFURLSessionManager初始化后，就可以获取NSURLSessionTask对象</p>
</blockquote>
<p>AFNetworking3 中有7个方法分别返回<code>NSURLSessionDataTask</code>,<code>NSURLSessionUploadTask</code>,<code>NSURLSessionDownloadTask</code>。这里从以下方法来看是如何实现的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromData:(<span class="built_in">NSData</span> *)bodyData</span><br><span class="line">                                         progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithRequest:request fromData:bodyData];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>url_session_manager_create_task_safely</code>是解决iOS8之前的一个bug ，详情可以看 <a href="https://github.com/AFNetworking/AFNetworking/issues/2093" target="_blank" rel="noopener">Issue 2093</a></p>
<ul>
<li>通过传入的<em>NSURLRequest</em>生成<strong>NSURLSessionUploadTask</strong>对象</li>
<li>调用自定义方法 <code>addDelegateForUploadTask...</code>来为task添加回调事件</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个方法中 <strong>AFURLSessionManagerTaskDelegate</strong> 类实现了 <code>NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate</code>代理。</li>
<li>使用 <code>setDelegate</code>来设置代理</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#检查参数</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AFURLSessionManager 就是通过字典 <strong>mutableTaskDelegatesKeyedByTaskIdentifier</strong> 来存储并管理每一个 NSURLSessionTask，它以 taskIdentifier 为键存储 task。<br>该方法使用 <strong>NSLock</strong> 来保证不同线程使用 mutableTaskDelegatesKeyedByTaskIdentifier 时，不会出现<strong>线程竞争</strong>的问题。</p>
<h2 id="实现-NSURLSessionDelegate"><a href="#实现-NSURLSessionDelegate" class="headerlink" title="实现 NSURLSessionDelegate"></a>实现 NSURLSessionDelegate</h2><blockquote>
<p>AFURLSessionManager初始化的时候调用 initWithSessionConfiguration，将 NSURLSession 的代理设置为self</p>
</blockquote>
<p>AFURLSessionManager实现了这些协议：</p>
<ul>
<li>NSURLSessionDelegate</li>
<li>NSURLSessionTaskDelegate</li>
<li>NSURLSessionDataDelegate</li>
<li>NSURLSessionDownloadDelegate</li>
</ul>
<p>所有的delegate 实现方法都提供对应的block接口,比如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - NSURLSessionDelegate</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的block接口是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br></pre></td></tr></table></figure>
<h2 id="使用-AFURLSessionManagerTaskDelegate-管理进度"><a href="#使用-AFURLSessionManagerTaskDelegate-管理进度" class="headerlink" title="使用 AFURLSessionManagerTaskDelegate 管理进度"></a>使用 AFURLSessionManagerTaskDelegate 管理进度</h2><blockquote>
<p>上文的AFURLSessionManagerTaskDelegate实现了 <code>NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate</code>代理。<br>它主要为 task 提供进度管理功能，并在 task 结束时回调，这里开始查看如何实现的。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="number">1.</span> 设置上传或者下载任务状态改变的是回调</span><br><span class="line">    <span class="number">2.</span> KVO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.</strong> 设置上传或者下载任务状态改变的是回调</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">    progress.cancellable = <span class="literal">YES</span>;</span><br><span class="line">    progress.cancellationHandler = ^&#123;</span><br><span class="line">        [weakTask cancel];</span><br><span class="line">    &#125;;</span><br><span class="line">    progress.pausable = <span class="literal">YES</span>;</span><br><span class="line">    progress.pausingHandler = ^&#123;</span><br><span class="line">        [weakTask suspend];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> ([progress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        progress.resumingHandler = ^&#123;</span><br><span class="line">            [weakTask resume];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过对应的<strong>NSProgress</strong>状态改变时，调用 <code>resume</code> <code>suspend</code>等方法改变 task 的状态</p>
<p><strong>2.</strong> KVO</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">   <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对progress进行键值观察，对象的某些属性改变时更新 NSProgress 对象或使用 block 传递 NSProgress 对象 <code>self.uploadProgressBlock(object)</code>或者 <code>self.downloadProgressBlock(object);</code>。其中fractionCompleted表示 NSProgress的<strong>进度</strong>。</p>
<h3 id="代理方法-URLSession-task-didCompleteWithError"><a href="#代理方法-URLSession-task-didCompleteWithError" class="headerlink" title="代理方法 URLSession:task:didCompleteWithError:"></a>代理方法 <code>URLSession:task:didCompleteWithError:</code></h3><blockquote>
<p>当task完成数据传输时会调用这个方法,接下来看一下在 AFURLSessionManagerTaskDelegate中的实现</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1.</span> 取出数据。储存responseSerializer downloadFileURL</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">    	<span class="number">2.</span> 有错误时调用completionHandler</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="number">3.</span> 无错误时调用completionHandler</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.</strong> 取出数据。储存responseSerializer downloadFileURL</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码从 mutableData 中取出了数据，设置了 userInfo。其中 <code>self. mutableData</code>是从<br><code>URLSession:dataTask:didReceiveData</code>代理方法中获取的。userInfo 用来做通知时传送的数据</p>
<p><strong>2. 3.调用completionHandler</strong></p>
<p>该代理方法中的error仅指本地端的错误，比如无法解析域名或者不能连上host等。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>如果当前 manager 持有 completionGroup 或者 completionQueue 就使用它们。否则会创建一个 dispatch_group_t 并在主线程中调用 completionHandler 并发送通知(在主线程中)。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>如果没有error，先对数据进行序列化，然后同样调用 block 并发送通知。</p>
<h2 id="AFURLSessionTaskSwizzling"><a href="#AFURLSessionTaskSwizzling" class="headerlink" title="_AFURLSessionTaskSwizzling"></a>_AFURLSessionTaskSwizzling</h2><blockquote>
<p>因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同,AFURLSessionTaskSwizzling 的就是修改 NSURLSessionTask 的 resume 和 suspend 方法</p>
</blockquote>
<p>使用+load 替换方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">	        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wnonnull"</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先用 NSClassFromString(@”NSURLSessionTask”) 判断当前部署的 iOS 版本是否含有类 NSURLSessionTask</li>
<li>因为 iOS7 和 iOS8 上对于 NSURLSessionTask 的实现不同，所以会通过 - [NSURLSession dataTaskWithURL:] 方法返回一个 NSURLSessionTask 实例</li>
<li>取得当前类 _AFURLSessionTaskSwizzling 中的实现 af_resume</li>
<li>如果当前类 currentClass 有 resume 方法<ul>
<li>真：5</li>
<li>假：6</li>
</ul>
</li>
<li>使用 swizzleResumeAndSuspendMethodForClass: 调剂该类的 resume 和 suspend 方法</li>
<li>currentClass = [currentClass superclass]</li>
</ol>
<h2 id="使用-AFSecurityPolicy-保证请求的安全"><a href="#使用-AFSecurityPolicy-保证请求的安全" class="headerlink" title="使用 AFSecurityPolicy 保证请求的安全"></a>使用 AFSecurityPolicy 保证请求的安全</h2><p><strong>AFSecurityPolicy</strong> 具体参考 <a href="../AFNetworking3源码阅读-Security/">AFNetworking3源码阅读-Security</a></p>
<p>在代理方法 <code>URLSession:didReceiveChallenge:completionHandler</code>中调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AFNetworking</category>
      </categories>
      <tags>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking3源码阅读-Reachability</title>
    <url>/essay/AFNetworking/AFNetworking3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Reachability/</url>
    <content><![CDATA[<blockquote>
<p>AFNetworking3源码阅读-Reachability</p>
<p>用于监控网络状态。当网络状态改变时，是重新发起一些请求的好时间；网络状态的监控也能给用户更好的网络失败提示。</p>
</blockquote>
<h2 id="AFNetworkReachabilityManager"><a href="#AFNetworkReachabilityManager" class="headerlink" title="AFNetworkReachabilityManager"></a>AFNetworkReachabilityManager</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(status));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[AFNetworkReachabilityManager sharedManager] startMonitoring];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>AFNetworkReachabilityManager中大概有这么几个方法：</p>
<p><img src="/res/AFNetworking/AFNetworking3源码阅读-Reachability-1.jpg" width="50%"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote>
<p>sharedManager 使用GCD <code>dispatch_once_t</code>单例化。具体实例调用 manager 方法。<br>+manager方法使用了这个函数来创建一个默认的，用于0.0.0.0的连接器</p>
</blockquote>
<p><code>__IPHONE_OS_VERSION_MIN_REQUIRED</code> 在iOS环境下（要求最低的系统版本）；<br><code>__MAC_OS_X_VERSION_MIN_REQUIRED</code>则表示mac环境下要求的最低环境<br>90000 表示 <code>__IPHONE_9_0</code> ；101100 表示 <code>__MAC_10_11</code></p>
<p>sockaddr_in6 代表ipv6地址<br>sockaddr_in 代表ipv4d地址<br>由于IPv6 是ios9和os_x 10.11后边推出的，这里要进行版本判断。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in6 address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin6_len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin6_family = AF_INET6;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">    <span class="keyword">struct</span> sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_len = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> managerForAddress:&amp;address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>SCNetworkReachabilityCreateWithAddress</code>生成SCNetworkReachabilityRef对象，通过监控该对象，即可获得网络连接情况。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address &#123;</span><br><span class="line">    <span class="built_in">SCNetworkReachabilityRef</span> reachability = <span class="built_in">SCNetworkReachabilityCreateWithAddress</span>(kCFAllocatorDefault, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)address);</span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line">	<span class="comment">//在`initWithReachability `中CFRetain了reachability，所以这里需要CFRelease。</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(reachability);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><blockquote>
<p>开启监听后，获得连接状态会调用<code>AFPostReachabilityStatusChange</code>，在AFPostReachabilityStatusChange中调用回调，并发送通知</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//监听回调，同时调用networkReachabilityStatusBlock</span></span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">		<span class="comment">//修改networkReachabilityStatus状态</span></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//监听需要的步骤：</span></span><br><span class="line">    <span class="comment">//1. 新建上下文</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">//2. 设置回调，, 当self.networkReachability的网络状态变化时，告之callBack处理</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilitySetCallback</span>(<span class="keyword">self</span>.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">//3. 将networkReachability加入RunLoop</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityScheduleWithRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line">    <span class="comment">//4. 获得连接状态，并调用回调</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        <span class="built_in">SCNetworkReachabilityFlags</span> flags;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SCNetworkReachabilityGetFlags</span>(<span class="keyword">self</span>.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关闭监听</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.networkReachability) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将networkReachability从RunLoop中移除</span></span><br><span class="line">    <span class="built_in">SCNetworkReachabilityUnscheduleFromRunLoop</span>(<span class="keyword">self</span>.networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注册键值监听</p>
</blockquote>
<p>重装keyPathsForValuesAffectingValueForKey，指明reachable 、reachableViaWWAN 和reachableViaWiFi属性依赖于networkReachabilityStatus。当networkReachabilityStatus改变时，观察reachable 、reachableViaWWAN 和reachableViaWiFi属性的程序需要被通知。</p>
<p>这是因为获得网络状态时，回调中只修改了networkReachabilityStatus值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span> *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"reachable"</span>] || [key isEqualToString:<span class="string">@"reachableViaWWAN"</span>] || [key isEqualToString:<span class="string">@"reachableViaWiFi"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSSet</span> setWithObject:<span class="string">@"networkReachabilityStatus"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SCNetworkReachability"><a href="#SCNetworkReachability" class="headerlink" title="SCNetworkReachability"></a>SCNetworkReachability</h3><blockquote>
<p>从上文可以看出监听主要使用的是SystemConfiguration框架中 SCNetworkReachability.h中的方法。这里介绍一下用到的方法和数据类型。</p>
</blockquote>
<p><strong>SCNetworkReachabilityFlags</strong>： 保存连接状态各个状态的含义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, <span class="built_in">SCNetworkReachabilityFlags</span>) &#123;</span><br><span class="line">	kSCNetworkReachabilityFlagsTransientConnection = <span class="number">1</span>&lt;&lt;<span class="number">0</span>, <span class="comment">// 可以通过瞬时连接（例如PPP－－－点对点通讯协议） 链接到给定的节点名和地址</span></span><br><span class="line">	kSCNetworkReachabilityFlagsReachable	 = <span class="number">1</span>&lt;&lt;<span class="number">1</span>, <span class="comment">// 当前网络配置可以请求到给定的节点名和地址</span></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionRequired = <span class="number">1</span>&lt;&lt;<span class="number">2</span>, <span class="comment">//当前网络配置可以请求到给定的节点名和地址，但必须先创建一个连接。如果创建这个标识，需要象征性地生成</span></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionOnTraffic = <span class="number">1</span>&lt;&lt;<span class="number">3</span>, <span class="comment">//当前网络配置可以请求到给定的节点名和地址，但必须先创建一个连接。定向到指定节点或地址的通信将发起该连接</span></span><br><span class="line">	kSCNetworkReachabilityFlagsInterventionRequired = <span class="number">1</span>&lt;&lt;<span class="number">4</span>, <span class="comment">//当前网络配置可以请求到给定的节点名和地址，但必须先创建一个连接。</span></span><br><span class="line">	<span class="comment">//用户需要通过某些方式的介入来创建该连接，比如提供密码、认证口令等。</span></span><br><span class="line">	<span class="comment">//一般的，只有在一个拨号通信的配置中，在自动连接过程中发生某些错误（比如没有拨号音，没有回应，无效的密码等），这种情况下，PPP通信将会终止连接直到用户介入。</span></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionOnDemand = <span class="number">1</span>&lt;&lt;<span class="number">5</span>, <span class="comment">//当前网络配置可以请求到给定的节点名和地址，但必须先创建一个连接。该请求一经CFSocketStream程序接口请求就创建，其他的函数不会创建该连接</span></span><br><span class="line">	kSCNetworkReachabilityFlagsIsLocalAddress = <span class="number">1</span>&lt;&lt;<span class="number">16</span>, <span class="comment">//所请求的节点或地址为连接到当前系统的网络节点</span></span><br><span class="line">	kSCNetworkReachabilityFlagsIsDirect	= <span class="number">1</span>&lt;&lt;<span class="number">17</span>, <span class="comment">//网络通信不会通过网关连接给定的节点名和地址，而是直接路由到系统中的一个接口上</span></span><br><span class="line"><span class="meta">#if	TARGET_OS_IPHONE</span></span><br><span class="line">	kSCNetworkReachabilityFlagsIsWWAN		= <span class="number">1</span>&lt;&lt;<span class="number">18</span>, <span class="comment">// 可通过蜂窝数据网络访问给定的节点或地址</span></span><br><span class="line"><span class="meta">#endif	// TARGET_OS_IPHONE</span></span><br><span class="line"></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>SCNetworkReachabilityRef</strong> 用来测试连接的引用。有三种创建方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SCNetworkReachabilityCreateWithAddress</span>(allocator,address)</span><br><span class="line"><span class="built_in">SCNetworkReachabilityCreateWithAddressPair</span>(allocator,localAddress,remoteAddress)</span><br><span class="line"><span class="built_in">SCNetworkReachabilityCreateWithName</span>(allocator,nodename)</span><br></pre></td></tr></table></figure>
<p><strong>SCNetworkReachabilityContext</strong> 上下文是一个结构体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="comment">// 创建一个SCNetworkReachabilityContext结构体时，需要调用SCDynamicStore的创建函数，而此创建函数会根据version来创建出不同的结构体，SCNetworkReachabilityContext对应的version是0</span></span><br><span class="line"> <span class="built_in">CFIndex</span>        version;  </span><br><span class="line"><span class="comment">// 下面两个block（release和retain）的参数就是info，此处表示的是网络状态处理的回调函数</span></span><br><span class="line">  <span class="keyword">void</span> *        __<span class="keyword">nullable</span> info;</span><br><span class="line"><span class="comment">// 该retain block用于对info进行retain，下面那个AFNetworkReachabilityRetainCallback核心就是调用了Block_copy（用于retain一个block函数，即在堆空间新建或直接引用一个block拷贝）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>    * __<span class="keyword">nonnull</span> (* __<span class="keyword">nullable</span> <span class="keyword">retain</span>)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line"><span class="comment">// 该release block用于对info进行release，下面那个AFNetworkReachabilityReleaseCallback核心就是调用了Block_release（用于release一个block函数，即将block从堆空间移除或移除相应引用）</span></span><br><span class="line">  <span class="keyword">void</span>        (* __<span class="keyword">nullable</span> release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line"><span class="comment">// 提供info的description，此处调用为NULL</span></span><br><span class="line"><span class="built_in">CFStringRef</span>    __<span class="keyword">nonnull</span> (* __<span class="keyword">nullable</span> copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; <span class="built_in">SCNetworkReachabilityContext</span>;</span><br></pre></td></tr></table></figure>
<p><strong>SCNetworkReachabilitySetCallback</strong> 给客户端指定对应target（该参数和需要检测网络状况的地址有一定关联，此处使用的是self.networkReachability），然后当这个target的网络状态变化时，告之SCNetworkReachabilityCallBack对象callBack处理（此处使用的是AFNetworkReachabilityCallback），另外callBack中使用到的参数包括target和context提供的info。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Boolean</span><br><span class="line"><span class="built_in">SCNetworkReachabilitySetCallback</span>		(</span><br><span class="line">						<span class="built_in">SCNetworkReachabilityRef</span> target,</span><br><span class="line">						<span class="built_in">SCNetworkReachabilityCallBack</span> __<span class="keyword">nullable</span> callout,</span><br><span class="line">						<span class="built_in">SCNetworkReachabilityContext</span> * __<span class="keyword">nullable</span> context</span><br><span class="line">						)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AFNetworking</category>
      </categories>
      <tags>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking3源码阅读-Security</title>
    <url>/essay/AFNetworking/AFNetworking3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Security/</url>
    <content><![CDATA[<blockquote>
<p>AFNetworking3源码阅读-Security<br>自 iOS9 发布之后，由于新特性 App Transport Security 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 AFNetworking 中的 AFSecurityPolicy 就是为了阻止中间人攻击，以及其它漏洞的工具。<br>AFSecurityPolicy 主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>
</blockquote>
<h2 id="https-amp-SSL-Pinning"><a href="#https-amp-SSL-Pinning" class="headerlink" title="https &amp; SSL Pinning"></a>https &amp; SSL Pinning</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密</p>
<p><img src="/res/AFNetworking/AFNetworking3源码阅读-Security-https.png" width="50%"></p>
<h3 id="SSL-Pinning"><a href="#SSL-Pinning" class="headerlink" title="SSL Pinning"></a>SSL Pinning</h3><p>可 以理解为证书绑定，是指客户端直接保存服务端的证书，建立https连接时直接对比服务端返回的和客户端保存的两个证书是否一样，一样就表明证书 是真的，不再去系统的信任证书机构里寻找验证。这适用于非浏览器应用，因为浏览器跟很多未知服务端打交道，无法把每个服务端的证书都保存到本地，但CS架构的像手机APP事先已经知道要进行通信的服务端，可以直接在客户端保存这个服务端的证书用于校验。</p>
<p>为什么直接对比就能保证证书没问题？ 如果中间人从客户端取出证书，再伪装成服务端跟其他客户端通信，它发送给客户端的这个证书不就能通过验证吗？确实可以通过验证，但后续的流程走不下去，因为下一步客户端会用证书里的公钥加密，中间人没有这个证书的私钥就解不出内容，也就截获不到数据，这个证书的私钥只有真正的服务端有，中间人伪造证书主要伪造的是公钥。</p>
<p>为什么要用SSL  Pinning？正常的验证方式不够吗？如果服务端的证书是从受信任的的CA机构颁发的，验证是没问题的，但CA机构颁发证书比较昂贵，小企业或个人用 户 可能会选择自己颁发证书，这样就无法通过系统受信任的CA机构列表验证这个证书的真伪了，所以需要SSL Pinning这样的方式去验证。</p>
<a id="more"></a>
<h2 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h2><blockquote>
<p>NSURLConnection 已经封装了https连接的建立、数据的加密解密功能，我们直接使用NSURLConnection是可以访问 https网站的，但NSURLConnection并没有验证证书是否合法，无法避免中间人攻击。<br>要做到真正安全通讯，需要我们手动去验证服务端返回的 证书，AFSecurityPolicy封装了证书验证的过程，让用户可以轻易使用，除了去系统信任CA机构列表验证，还支持SSL  Pinning方式的验证</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>把服务端证书(需要转换成cer格式)放到APP项目资源里，AFSecurityPolicy会自动寻找根目录下所有cer文件</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];</span><br><span class="line">securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line">[AFHTTPRequestOperationManager manager].securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure>
<p>验证时 使用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain;</span><br></pre></td></tr></table></figure>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>UML图如下:</p>
<p><img src="/res/AFNetworking//AFNetworking3源码阅读-Security-uml.jpg" width="70%"></p>
<h3 id="AFSSLPinningMode-验证模式"><a href="#AFSSLPinningMode-验证模式" class="headerlink" title="AFSSLPinningMode 验证模式"></a>AFSSLPinningMode 验证模式</h3><ul>
<li><p>AFSSLPinningModeNone</p>
<p>  这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书，这里是不会通过的。</p>
</li>
<li><p>AFSSLPinningModeCertificate</p>
<p>  这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名/有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</p>
</li>
<li><p>AFSSLPinningModePublicKey</p>
<p>  这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</p>
</li>
</ul>
<h3 id="验证服务端是否受信"><a href="#验证服务端是否受信" class="headerlink" title="验证服务端是否受信"></a>验证服务端是否受信</h3><blockquote>
<p>验证服务端是否守信是通过<code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法进行的。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据severTrust和domain来检查服务器端发来的证书是否可信</span></span><br><span class="line"><span class="comment">// 其中SecTrustRef是一个CoreFoundation类型，用于对服务器端传来的X.509证书评估的</span></span><br><span class="line"><span class="comment">// 而我们都知道，数字证书的签发机构CA，在接收到申请者的资料后进行核对并确定信息的真实有效，然后就会制作一份符合X.509标准的文件。证书中的证书内容包含的持有者信息和公钥等都是由申请者提供的，而数字签名则是CA机构对证书内容进行hash加密后得到的，而这个数字签名就是我们验证证书是否是有可信CA签发的数据。</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain&#123;</span><br><span class="line"></span><br><span class="line">	<span class="number">1</span>: 不能隐式地信任自己签发的证书</span><br><span class="line"></span><br><span class="line">	<span class="number">2</span>: 设置 policy</span><br><span class="line"></span><br><span class="line">	<span class="number">3</span>: 验证证书是否有效</span><br><span class="line"></span><br><span class="line">	<span class="number">4</span>: 根据 SSLPinningMode 对服务端进行验证</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1#</strong> 不能隐式地信任自己签发的证书</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">//self.allowInvalidCertificates==YES表示如果此处允许使用自建证书（服务器自己弄的CA证书，非官方），并且还想验证domain是否有效(self.validatesDomainName == YES)，也就是说你想验证自建证书的domain是否有效。</span></span><br><span class="line"> <span class="comment">//那么你必须使用pinnedCertificates（就是在客户端保存服务器端颁发的证书拷贝）才可以。</span></span><br><span class="line"> <span class="comment">//但是你的SSLPinningMode为AFSSLPinningModeNone，表示你不使用SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。所以当然你的客户端上没有你导入的pinnedCertificates，同样表示你无法验证该自建证书。所以都返回NO。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2#</strong> 设置 policy</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处设置验证证书的策略</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">    <span class="comment">// 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略，其中第一个参数为true表示验证整个SSL证书链，第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不需要验证domain，就使用默认的BasicX509验证策略</span></span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br></pre></td></tr></table></figure>
<p><strong>3#</strong> 验证证书是否有效</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果SSLPinningMode为 AFSSLPinningModeNone，表示你不使用SSL pinning，但是我允许自建证书，那么返回YES，或者使用AFServerTrustIsValid函数看看serverTrust是否可信任，如果信任，也返回YES</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 既不允许自建证书，而且使用AFServerTrustIsValid函数又返回NO，那么该serverTrust就真的不能通过验证了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4#</strong> 根据 SSLPinningMode 对服务端进行验证</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;<span class="comment">//验证整个证书</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                <span class="comment">// 这里使用SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span></span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将pinnedCertificates设置成需要参与验证的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），具体就是调用SecTrustEvaluate来验证。</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//验证整个证书链</span></span><br><span class="line">            <span class="comment">// 服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            <span class="comment">// 从服务器端证书链的根节点往下遍历，看看是否有与客户端的绑定证书一致的，有的话，就说明服务器端是可信的。因为遍历顺序正好相反，所以使用reverseObjectEnumerator</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依次遍历这些公钥，如果和客户端绑定证书的公钥一致，那么就给trustedPublicKeyCount加一</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一个验证通过的public key就算通过</span></span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面用到了一些静态方法，如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从证书中获取public key</span></span><br><span class="line"><span class="comment">//__Require_Quiet __Require_noErr_Quiet 这两个宏方法用于方便地处理调用各种证书方法过程中出现的错误</span></span><br><span class="line"><span class="comment">//出现错误后用goto语句直接跳转到相应位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取证书SecCertificateRef对象</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//2. 获取默认x.509证书标准</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="comment">//3. 生成SecTrustRef 对象</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//4. 评估SecTrustRef对象</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    <span class="comment">//5. 获得公钥SecTrustCopyPublicKey对象</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//kSecTrustResultUnspecified:证书通过验证，但用户没有设置这些证书是否被信任</span></span><br><span class="line">    <span class="comment">//kSecTrustResultProceed:证书通过验证，用户有操作设置了证书被信任，例如在弹出的是否信任的alert框中选择always trust</span></span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出服务端返回的所有证书</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用SecTrustGetCertificateCount函数t获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取出服务端返回证书里所有的public key</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">// 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line"></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        <span class="comment">// 根据给定的certificates和policy来生成一个trust对象</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        <span class="comment">// 使用SecTrustEvaluate来评估上面构建的trust</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">        <span class="comment">// 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="comment">// 注意释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    <span class="comment">// 返回对应的一组公钥</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与-AFURLSessionManager-协作"><a href="#与-AFURLSessionManager-协作" class="headerlink" title="与 AFURLSessionManager 协作"></a>与 AFURLSessionManager 协作</h2><p>在代理协议 <code>- URLSession:didReceiveChallenge:completionHandler:</code> 或者 <code>- URLSession:task:didReceiveChallenge:completionHandler:</code> 代理方法被调用时会运行这段代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;  </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeRejectProtectionSpace</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSURLAuthenticationChallenge 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 protectionSpace，这里保存了需要认证的保护空间, 每一个 NSURLProtectionSpace 对象都保存了主机地址，端口和认证方法等重要信息。</p>
<p>在上面的方法中，如果保护空间中的认证方法为 NSURLAuthenticationMethodServerTrust，那么就会使用在上一小节中提到的方法 - [AFSecurityPolicy evaluateServerTrust:forDomain:] 对保护空间中的 serverTrust 以及域名 host 进行认证</p>
<p>根据认证的结果，会在 completionHandler 中传入不同的 disposition 和 credential 参数。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>AFNetworking</category>
      </categories>
      <tags>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetworking3源码阅读-Serialization</title>
    <url>/essay/AFNetworking/AFNetworking3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-Serialization/</url>
    <content><![CDATA[<blockquote>
<p>Serialization 包括 <code>AFURLResponseSerialization</code> 和 <code>AFURLRequestSerialization</code></p>
</blockquote>
<p><strong>AFURLResponseSerialization</strong> 是处理响应的模块，将请求返回的数据解析成对应的格式。而<strong>AFURLRequestSerialization</strong>的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>
<h2 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h2><blockquote>
<p>AFURLResponseSerialization 是一个协议，协议的内容为：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br></pre></td></tr></table></figure>
<p>它的实现类为：</p>
<ul>
<li>AFURLResponseSerialization<ul>
<li>AFHTTPResponseSerializer<ul>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在文件中 所有类都遵循<strong>AFURLResponseSerialization</strong>，而<strong>AFHTTPResponseSerializer</strong>是其他类的基类。</p>
<a id="more"></a>
<h3 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h3><p><strong>初始化:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.acceptableStatusCodes = [<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="keyword">self</span>.acceptableContentTypes = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是对 HTTP 响应进行序列化，所以这里设置了 stringEncoding 为 NSUTF8StringEncoding 而且没有对接收的内容类型加以限制。<br>将 acceptableStatusCodes 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示获得了有效的响应。</p>
<p><strong>验证响应的有效性:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]]) &#123;</span><br><span class="line">			<span class="meta">#1: 返回内容类型无效</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">			<span class="meta">#2: 返回状态码无效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法根据在初始化方法中初始化的属性 acceptableContentTypes 和 acceptableStatusCodes 来判断当前响应是否有效。</p>
<h4 id="AFURLResponseSerialization协议的实现"><a href="#AFURLResponseSerialization协议的实现" class="headerlink" title="AFURLResponseSerialization协议的实现"></a>AFURLResponseSerialization协议的实现</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的方法对响应进行验证，然后返回数据</p>
<h3 id="AFJSONResponseSerializer"><a href="#AFJSONResponseSerializer" class="headerlink" title="AFJSONResponseSerializer"></a>AFJSONResponseSerializer</h3><p><strong>初始化：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> serializerWithReadingOptions:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)serializerWithReadingOptions:(<span class="built_in">NSJSONReadingOptions</span>)readingOptions &#123;</span><br><span class="line">    AFJSONResponseSerializer *serializer = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    serializer.readingOptions = readingOptions;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serializer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.acceptableContentTypes = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/json"</span>, <span class="string">@"text/javascript"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对AFHTTPResponseSerializer 设置了<strong>acceptableContentTypes</strong>；</p>
<h4 id="AFURLResponseSerialization协议的实现："><a href="#AFURLResponseSerialization协议的实现：" class="headerlink" title="AFURLResponseSerialization协议的实现："></a>AFURLResponseSerialization协议的实现：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">1.</span> 验证请求</span><br><span class="line"></span><br><span class="line">	<span class="number">2.</span> 解决一个由只包含一个空格的响应引起的 bug</span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> 序列化 JSON</span><br><span class="line">	</span><br><span class="line">	<span class="number">4.</span> 移除 JSON 中的 null</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. 验证请求</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用自身的validateResponse验证响应，<br>validateResponse:中如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData，再用 <strong>AFErrorOrUnderlyingErrorHasCodeInDomain</strong>检验error 和domain，如果就是这两个值 就返回nil。</p>
<p><strong>2. 解决一个由只包含一个空格的响应引起的 bug</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data.length == <span class="number">0</span> || isSpace) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于’head :ok’，Rails返回的是一个空格 (这是Safari上的一个bug)，并且这样的JSON格式不会被NSJSONSerialization解析。如果是单个空格，就不解析<br>查看 <a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="noopener">Issues 1742</a></p>
<p><strong>3.序列化 JSON</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!responseObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用系统自带的NSJSONSerialization来解析NSData数据,如果serializationError不为空，那么最终的error其实就是serializationError</p>
<p><strong>4. 移除 JSON 中的 null</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues) &#123;</span><br><span class="line">    <span class="keyword">return</span> AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AFJSONObjectByRemovingKeysWithNullValues通过递归的方法，把JSON中NSDictionary的数据（不包括NSArray）中的对应value为空的key移除。</p>
<h2 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h2><p>AFURLRequestSerialization 的主要工作是对发出的 HTTP 请求进行处理。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"GET"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[[AFJSONRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<h3 id="AFURLRequestSerialization-1"><a href="#AFURLRequestSerialization-1" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h3><blockquote>
<p>AFURLRequestSerialization 是一个协议</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">nullable</span> <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br></pre></td></tr></table></figure>
<p>它的实现类为：</p>
<ul>
<li>AFURLRequestSerialization<ul>
<li>AFHTTPRequestSerializer<ul>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>AFHTTPRequestSerializer</strong>是所有类的基类，AFJSONRequestSerializer 和 AFPropertyListRequestSerializer继承了AFHTTPRequestSerializer。</p>
<h3 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h3><p><strong>初始化：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">	<span class="number">1.</span> 初始化参数, </span><br><span class="line">	<span class="number">2.</span> 设置HTTP 头部字段</span><br><span class="line">	<span class="number">3.</span> KVO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. 初始化参数</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.stringEncoding = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"><span class="keyword">self</span>.mutableHTTPRequestHeaders = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="keyword">self</span>.requestHeaderModificationQueue = dispatch_queue_create(<span class="string">"requestHeaderModificationQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"GET"</span>, <span class="string">@"HEAD"</span>, <span class="string">@"DELETE"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br></pre></td></tr></table></figure>
<p>初始化了一些参数 ,<strong>HTTPMethodsEncodingParametersInURI</strong>表示需要将的quey是拼接到url后面的的方法，就是<code>GET HEAD DELETE</code>，与此对应的<code>POST PUT</code>方法将query拼到http body中。<strong>mutableHTTPRequestHeaders</strong> 储存http头部信息。<strong>mutableObservedChangedKeyPaths</strong>保存需要键值观察的值。<br><strong>requestHeaderModificationQueue</strong> ？？</p>
<p><strong>2. 设置HTTP 头部字段</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">NSMutableArray</span> *acceptLanguagesComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span> setValue:[acceptLanguagesComponents componentsJoinedByString:<span class="string">@", "</span>] forHTTPHeaderField:<span class="string">@"Accept-Language"</span>];</span><br><span class="line">   </span><br><span class="line"><span class="built_in">NSString</span> *userAgent = <span class="literal">nil</span>;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span> setValue:userAgent forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br></pre></td></tr></table></figure>
<p>分别设置了<strong>acceptLanguagesComponents</strong>和<strong>userAgent</strong>信息。<br>其中<code>acceptLanguagesComponents</code>一般为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en;q=1</span><br></pre></td></tr></table></figure></p>
<p>userAgent为:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[工程名字]/[工程版本] (iPhone; iOS <span class="number">10.2</span>; Scale/<span class="number">2.00</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>3.KVO</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">           [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>对一些属性进行 KVO，确保它们在改变后更新 NSMutableURLRequest 中对应的属性。其中<strong>AFHTTPRequestSerializerObservedKeyPaths</strong>为这些值：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//是否允许使用设备的蜂窝移动网络来创建request，默认为允许</span><br><span class="line">allowsCellularAccess, </span><br><span class="line">/* 创建的request所使用的缓存策略，默认使用`NSURLRequestUseProtocolCachePolicy`，该策略表示 </span><br><span class="line"> 如果缓存不存在，直接从服务端获取。如果缓存存在，会根据response中的Cache-Control字段判断</span><br><span class="line"> 下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新话</span><br><span class="line"> 直接返回给用户缓存数据，若已更新，则请求服务端.*/</span><br><span class="line">cachePolicy, </span><br><span class="line">/**</span><br><span class="line"> 如果设置HTTPShouldHandleCookies为YES，就处理存储在NSHTTPCookieStore中的cookies</span><br><span class="line"> HTTPShouldHandleCookies表示是否应该给request设置cookie并随request一起发送出去</span><br><span class="line"> */</span><br><span class="line">HTTPShouldHandleCookies, </span><br><span class="line">/**</span><br><span class="line"> HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。</span><br><span class="line"> 如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息。</span><br><span class="line"> */</span><br><span class="line">HTTPShouldUsePipelining,</span><br><span class="line">    /**</span><br><span class="line">     设定request的network service类型. 默认是`NSURLNetworkServiceTypeDefault`.</span><br><span class="line">     这个network service是为了告诉系统网络层这个request使用的目的</span><br><span class="line">     比如NSURLNetworkServiceTypeVoIP表示的就这个request是用来请求网际协议通话技术(Voice over IP)。</span><br><span class="line"></span><br><span class="line">     系统能根据提供的信息来优化网络处理，从而优化电池寿命，网络性能等等</span><br><span class="line">     */</span><br><span class="line">networkServiceType,</span><br><span class="line">/**</span><br><span class="line"> 超时机制，默认60秒</span><br><span class="line"> */</span><br><span class="line">timeoutInterval</span><br></pre></td></tr></table></figure></p>
<h4 id="AFURLRequestSerialization-协议的实现"><a href="#AFURLRequestSerialization-协议的实现" class="headerlink" title="AFURLRequestSerialization 协议的实现"></a>AFURLRequestSerialization 协议的实现</h4><p>初始化之后，如果调用了 - [AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]，就会进入 AFHTTPRequestSerializer 的这一方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br></pre></td></tr></table></figure>
<p>其中调用了AFURLRequestSerialization 协议的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error&#123;</span><br><span class="line">                                        </span><br><span class="line"><span class="number">1.</span> 通过 HTTPRequestHeaders 字典设置头部字段</span><br><span class="line"><span class="number">2.</span> 将parameters转换为查询参数query</span><br><span class="line"><span class="number">3.</span> 将 query 添加到 URL 或者 HTTP body 中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1.通过 HTTPRequestHeaders 字典设置头部字段</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">     <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">         [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p><strong>2. 将parameters转换为查询参数query</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">query = AFQueryStringFromParameters(parameters);</span><br></pre></td></tr></table></figure>
<p>AFQueryStringFromParameters (调用)-&gt; AFQueryStringPairsFromDictionary -&gt; AFQueryStringPairsFromKeyAndValue<br>其中AFQueryStringPairsFromKeyAndValue递归调用并解析，返回查询参数。</p>
<p><strong>3. 将 query 添加到 URL 或者 HTTP body 中</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这个方法会返回一个 NSMutableURLRequest。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>AFNetworking</category>
      </categories>
      <tags>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-AVPlayer视频播放</title>
    <url>/essay/AVFoundation/AVFoundation-AVPlayer%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE/</url>
    <content><![CDATA[<blockquote>
<p>AV Player是一个用来播放给予时间的视听媒体的控制器对象。将视频资源导出到界面需要使用AVPlayerLayer类；AVPlayer只管理一个单独资源的播放，当需要播放多个音频资源可以使用子类AVQueuePlayer</p>
</blockquote>
<blockquote>
<p>不需要自定义播放器的情况可以使用 <code>MPMoviewPlayerController</code></p>
</blockquote>
<p>参考 <a href="http://www.cnblogs.com/kenshincui/p/4186022.html#avPlayer" target="_blank" rel="noopener">http://www.cnblogs.com/kenshincui/p/4186022.html#avPlayer</a></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><em>示例:</em></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *assetURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"waves"</span> withExtension:<span class="string">@"mp4"</span>];</span><br><span class="line"><span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:assetURL];</span><br><span class="line"><span class="built_in">AVPlayerItem</span> *playeritem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:playerItem];</span><br><span class="line"><span class="built_in">AVPlayerLayer</span> *playerLayer = [<span class="built_in">AVPlayer</span> playerLayerWithPlayer:<span class="keyword">self</span>.player];</span><br><span class="line"><span class="comment">//playerLayer.videoGravity=AVLayerVideoGravityResizeAspect;//视频填充模式</span></span><br><span class="line">[<span class="keyword">self</span>.view.layer addSubLayer:playerLayer];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="对播放进行控制"><a href="#对播放进行控制" class="headerlink" title="对播放进行控制"></a>对播放进行控制</h3><h2 id="监听播放状态"><a href="#监听播放状态" class="headerlink" title="监听播放状态"></a>监听播放状态</h2><blockquote>
<p>监听AVPlayerItem的<em>status</em>属性，播放项开始时status为 <code>AVPlayerItemStatusUnknow</code>，当状态改变为 <code>AVPlayerItemStatusReadyToPlay</code>才可以开始播放，只有处于这个状态时才能获得视频时长等信息。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监控状态属性，注意AVPlayer也有一个status属性，通过监控它的status也可以获得播放状态</span></span><br><span class="line">    [playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"status"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *playerItem=object;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"status"</span>]) &#123;</span><br><span class="line">        <span class="built_in">AVPlayerStatus</span> status= [[change objectForKey:<span class="string">@"new"</span>] intValue];</span><br><span class="line">        <span class="keyword">if</span>(status==<span class="built_in">AVPlayerStatusReadyToPlay</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"正在播放...，视频总长度:%.2f"</span>,<span class="built_in">CMTimeGetSeconds</span>(playerItem.duration));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="监控网络加载情况属性"><a href="#监控网络加载情况属性" class="headerlink" title="监控网络加载情况属性"></a>监控网络加载情况属性</h2><blockquote>
<p>监听AVPlayerItem的<em>loadedTimeRanges</em>属性，当loadedTimeRanges的改变时（每缓冲一部分数据就会更新此属性）可以获得本次缓冲加载的视频范围（包含起始时间、本次加载时长），这样一来就可以实时获得缓冲情况。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监控网络加载情况属性</span></span><br><span class="line">    [playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"loadedTimeRanges"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"> </span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *playerItem=object;</span><br><span class="line">	<span class="keyword">if</span>([keyPath isEqualToString:<span class="string">@"loadedTimeRanges"</span>])&#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array=playerItem.loadedTimeRanges;</span><br><span class="line">        <span class="built_in">CMTimeRange</span> timeRange = [array.firstObject <span class="built_in">CMTimeRangeValue</span>];<span class="comment">//本次缓冲时间范围</span></span><br><span class="line">        <span class="keyword">float</span> startSeconds = <span class="built_in">CMTimeGetSeconds</span>(timeRange.start);</span><br><span class="line">        <span class="keyword">float</span> durationSeconds = <span class="built_in">CMTimeGetSeconds</span>(timeRange.duration);</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> totalBuffer = startSeconds + durationSeconds;<span class="comment">//缓冲总长度</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"共缓冲：%.2f"</span>,totalBuffer);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间监听"><a href="#时间监听" class="headerlink" title="时间监听"></a>时间监听</h2><blockquote>
<p>AVPlayer提供了两种时间监听方法</p>
</blockquote>
<h3 id="定期监听"><a href="#定期监听" class="headerlink" title="定期监听"></a>定期监听</h3><blockquote>
<p>使用<code>- (id)addPeriodicTimeObserverForInterval:(CMTime)interval queue:(nullable dispatch_queue_t)queue usingBlock:(void (^)(CMTime time))block;</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每秒</span></span><br><span class="line"><span class="built_in">CMTime</span> interval = <span class="built_in">CMTimeMake</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);              <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main dispatch queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();                     <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create callback block for time observer</span></span><br><span class="line">__<span class="keyword">weak</span> THPlayerController *weakSelf = <span class="keyword">self</span>;                             <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">void</span> (^callback)(<span class="built_in">CMTime</span> time) = ^(<span class="built_in">CMTime</span> time) &#123;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> currentTime = <span class="built_in">CMTimeGetSeconds</span>(time);</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = <span class="built_in">CMTimeGetSeconds</span>(weakSelf.playerItem.duration);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当前已经播放%.2fs."</span>, currentTime);  <span class="comment">// 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add observer and store pointer for future use</span></span><br><span class="line"><span class="keyword">self</span>.timeObserver =                                                     <span class="comment">// 5</span></span><br><span class="line">    [<span class="keyword">self</span>.player addPeriodicTimeObserverForInterval:interval</span><br><span class="line">                                              queue:queue</span><br><span class="line">                                         usingBlock:callback];</span><br></pre></td></tr></table></figure>
<h3 id="边界时间监听"><a href="#边界时间监听" class="headerlink" title="边界时间监听"></a>边界时间监听</h3><blockquote>
<p>使用 <code>- (id)addBoundaryTimeObserverForTimes:(NSArray&lt;NSValue *&gt; *)times queue:(nullable dispatch_queue_t)queue usingBlock:(void (^)(void))block;</code></p>
</blockquote>
<ul>
<li>times : CMTime值组成的NSArray数组，定义了需要通知的边界点</li>
<li>queue ： 调度队列，指定NULL等同设置主队列</li>
<li>block ： 回调块</li>
</ul>
<h2 id="监听播放完成通知"><a href="#监听播放完成通知" class="headerlink" title="监听播放完成通知"></a>监听播放完成通知</h2><blockquote>
<p>注册 <code>AVPlayerItemDidPlayToEndTimeNotification</code>的通知</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//给AVPlayerItem添加播放完成通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(playbackFinished:) name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span> object:<span class="keyword">self</span>.player.currentItem];</span><br><span class="line">   </span><br><span class="line">-(<span class="keyword">void</span>)playbackFinished:(<span class="built_in">NSNotification</span> *)notification&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"视频播放完成."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成视频缩略图"><a href="#生成视频缩略图" class="headerlink" title="生成视频缩略图"></a>生成视频缩略图</h2><blockquote>
<p>使用 <code>AVAssetImageGenerator</code>类可以从 AVAsset视频中提取图片。</p>
</blockquote>
<p><em>AVAssetImageGenerator</em>有两个可以检索图片的方法：</p>
<ul>
<li><code>- (void)generateCGImagesAsynchronouslyForTimes:(NSArray&lt;NSValue *&gt; *)requestedTimes completionHandler:(AVAssetImageGeneratorCompletionHandler)handler;</code><ul>
<li>生成一组图片</li>
</ul>
</li>
<li><code>- (nullable CGImageRef)copyCGImageAtTime:(CMTime)requestedTime actualTime:(nullable CMTime *)actualTime error:(NSError * __nullable * __nullable)outError CF_RETURNS_RETAINED;</code><ul>
<li>在指定时间捕捉图片</li>
</ul>
</li>
</ul>
<p><em>生成一组图片示例：</em></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">self</span>.imageGenerator =                                                   <span class="comment">// 1</span></span><br><span class="line">       [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:<span class="keyword">self</span>.asset];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//默认情况下捕捉的图片都是原始尺寸，设置(200.0f, 0.0f)可以让图片宽度固定，高度自适应</span></span><br><span class="line">   <span class="keyword">self</span>.imageGenerator.maximumSize = <span class="built_in">CGSizeMake</span>(<span class="number">200.0</span>f, <span class="number">0.0</span>f);             <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">CMTime</span> duration = <span class="keyword">self</span>.asset.duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成视频捕捉位置的CMTime集合</span></span><br><span class="line">   <span class="built_in">NSMutableArray</span> *times = [<span class="built_in">NSMutableArray</span> array];                         <span class="comment">// 3</span></span><br><span class="line">   <span class="built_in">CMTimeValue</span> increment = duration.value / <span class="number">20</span>;</span><br><span class="line">   <span class="built_in">CMTimeValue</span> currentValue = <span class="number">2.0</span> * duration.timescale;</span><br><span class="line">   <span class="keyword">while</span> (currentValue &lt;= duration.value) &#123;</span><br><span class="line">       <span class="built_in">CMTime</span> time = <span class="built_in">CMTimeMake</span>(currentValue, duration.timescale);</span><br><span class="line">       [times addObject:[<span class="built_in">NSValue</span> valueWithCMTime:time]];</span><br><span class="line">       currentValue += increment;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   __block <span class="built_in">NSUInteger</span> imageCount = times.count;                            <span class="comment">// 4</span></span><br><span class="line">   __block <span class="built_in">NSMutableArray</span> *images = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">   <span class="built_in">AVAssetImageGeneratorCompletionHandler</span> handler;                         <span class="comment">// 5</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//requestedTime：请求的时间对应times数组中的值；</span></span><br><span class="line">   <span class="comment">//imageRef :生成的CGImageRef，若该时间点没有图片则为NULL</span></span><br><span class="line">   <span class="comment">//actualTime:图片实际生成的时间</span></span><br><span class="line">   <span class="comment">//result:表示生成图片失败还是成功</span></span><br><span class="line">   handler = ^(<span class="built_in">CMTime</span> requestedTime,</span><br><span class="line">               <span class="built_in">CGImageRef</span> imageRef,</span><br><span class="line">               <span class="built_in">CMTime</span> actualTime,</span><br><span class="line">               <span class="built_in">AVAssetImageGeneratorResult</span> result,</span><br><span class="line">               <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;                     <span class="comment">// 6</span></span><br><span class="line">           <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">           <span class="keyword">id</span> thumbnail =</span><br><span class="line">               [THThumbnail thumbnailWithImage:image time:actualTime];</span><br><span class="line">           [images addObject:thumbnail];</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// If the decremented image count is at 0, we're all done.</span></span><br><span class="line">       <span class="keyword">if</span> (--imageCount == <span class="number">0</span>) &#123;                                            <span class="comment">// 7</span></span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="built_in">NSString</span> *name = THThumbnailsGeneratedNotification;</span><br><span class="line">               <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">               [nc postNotificationName:name object:images];</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   [<span class="keyword">self</span>.imageGenerator generateCGImagesAsynchronouslyForTimes:times       <span class="comment">// 8</span></span><br><span class="line">                                             completionHandler:handler];</span><br></pre></td></tr></table></figure>
<h2 id="显示字幕（视频自带）"><a href="#显示字幕（视频自带）" class="headerlink" title="显示字幕（视频自带）"></a>显示字幕（视频自带）</h2><blockquote>
<p>显示字幕需要用到<code>AVMediaSelectionGroup</code>和<code>AVMediaSelectionOption</code>两个类</p>
</blockquote>
<ol>
<li>初始化 <em>AVAsset</em> 的时候加上 <strong><em>availableMediaCharacteristicsWithMediaSelectionOptions</em></strong> 属性<ul>
<li><em>AVMediaSelectionOption</em>的该属性会返回一个包含字符串的数组,这些字符串表示可用的媒体特性<ul>
<li>AVMediaCharacteristicLegible （字幕或者隐藏式字幕）</li>
<li>AVMediaCharacteristicAudible （音频）</li>
<li>AVMediaCharacteristicVisual （字幕） </li>
</ul>
</li>
</ul>
</li>
<li><p>请求可用的媒体特性数据后，调用 <em>AVAsset</em> 的 <strong><em>mediaSelectionGroupForMediaCharacteristic：</em></strong>方法为其传递需要的媒体特性，会返回 <em>AVMediaSelectionGroup</em> ，表示包含的备用媒体轨道</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;                            <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">AVMediaSelectionGroup</span> *group =</span><br><span class="line">      [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">if</span> (group) &#123;</span><br><span class="line">      <span class="built_in">NSMutableArray</span> *subtitles = [<span class="built_in">NSMutableArray</span> array];                 <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@" %@ "</span>,option.displayName);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出 ，表示多个字幕轨道</span></span><br><span class="line"><span class="string">@"English"</span></span><br><span class="line"><span class="string">@"English Forced"</span></span><br><span class="line"><span class="string">@"Italian"</span></span><br><span class="line"><span class="string">@"Italian Forced"</span></span><br><span class="line"><span class="string">@"Portuguese"</span></span><br><span class="line"><span class="string">@"Portuguese Forced"</span></span><br><span class="line"><span class="string">@"Russian"</span></span><br><span class="line"><span class="string">@"Russian Forced"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示字幕，通过调用 <em>AVPlayerItem</em> 的 <strong><em>selectMediaOption：inMediaSelectionGroup：</em></strong>方法。</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)subtitleSelected:(<span class="built_in">NSString</span> *)subtitle &#123;</span><br><span class="line">   <span class="built_in">NSString</span> *mc = <span class="built_in">AVMediaCharacteristicLegible</span>;</span><br><span class="line">   <span class="built_in">AVMediaSelectionGroup</span> *group =</span><br><span class="line">       [<span class="keyword">self</span>.asset mediaSelectionGroupForMediaCharacteristic:mc];          <span class="comment">// 1</span></span><br><span class="line">   <span class="built_in">BOOL</span> selected = <span class="literal">NO</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">AVMediaSelectionOption</span> *option <span class="keyword">in</span> group.options) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([option.displayName isEqualToString:subtitle]) &#123;</span><br><span class="line">           [<span class="keyword">self</span>.playerItem selectMediaOption:option                       <span class="comment">// 2</span></span><br><span class="line">                        inMediaSelectionGroup:group];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-人脸识别</title>
    <url>/essay/AVFoundation/AVFoundation-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>Core Image框架中定义了CIDetector和CUFaceFeature，它们使用起来提供了简单而强大的人脸检测功能<br>但是这些方法没有针对实时性进行优化，在AVFoundation中通过特定的AVCaptureOutput类型的 AVCaptureMetadataOutput也可以实现人脸检测。</p>
</blockquote>
<p>当使用人脸检测时，会输出一个具体子类类型AVMetadataFaceObject。<strong>AVMetadataFaceObject</strong> 定义了多个用户描述被检测到的人脸的属性，最重要的是人脸的边界（bounds），还给出了用于定义检测人脸倾斜角（roll angle）表示人的头部向肩膀方向侧倾角度，偏转角（yaw angle）表示人脸绕y轴旋转的角度。</p>
<p>配置会话与之前使用摄像头拍照类似，区别在于更换一个output，如：</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupSessionOutputs:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.metadataOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];           <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.metadataOutput]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.metadataOutput];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定对象输出的元数据类型，AV Foundation支持多种类型 这里限制使用人脸元数据</span></span><br><span class="line">        <span class="built_in">NSArray</span> *metadataObjectTypes = @[<span class="built_in">AVMetadataObjectTypeFace</span>];         <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">self</span>.metadataOutput.metadataObjectTypes = metadataObjectTypes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人脸检测用到的硬件加速，而且许多重要的任务都在主线程，一般指定主线程</span></span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">        <span class="comment">//指定AVCaptureMetadataOutputObjectsDelegate</span></span><br><span class="line">        [<span class="keyword">self</span>.metadataOutput setMetadataObjectsDelegate:<span class="keyword">self</span>                <span class="comment">// 4</span></span><br><span class="line">                                                  queue:mainQueue];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:</span><br><span class="line">                                           <span class="string">@"Failed to still image output."</span>&#125;;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:THCameraErrorDomain</span><br><span class="line">                                         code:THCameraErrorFailedToAddOutput</span><br><span class="line">                                     userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AVCaptureMetadataOutputObjectsDelegate 需要实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">didOutputMetadataObjects:(<span class="built_in">NSArray</span> *)metadataObjects</span><br><span class="line">       fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单输出一些AVMetadataFaceObject数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVMetadataFaceObject</span> *face <span class="keyword">in</span> metadataObjects) &#123;                   <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Face detected with ID: %li"</span>, (<span class="keyword">long</span>)face.faceID);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Face bounds: %@"</span>, <span class="built_in">NSStringFromCGRect</span>(face.bounds));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将人脸数据传给委托对象</span></span><br><span class="line">    [<span class="keyword">self</span>.faceDetectionDelegate didDetectFaces:metadataObjects];            <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>THFaceDetectionDelegate长这样：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">THFaceDetectionDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didDetectFaces:(<span class="built_in">NSArray</span> *)faces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>获取到AVMetadataFaceObject 后，将人脸数据可视化：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)didDetectFaces:(<span class="built_in">NSArray</span> *)faces &#123;</span><br><span class="line">    <span class="comment">//将设备坐标空间转换为视图空间对象集合</span></span><br><span class="line">    <span class="built_in">NSArray</span> *transformedFaces = [<span class="keyword">self</span> transformedFacesFromFaces:faces];</span><br><span class="line">    <span class="comment">//faceLayers 保存人脸数据对应的layer</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *lostFaces = [<span class="keyword">self</span>.faceLayers.allKeys mutableCopy];      <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVMetadataFaceObject</span> *face <span class="keyword">in</span> transformedFaces) &#123;</span><br><span class="line">        <span class="comment">//移除已不存在的人脸，添加新的人脸</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *faceID = @(face.faceID);                                  <span class="comment">// 2</span></span><br><span class="line">		[lostFaces removeObject:faceID];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CALayer</span> *layer = [<span class="keyword">self</span>.faceLayers objectForKey:faceID];             <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">            <span class="comment">// no layer for faceID, create new face layer</span></span><br><span class="line">            layer = [<span class="keyword">self</span> makeFaceLayer];                                   <span class="comment">// 4</span></span><br><span class="line">            [<span class="keyword">self</span>.overlayLayer addSublayer:layer];</span><br><span class="line">            <span class="keyword">self</span>.faceLayers[faceID] = layer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        layer.transform = <span class="built_in">CATransform3DIdentity</span>;                            <span class="comment">// 1</span></span><br><span class="line">        layer.frame = face.bounds;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改人脸的倾斜角</span></span><br><span class="line">        <span class="keyword">if</span> (face.hasRollAngle) &#123;</span><br><span class="line">            <span class="built_in">CATransform3D</span> t = [<span class="keyword">self</span> transformForRollAngle:face.rollAngle];  <span class="comment">// 2</span></span><br><span class="line">            layer.transform = <span class="built_in">CATransform3DConcat</span>(layer.transform, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改人脸的偏转角</span></span><br><span class="line">        <span class="keyword">if</span> (face.hasYawAngle) &#123;</span><br><span class="line">            <span class="built_in">CATransform3D</span> t = [<span class="keyword">self</span> transformForYawAngle:face.yawAngle];    <span class="comment">// 4</span></span><br><span class="line">            layer.transform = <span class="built_in">CATransform3DConcat</span>(layer.transform, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *faceID <span class="keyword">in</span> lostFaces) &#123;                                   <span class="comment">// 6</span></span><br><span class="line">        <span class="built_in">CALayer</span> *layer = [<span class="keyword">self</span>.faceLayers objectForKey:faceID];</span><br><span class="line">        [layer removeFromSuperlayer];</span><br><span class="line">        [<span class="keyword">self</span>.faceLayers removeObjectForKey:faceID];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将设备坐标空间转换为视图空间对象集合</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)transformedFacesFromFaces:(<span class="built_in">NSArray</span> *)faces &#123;                   <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *transformedFaces = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVMetadataObject</span> *face <span class="keyword">in</span> faces) &#123;</span><br><span class="line">        <span class="built_in">AVMetadataObject</span> *transformedFace =                                 <span class="comment">// 3</span></span><br><span class="line">            [<span class="keyword">self</span>.previewLayer transformedMetadataObjectForMetadataObject:face];</span><br><span class="line">        [transformedFaces addObject:transformedFace];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformedFaces;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CALayer</span> *)makeFaceLayer &#123;</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    layer.borderWidth = <span class="number">5.0</span>f;</span><br><span class="line">    layer.borderColor =</span><br><span class="line">        [<span class="built_in">UIColor</span> colorWithRed:<span class="number">0.188</span> green:<span class="number">0.517</span> blue:<span class="number">0.877</span> alpha:<span class="number">1.000</span>].CGColor;</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rotate around Z-axis</span></span><br><span class="line">- (<span class="built_in">CATransform3D</span>)transformForRollAngle:(<span class="built_in">CGFloat</span>)rollAngleInDegrees &#123;        <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">CGFloat</span> rollAngleInRadians = THDegreesToRadians(rollAngleInDegrees);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DMakeRotation</span>(rollAngleInRadians, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rotate around Y-axis</span></span><br><span class="line">- (<span class="built_in">CATransform3D</span>)transformForYawAngle:(<span class="built_in">CGFloat</span>)yawAngleInDegrees &#123;          <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">CGFloat</span> yawAngleInRadians = THDegreesToRadians(yawAngleInDegrees);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CATransform3D</span> yawTransform =</span><br><span class="line">        <span class="built_in">CATransform3DMakeRotation</span>(yawAngleInRadians, <span class="number">0.0</span>f, <span class="number">-1.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CATransform3DConcat</span>(yawTransform, [<span class="keyword">self</span> orientationTransform]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-AVAudioPlayer简介</title>
    <url>/essay/AVFoundation/AVFoundation-AVAudioPlayer%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="使用System-Sound-Service播放音效"><a href="#使用System-Sound-Service播放音效" class="headerlink" title="使用System Sound Service播放音效"></a>使用System Sound Service播放音效</h1><p>参考 <a href></a></p>
<blockquote>
<p>步骤</p>
</blockquote>
<ol>
<li>调用<code>AudioServicesCreateSystemSoundID(   CFURLRef  inFileURL, SystemSoundID*   outSystemSoundID)</code>函数获得系统声音ID。</li>
<li>如果需要监听播放完成操作，则使用<code>AudioServicesAddSystemSoundCompletion(  SystemSoundID inSystemSoundID,
 CFRunLoopRef  inRunLoop, CFStringRef  inRunLoopMode, AudioServicesSystemSoundCompletionProc  inCompletionRoutine, void*  inClientData)</code>方法注册回调函数。</li>
<li>调用<code>AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID)</code>或者<code>AudioServicesPlayAlertSound(SystemSoundID inSystemSoundID)</code> 方法播放音效（后者带有震动效果）。</li>
</ol>
<a id="more"></a>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放完成回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param soundID    系统声音ID</span></span><br><span class="line"><span class="comment"> *  @param clientData 回调时传递的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> soundCompleteCallback(SystemSoundID soundID,<span class="keyword">void</span> * clientData)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"播放完成..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放音效文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param name 音频文件名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)playSoundEffect:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *audioFile=[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *fileUrl=[<span class="built_in">NSURL</span> fileURLWithPath:audioFile];</span><br><span class="line">    <span class="comment">//1.获得系统声音ID</span></span><br><span class="line">    SystemSoundID soundID=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * inFileUrl:音频文件url</span></span><br><span class="line"><span class="comment">     * outSystemSoundID:声音id（此函数会将音效文件加入到系统音频服务中并返回一个长整形ID）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AudioServicesCreateSystemSoundID((__bridge <span class="built_in">CFURLRef</span>)(fileUrl), &amp;soundID);</span><br><span class="line">    <span class="comment">//如果需要在播放完之后执行某些操作，可以调用如下方法注册一个播放完成回调函数</span></span><br><span class="line">    AudioServicesAddSystemSoundCompletion(soundID, <span class="literal">NULL</span>, <span class="literal">NULL</span>, soundCompleteCallback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//2.播放音频</span></span><br><span class="line">    AudioServicesPlaySystemSound(soundID);<span class="comment">//播放音效</span></span><br><span class="line"><span class="comment">//    AudioServicesPlayAlertSound(soundID);//播放音效并震动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AVAudioPlayer播放和录制音频"><a href="#AVAudioPlayer播放和录制音频" class="headerlink" title="AVAudioPlayer播放和录制音频"></a>AVAudioPlayer播放和录制音频</h1><blockquote>
<p>主要通过 AVAudioPlayer 和 AVAudioRecorder 类来实现。</p>
</blockquote>
<h2 id="AVAudioPlayer-简介"><a href="#AVAudioPlayer-简介" class="headerlink" title="AVAudioPlayer 简介"></a>AVAudioPlayer 简介</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>一般通过 使用本地音频文件的 NSURL 或者包含音频的内存的 NSData。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithContentsOfURL:(<span class="built_in">NSURL</span> *)url error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithData:(<span class="built_in">NSData</span> *)data error:(<span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>prepareToPlay</strong> 方法 可以取得需要的音频硬件并预加载 Audio Queue 的缓冲区。在创建的时候调用可以降低调用 <strong>play</strong> 方法和听到声音输出之间的延迟。</p>
<h3 id="对播放进行控制"><a href="#对播放进行控制" class="headerlink" title="对播放进行控制"></a>对播放进行控制</h3><blockquote>
<p>常见的 <code>play</code>、<code>stop</code>和 <code>pause</code>的播放暂停功能。<br>其中 stop 和 pause 的区别是 stop 方法会撤销调用 prepareToPlay时所做的设置，而 pause 方法不会。</p>
</blockquote>
<p>除此之外还有：</p>
<ul>
<li><strong>修改播放器的音量</strong> （volume）：从0.0（静音）到1.0（最大音量之间）。</li>
<li><strong>修改播放器的 pan 值</strong>：允许使用立体声播放声音，从 -1.0（极左）到 1.0（极右）。默认 0.0（居中）。</li>
<li><strong>调整播放率</strong> （rate）：需要配合 enableRate 使用。范围从 0.5（半数）到2.0（2倍数）。</li>
<li><strong>无缝循环</strong> (numberOfLoops): 播放 n+1次，若 n&lt;-1 则播放无限次直到被停止。</li>
<li><strong>音频计量</strong>： 可以读取音量力度的平均值和峰值。</li>
</ul>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-拍照和录像</title>
    <url>/essay/AVFoundation/AVFoundation-%E6%8B%8D%E7%85%A7%E5%92%8C%E5%BD%95%E5%83%8F/</url>
    <content><![CDATA[<blockquote>
<p>使用AV Foundation 捕捉照片和视频</p>
</blockquote>
<p>使用AVFoundation拍照和录制视频的一般步骤如下：</p>
<ol>
<li>创建<strong>AVCaptureSession</strong>对象。</li>
<li>使用<strong>AVCaptureDevice</strong>的静态方法获得需要使用的设备，例如拍照和录像就需要获得摄像头设备，录音就要获得麦克风设备。</li>
<li>利用输入设备AVCaptureDevice初始化<strong>AVCaptureDeviceInput</strong>对象。</li>
<li>初始化输出数据管理对象，如果要拍照就初始化AVCaptureStillImageOutput对象；如果拍摄视频就初始化AVCaptureMovieFileOutput对象。</li>
<li>将数据输入对象AVCaptureDeviceInput、数据输出对象<strong>AVCaptureOutput</strong>添加到媒体会话管理对象AVCaptureSession中。</li>
<li>创建视频预览图层<strong>AVCaptureVideoPreviewLayer</strong>并指定媒体会话，添加图层到显示容器中，调用AVCaptureSession的startRuning方法开始捕获。</li>
<li>将捕获的音频或视频数据输出到指定文件。</li>
</ol>
<a id="more"></a>
<p>主要用到的类：</p>
<ul>
<li>AVCaptureDeviceInput (输入设备)<ul>
<li>AVCaptureDevice </li>
</ul>
</li>
<li>AVCaptureSession （捕捉会话）</li>
<li>AVCaptureVideoPreviewLayer （展示层)</li>
<li>AVCaptureOutput （输出）<ul>
<li>AVCaptureStillImageOutput (捕捉图片)</li>
<li>AVCaptureAudioDataOutput </li>
<li>AVCaptureVideoDataOutput</li>
<li>AVCaptureFileOutput</li>
</ul>
</li>
</ul>
<h2 id="配置会话："><a href="#配置会话：" class="headerlink" title="配置会话："></a>配置会话：</h2><blockquote>
<p>简单配置会话</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化会话</span></span><br><span class="line">    _captureSession=[[<span class="built_in">AVCaptureSession</span> alloc]init];</span><br><span class="line">    <span class="keyword">if</span> ([_captureSession canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;<span class="comment">//设置分辨率</span></span><br><span class="line">        _captureSession.sessionPreset=<span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">        <span class="comment">//_captureSession.sessionPreset=AVCaptureSessionPresetHigh;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得视频捕捉设备</span></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *captureDevice=[<span class="keyword">self</span> getCameraDeviceWithPosition:<span class="built_in">AVCaptureDevicePositionBack</span>];<span class="comment">//取得后置摄像头</span></span><br><span class="line">    <span class="comment">//	AVCaptureDevice *videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];//获取默认摄像头</span></span><br><span class="line">    <span class="keyword">if</span> (!captureDevice) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取得后置摄像头时出现问题."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">NSError</span> *error=<span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//根据输入设备初始化设备输入对象，用于获得输入数据</span></span><br><span class="line">    _captureDeviceInput=[[<span class="built_in">AVCaptureDeviceInput</span> alloc]initWithDevice:captureDevice error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"取得设备输入对象时出错，错误原因：%@"</span>,error.localizedDescription);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取静态图片输出</span></span><br><span class="line">    _captureStillImageOutput=[[<span class="built_in">AVCaptureStillImageOutput</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *outputSettings = @&#123;<span class="built_in">AVVideoCodecKey</span>:<span class="built_in">AVVideoCodecJPEG</span>&#125;;</span><br><span class="line">    [_captureStillImageOutput setOutputSettings:outputSettings];<span class="comment">//输出设置</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将设备输入添加到会话中</span></span><br><span class="line">    <span class="keyword">if</span> ([_captureSession canAddInput:_captureDeviceInput]) &#123;</span><br><span class="line">        [_captureSession addInput:_captureDeviceInput];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将设备输出添加到会话中</span></span><br><span class="line">    <span class="keyword">if</span> ([_captureSession canAddOutput:_captureStillImageOutput]) &#123;</span><br><span class="line">        [_captureSession addOutput:_captureStillImageOutput];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建视频预览层，用于实时展示摄像头状态</span></span><br><span class="line">    _captureVideoPreviewLayer=[[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc]initWithSession:<span class="keyword">self</span>.captureSession];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CALayer</span> *layer=<span class="keyword">self</span>.viewContainer.layer;</span><br><span class="line">    layer.masksToBounds=<span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    _captureVideoPreviewLayer.frame=layer.bounds;</span><br><span class="line">    _captureVideoPreviewLayer.videoGravity=<span class="built_in">AVLayerVideoGravityResizeAspectFill</span>;<span class="comment">//填充模式</span></span><br><span class="line">    <span class="comment">//将视频预览层添加到界面中</span></span><br><span class="line">    \[layer addSublayer:_captureVideoPreviewLayer];</span><br></pre></td></tr></table></figure>
<h3 id="添加音频捕捉设备（麦克风）"><a href="#添加音频捕捉设备（麦克风）" class="headerlink" title="添加音频捕捉设备（麦克风）"></a>添加音频捕捉设备（麦克风）</h3><blockquote>
<p>输入不仅可以添加摄像头 ，页可以添加麦克风</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup default microphone</span></span><br><span class="line"><span class="built_in">AVCaptureDevice</span> *audioDevice =                                          <span class="comment">// 5</span></span><br><span class="line">    [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *audioInput =                                      <span class="comment">// 6</span></span><br><span class="line">    [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:audioDevice error:error];</span><br><span class="line"><span class="keyword">if</span> (audioInput) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:audioInput]) &#123;                 <span class="comment">// 7</span></span><br><span class="line">        [<span class="keyword">self</span>.captureSession addInput:audioInput];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加视频输出"><a href="#添加视频输出" class="headerlink" title="添加视频输出"></a>添加视频输出</h3><blockquote>
<p>输出不仅可以添加静态图片，可以添加视频输出</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Setup movie file output</span></span><br><span class="line"><span class="keyword">self</span>.movieOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc] init];             <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.movieOutput]) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.movieOutput];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动或者停止会话"><a href="#启动或者停止会话" class="headerlink" title="启动或者停止会话"></a>启动或者停止会话</h3><blockquote>
<p>启动会话，使它处于图片和视频捕捉状态。最好不要在主线程中启动。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startSession &#123;</span><br><span class="line">	<span class="keyword">if</span> (![<span class="keyword">self</span>.captureSession isRunning]) &#123;                                 <span class="comment">// 1</span></span><br><span class="line">		<span class="built_in">dispatch_async</span>([<span class="keyword">self</span> globalQueue], ^&#123;</span><br><span class="line">			[<span class="keyword">self</span>.captureSession startRunning];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopSession &#123;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession isRunning]) &#123;                                  <span class="comment">// 2</span></span><br><span class="line">		<span class="built_in">dispatch_async</span>([<span class="keyword">self</span> globalQueue], ^&#123;</span><br><span class="line">			[<span class="keyword">self</span>.captureSession stopRunning];</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="隐私访问权限"><a href="#隐私访问权限" class="headerlink" title="隐私访问权限"></a>隐私访问权限</h3><blockquote>
<p>xcode8 iOS10中后不添加权限会出错</p>
</blockquote>
<p>在info.plist文件添加对应的Key-Value:</p>
<p><img src="/res/AVFoundation/iOS10权限.png" alt></p>
<h2 id="聚焦-自动聚焦，手动聚焦"><a href="#聚焦-自动聚焦，手动聚焦" class="headerlink" title="聚焦(自动聚焦，手动聚焦)"></a>聚焦(自动聚焦，手动聚焦)</h2><h3 id="坐标空间转换"><a href="#坐标空间转换" class="headerlink" title="坐标空间转换"></a>坐标空间转换</h3><blockquote>
<p>如iPhone5屏幕坐标系左上角为（0，0）垂直时右下角为（320，568），水平时右下角（568，320）。<br>而设备坐标系基于摄像头的本地设置，左上角为（0，0）右下角为（1，1）。</p>
</blockquote>
<p><strong>AVCaptureVideoPreviewLayer</strong>定义了两个方法用于转换两者间的坐标：</p>
<ul>
<li><code>- (CGPoint)captureDevicePointOfInterestForPoint:(CGPoint)pointInLayer NS_AVAILABLE_IOS(6_0);</code> <ul>
<li>将屏幕坐标系转换为设备坐标系</li>
</ul>
</li>
<li><code>- (CGPoint)pointForCaptureDevicePointOfInterest:(CGPoint)captureDevicePointOfInterest NS_AVAILABLE_IOS(6_0);</code>  <ul>
<li>将设备坐标系转换为屏幕坐标系</li>
</ul>
</li>
</ul>
<h3 id="设置对焦模式"><a href="#设置对焦模式" class="headerlink" title="设置对焦模式"></a>设置对焦模式</h3><blockquote>
<p>对焦模式<code>AVCaptureFlashMode</code>有 三种 <strong>AVCaptureFlashModeOff</strong> 、<strong>AVCaptureFlashModeOn</strong> 和 <strong>AVCaptureFlashModeAuto</strong><br>配置设备时一定要判断一下设备是否支持，比如前置摄像头不支持对焦操作<br>修改设备配置时需要先锁定配置 <code>lockForConfiguration</code> 执行所需的修改，最后解锁设备 <code>unlockForConfiguration</code></p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFlashMode:(<span class="built_in">AVCaptureFlashMode</span>)flashMode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device.flashMode != flashMode &amp;&amp;</span><br><span class="line">        [device isFlashModeSupported:flashMode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            device.flashMode = flashMode;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点击对焦"><a href="#点击对焦" class="headerlink" title="点击对焦"></a>点击对焦</h3><blockquote>
<p>将屏幕坐标转换为捕捉设备坐标，然后将 <strong>focusPointOfInterest</strong> 设置为该坐标</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Focus Methods</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)cameraSupportsTapToFocus &#123;                                          <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] isFocusPointOfInterestSupported];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)focusAtPoint:(<span class="built_in">CGPoint</span>)point &#123;                                       <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device.isFocusPointOfInterestSupported &amp;&amp;                           <span class="comment">// 3</span></span><br><span class="line">        [device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeAutoFocus</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;                         <span class="comment">// 4</span></span><br><span class="line">            device.focusPointOfInterest = point;</span><br><span class="line">            device.focusMode = <span class="built_in">AVCaptureFocusModeAutoFocus</span>;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调整曝光模式"><a href="#调整曝光模式" class="headerlink" title="调整曝光模式"></a>调整曝光模式</h2><blockquote>
<p>与调整对焦模式类似，可以调整曝光模式 <code>device.exposureMode</code><br><strong>AVCaptureExposureModeLocked</strong> 锁定曝光 <strong>AVCaptureExposureModeAutoExpose</strong> 自动曝光 <strong>AVCaptureExposureModeContinuousAutoExposure</strong> 自动持续曝光 <strong>AVCaptureExposureModeCustom</strong> 自定义曝光 四个值</p>
</blockquote>
<h2 id="调整闪光灯模式"><a href="#调整闪光灯模式" class="headerlink" title="调整闪光灯模式"></a>调整闪光灯模式</h2><blockquote>
<p>与之前的两个类似</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)cameraHasTorch &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] hasTorch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">AVCaptureTorchMode</span>)torchMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> activeCamera] torchMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTorchMode:(<span class="built_in">AVCaptureTorchMode</span>)torchMode &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (device.torchMode != torchMode &amp;&amp;</span><br><span class="line">        [device isTorchModeSupported:torchMode]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">            device.torchMode = torchMode;</span><br><span class="line">            [device unlockForConfiguration];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切换摄像头"><a href="#切换摄像头" class="headerlink" title="切换摄像头"></a>切换摄像头</h2><blockquote>
<p>切换摄像头时担心停止会话和重启会话带来的开销，但是对会话进行改变时，要通过 <code>beginConfiguration</code> 和 <code>commitConfiguration</code> 进行单独的原子性的变化。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Device Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定位置的AVCaptureDevice **AVCaptureDevicePositionBack** 和 **AVCaptureDevicePositionFront**</span></span><br><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)cameraWithPosition:(<span class="built_in">AVCaptureDevicePosition</span>)position &#123; <span class="comment">// 1</span></span><br><span class="line">	<span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;                              <span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">if</span> (device.position == position) &#123;</span><br><span class="line">			<span class="keyword">return</span> device;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前捕捉会话对应的摄像头</span></span><br><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)activeCamera &#123;                                         <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeVideoInput.device;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前为激活的摄像头</span></span><br><span class="line">- (<span class="built_in">AVCaptureDevice</span> *)inactiveCamera &#123;                                       <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.cameraCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> activeCamera].position == <span class="built_in">AVCaptureDevicePositionBack</span>) &#123;  <span class="comment">// 5</span></span><br><span class="line">            device = [<span class="keyword">self</span> cameraWithPosition:<span class="built_in">AVCaptureDevicePositionFront</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            device = [<span class="keyword">self</span> cameraWithPosition:<span class="built_in">AVCaptureDevicePositionBack</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否超过一个摄像头可用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canSwitchCameras &#123;                                                  <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.cameraCount &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用的视频捕捉设备的数量</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)cameraCount &#123;                                                 <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)switchCameras &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> canSwitchCameras]) &#123;                                         <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *videoDevice = [<span class="keyword">self</span> inactiveCamera];                   <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *videoInput =</span><br><span class="line">    [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:videoDevice error:&amp;error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (videoInput) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.captureSession beginConfiguration];                           <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.captureSession removeInput:<span class="keyword">self</span>.activeVideoInput];            <span class="comment">// 4</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddInput:videoInput]) &#123;                 <span class="comment">// 5</span></span><br><span class="line">            [<span class="keyword">self</span>.captureSession addInput:videoInput];</span><br><span class="line">            <span class="keyword">self</span>.activeVideoInput = videoInput;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//若不能添加新输入则重新添加之前的输入</span></span><br><span class="line">            [<span class="keyword">self</span>.captureSession addInput:<span class="keyword">self</span>.activeVideoInput];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.captureSession commitConfiguration];                          <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];           <span class="comment">// 7</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拍照，获取静态图片"><a href="#拍照，获取静态图片" class="headerlink" title="拍照，获取静态图片"></a>拍照，获取静态图片</h2><blockquote>
<p><code>AVCaptureStillImageOutput</code> 用于捕捉静态图片，执行<code>- (void)captureStillImageAsynchronouslyFromConnection:(AVCaptureConnection *)connection completionHandler:(void (^)(CMSampleBufferRef imageDataSampleBuffer, NSError *error))handler;</code>方法来获取图片<br>使用 <code>ALAssetsLibrary</code>来将图片储存在照片中</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拍照</span></span><br><span class="line">- (<span class="keyword">void</span>)captureStillImage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureConnection</span> *connection =                                   </span><br><span class="line">        [<span class="keyword">self</span>.imageOutput connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection.isVideoOrientationSupported) &#123;                       </span><br><span class="line">        connection.videoOrientation = [<span class="keyword">self</span> currentVideoOrientation];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> handler = ^(<span class="built_in">CMSampleBufferRef</span> sampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *imageData =</span><br><span class="line">                [<span class="built_in">AVCaptureStillImageOutput</span></span><br><span class="line">                    jpegStillImageNSDataRepresentation:sampleBuffer];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithData:imageData];</span><br><span class="line">            [<span class="keyword">self</span> writeImageToAssetsLibrary:image];                         <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"NULL sampleBuffer: %@"</span>, [error localizedDescription]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Capture still image</span></span><br><span class="line">    [<span class="keyword">self</span>.imageOutput captureStillImageAsynchronouslyFromConnection:connection</span><br><span class="line">                                                  completionHandler:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存在本地照片</span></span><br><span class="line">- (<span class="keyword">void</span>)writeImageToAssetsLibrary:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line"></span><br><span class="line">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    [library writeImageToSavedPhotosAlbum:image.CGImage                     <span class="comment">// 3</span></span><br><span class="line">                              orientation:(<span class="built_in">NSInteger</span>)image.imageOrientation <span class="comment">// 4</span></span><br><span class="line">                          completionBlock:^(<span class="built_in">NSURL</span> *assetURL, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                                  [<span class="keyword">self</span> postThumbnailNotifification:image]; <span class="comment">// 5</span></span><br><span class="line">                              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                  <span class="keyword">id</span> message = [error localizedDescription];</span><br><span class="line">                                  <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, message);</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postThumbnailNotifification:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        [nc postNotificationName:THThumbnailCreatedNotification object:image];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="视频捕捉"><a href="#视频捕捉" class="headerlink" title="视频捕捉"></a>视频捕捉</h2><blockquote>
<p>使用<code>AVCaptureMovieFileOutput</code> 来捕捉视频<br>在录制开始时，在文件的最前面会写入一个最小化的头信息，随着录制的进行，片段按照一定周期写入，创建完整的头信息，这样就确保了当程序遇到崩溃或者中断时，影片仍然会以最后一个写入的片段为重点进行保存。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Video Capture Methods</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRecording &#123;                                                       <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.movieOutput.isRecording;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取处理当前视频捕捉连接的信息，对捕捉的视频数据配置一些核心属性</span></span><br><span class="line">- (<span class="keyword">void</span>)startRecording &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isRecording]) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">AVCaptureConnection</span> *videoConnection =                              <span class="comment">// 2</span></span><br><span class="line">            [<span class="keyword">self</span>.movieOutput connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">        <span class="comment">//视频方向</span></span><br><span class="line">		<span class="keyword">if</span> ([videoConnection isVideoOrientationSupported]) &#123;                <span class="comment">// 3</span></span><br><span class="line">			videoConnection.videoOrientation = <span class="keyword">self</span>.currentVideoOrientation;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//支持视频稳定</span></span><br><span class="line">		<span class="keyword">if</span> ([videoConnection isVideoStabilizationSupported]) &#123;              <span class="comment">// 4</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue] &lt; <span class="number">8.0</span>) &#123;</span><br><span class="line">                videoConnection.enablesVideoStabilizationWhenAvailable = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                videoConnection.preferredVideoStabilizationMode = <span class="built_in">AVCaptureVideoStabilizationModeAuto</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVCaptureDevice</span> *device = [<span class="keyword">self</span> activeCamera];</span><br><span class="line">        <span class="comment">//支持平滑对焦，即减慢摄像头镜头对焦的速度</span></span><br><span class="line">        <span class="keyword">if</span> (device.isSmoothAutoFocusSupported) &#123;                            <span class="comment">// 5</span></span><br><span class="line">            <span class="built_in">NSError</span> *error;</span><br><span class="line">            <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">                device.smoothAutoFocusEnabled = <span class="literal">NO</span>;</span><br><span class="line">                [device unlockForConfiguration];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.outputURL = [<span class="keyword">self</span> uniqueURL];                                  <span class="comment">// 6</span></span><br><span class="line">        <span class="comment">//开始录制</span></span><br><span class="line">		[<span class="keyword">self</span>.movieOutput startRecordingToOutputFileURL:<span class="keyword">self</span>.outputURL      <span class="comment">// 8</span></span><br><span class="line">                                      recordingDelegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CMTime</span>)recordedDuration &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.movieOutput.recordedDuration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//视频文件写入目录</span></span><br><span class="line">- (<span class="built_in">NSURL</span> *)uniqueURL &#123;                                                      <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *dirPath =</span><br><span class="line">        [fileManager temporaryDirectoryWithTemplateString:<span class="string">@"kamera.XXXXXX"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dirPath) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *filePath =</span><br><span class="line">            [dirPath stringByAppendingPathComponent:<span class="string">@"kamera_movie.mov"</span>];</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stopRecording &#123;                                                     <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isRecording]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.movieOutput stopRecording];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - AVCaptureFileOutputRecordingDelegate</span></span><br><span class="line"><span class="comment">//在AVCaptureFileOutputRecordingDelegate 实现中获取最终文件并写入</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput</span><br><span class="line">didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL</span><br><span class="line">      fromConnections:(<span class="built_in">NSArray</span> *)connections</span><br><span class="line">                error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;                                                            <span class="comment">// 1</span></span><br><span class="line">        [<span class="keyword">self</span>.delegate mediaCaptureFailedWithError:error];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> writeVideoToAssetsLibrary:[<span class="keyword">self</span>.outputURL <span class="keyword">copy</span>]];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">self</span>.outputURL = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeVideoToAssetsLibrary:(<span class="built_in">NSURL</span> *)videoURL &#123;</span><br><span class="line"></span><br><span class="line">    ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];              <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([library videoAtPathIsCompatibleWithSavedPhotosAlbum:videoURL]) &#123;   <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">        ALAssetsLibraryWriteVideoCompletionBlock completionBlock;</span><br><span class="line"></span><br><span class="line">        completionBlock = ^(<span class="built_in">NSURL</span> *assetURL, <span class="built_in">NSError</span> *error)&#123;               <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.delegate assetLibraryWriteFailedWithError:error];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="keyword">self</span> generateThumbnailForVideoAtURL:videoURL];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        [library writeVideoAtPathToSavedPhotosAlbum:videoURL                <span class="comment">// 8</span></span><br><span class="line">                                    completionBlock:completionBlock];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//视频缩略图</span></span><br><span class="line">- (<span class="keyword">void</span>)generateThumbnailForVideoAtURL:(<span class="built_in">NSURL</span> *)videoURL &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>([<span class="keyword">self</span> globalQueue], ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:videoURL];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAssetImageGenerator</span> *imageGenerator =                             <span class="comment">// 5</span></span><br><span class="line">            [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:asset];</span><br><span class="line">        imageGenerator.maximumSize = <span class="built_in">CGSizeMake</span>(<span class="number">100.0</span>f, <span class="number">0.0</span>f);</span><br><span class="line">        imageGenerator.appliesPreferredTrackTransform = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = [imageGenerator copyCGImageAtTime:kCMTimeZero <span class="comment">// 6</span></span><br><span class="line">                                                     actualTime:<span class="literal">NULL</span></span><br><span class="line">                                                          error:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;                        <span class="comment">// 7</span></span><br><span class="line">            [<span class="keyword">self</span> postThumbnailNotifification:image];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Recoding Destination URL</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">AVCaptureVideoOrientation</span>)currentVideoOrientation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureVideoOrientation</span> orientation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ([<span class="built_in">UIDevice</span> currentDevice].orientation) &#123;                         <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationPortrait</span>:</span><br><span class="line">            orientation = <span class="built_in">AVCaptureVideoOrientationPortrait</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationLandscapeRight</span>:</span><br><span class="line">            orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>:</span><br><span class="line">            orientation = <span class="built_in">AVCaptureVideoOrientationPortraitUpsideDown</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeRight</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-条码识别</title>
    <url>/essay/AVFoundation/AVFoundation-%E6%9D%A1%E7%A0%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>AVFoundation可以识别一维条码和二维码</p>
</blockquote>
<p>一维条码支持的类型有：<strong>UPC-E</strong> <strong>EAN-8</strong> <strong>EAN-13</strong> <strong>Code 39</strong> <strong>Code 93</strong> <strong>Code 128</strong> 交错式2of5码（iOS8以上） ITF （iOS8以上）；</p>
<p>二维码支持的类型有： <strong>QR</strong> <strong>Axtec</strong> <strong>PDF-417</strong> Data matrix(iOS8以上)</p>
<p>同样使用<strong>AVCaptureMetadataOutput</strong> ，和实现AVCaptureMetadataOutputObjectsDelegate代理</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改输出配置</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)setupSessionOutputs:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="keyword">self</span>.metadataOutput = [[<span class="built_in">AVCaptureMetadataOutput</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.metadataOutput]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.metadataOutput];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();</span><br><span class="line">        [<span class="keyword">self</span>.metadataOutput setMetadataObjectsDelegate:<span class="keyword">self</span></span><br><span class="line">                                                  queue:mainQueue];</span><br><span class="line">        <span class="comment">//感兴趣的扫描对象是 QR Code Azte Code 以及 UPC-E Code</span></span><br><span class="line">        <span class="built_in">NSArray</span> *types = @[<span class="built_in">AVMetadataObjectTypeQRCode</span>,                      <span class="comment">// 1</span></span><br><span class="line">                           <span class="built_in">AVMetadataObjectTypeAztecCode</span>,</span><br><span class="line">                           <span class="built_in">AVMetadataObjectTypeUPCECode</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.metadataOutput.metadataObjectTypes = types;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:</span><br><span class="line">                                       <span class="string">@"Failed to still image output."</span>&#125;;</span><br><span class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:THCameraErrorDomain</span><br><span class="line">                                     code:THCameraErrorFailedToAddOutput</span><br><span class="line">                                 userInfo:userInfo];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">didOutputMetadataObjects:(<span class="built_in">NSArray</span> *)metadataObjects</span><br><span class="line">       fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//metadataObjects提供了bounds 和 corners 属性</span></span><br><span class="line">    <span class="comment">//bounds提供了识别码的按坐标轴对齐的矩形边界</span></span><br><span class="line">    <span class="comment">//corners提供角点字典表示的数组</span></span><br><span class="line">	<span class="comment">//    [self.codeDetectionDelegate didDetectCodes:metadataObjects];            // 2</span></span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (metadataObjects.count&gt;<span class="number">0</span>) &#123;        </span><br><span class="line">	        [<span class="keyword">self</span>.session stopRunning];        </span><br><span class="line">	        <span class="built_in">AVMetadataMachineReadableCodeObject</span> *metadataObject = metadataObjects.firstObject;</span><br><span class="line">   		     <span class="comment">//输出扫描字符串        </span></span><br><span class="line">	        <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:metadataObject.stringValue message:<span class="string">@""</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@"ok"</span> otherButtonTitles: <span class="literal">nil</span>];        </span><br><span class="line">	        [alert show];</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>rectOfInterest</p>
</blockquote>
<p>如果不设置的话，就是AVCaptureVideoPreviewLayer中间区域（测试之后就是preview中间的横线）</p>
<p>设置rectOfInterest</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> size = <span class="keyword">self</span>.view.bounds.size;</span><br><span class="line"><span class="built_in">CGRect</span> cropRect = scanBg.frame;</span><br><span class="line"><span class="keyword">self</span>.output.rectOfInterest = <span class="built_in">CGRectMake</span>(cropRect.origin.y/size.height,cropRect.origin.x/size.width,cropRect.size.height/size.height,cropRect.size.width/size.width);</span><br></pre></td></tr></table></figure>
<p>捕捉设备坐标系相对于屏幕坐标系旋转90°。即 右上角为（0，0）左下角为（1，1）。</p>
<blockquote>
<p>rectOfInterest 与 sessionPreset</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> size = <span class="keyword">self</span>.view.bounds.size;</span><br><span class="line"><span class="built_in">CGRect</span> cropRect = <span class="built_in">CGRectMake</span>(<span class="number">40</span>, <span class="number">100</span>, <span class="number">240</span>, <span class="number">240</span>);</span><br><span class="line"><span class="built_in">CGFloat</span> p1 = size.height/size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> p2 = <span class="number">1920.</span>/<span class="number">1080.</span>;  <span class="comment">//使用了1920x1080的图像输出</span></span><br><span class="line"><span class="keyword">if</span> (p1 &lt; p2) &#123;</span><br><span class="line">  <span class="built_in">CGFloat</span> fixHeight = bounds.size.width * <span class="number">1920.</span> / <span class="number">1080.</span>;</span><br><span class="line">  <span class="built_in">CGFloat</span> fixPadding = (fixHeight - size.height)/<span class="number">2</span>;</span><br><span class="line">  captureOutput.rectOfInterest = <span class="built_in">CGRectMake</span>((cropRect.origin.y + fixPadding)/fixHeight,</span><br><span class="line">                                              cropRect.origin.x/size.width,</span><br><span class="line">                                              cropRect.size.height/fixHeight,</span><br><span class="line">                                              cropRect.size.width/size.width);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> fixWidth = bounds.size.height * <span class="number">1080.</span> / <span class="number">1920.</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> fixPadding = (fixWidth - size.width)/<span class="number">2</span>;</span><br><span class="line">    captureOutput.rectOfInterest = <span class="built_in">CGRectMake</span>(cropRect.origin.y/size.height,</span><br><span class="line">                                              (cropRect.origin.x + fixPadding)/fixWidth,</span><br><span class="line">                                              cropRect.size.height/size.height,</span><br><span class="line">                                              cropRect.size.width/fixWidth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>试了支付宝的扫描，发现几乎整个屏幕都是扫描灵敏区域。。不知道它是不是也用AVFoundation实现的。。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-绘制音频波形图AVAssetReader</title>
    <url>/essay/AVFoundation/AVFoundation-%E7%BB%98%E5%88%B6%E9%9F%B3%E9%A2%91%E6%B3%A2%E5%BD%A2%E5%9B%BEAVAssetReader/</url>
    <content><![CDATA[<blockquote>
<p>AVAssetReader 和 AVAssetWriter类提供的低级功能，能处理更复杂的媒体样本。</p>
</blockquote>
<h2 id="AVAssetReader-和-AVAssetWriter"><a href="#AVAssetReader-和-AVAssetWriter" class="headerlink" title="AVAssetReader 和 AVAssetWriter"></a>AVAssetReader 和 AVAssetWriter</h2><blockquote>
<p>AVAssetReader</p>
</blockquote>
<p>AVAssetReader 用于从 AVAsset示例中读取媒体样本。</p>
<p>通常会配置一个或多个<strong>AVAssetReaderOutput</strong>实例，并通过 <strong>copyNextSampleBuffer</strong> 方法访问音频和视频帧。</p>
<p>一个资源读取器的内部通道都是以多线程的方式不断提取下一个可用样本的。这样可以在系统请求资源时最小化时延。</p>
<a id="more"></a>
<blockquote>
<p>AVAssetWriter</p>
</blockquote>
<p>AVAssetWriter 用于对媒体资源进行编码并将其写入到容器文件中（如MPEG-4）。</p>
<p>通常由一个或多个<strong>AVAssetWriterInput</strong>对象配置，用于附加将包含要写入容器的媒体样本的<strong>CMSampleBuffer</strong>对象。</p>
<p>AVAssetWriter可用于实时操作和离线操作两种：</p>
<ul>
<li>实时。当处理实时资源时，比如从AVCaptureVideoDataOutput写入捕捉样本时，AVAssetWriterInput应该令<strong>expectsMediaDataInRealTime</strong>属性为YES类确保<strong>readyForMoreMediaData</strong>（指示保持数据样本交错的情况下是否可以附加更多信息）值被正确计算。</li>
<li>离线。当从离线资源中读取媒体资源时，比如从AVAssetReader读取样本buffer，仍然需要<strong>readyForMoreMediaData</strong>，再可以使用<strong>requestMediaDataWhenReadyOnQueue:usingBlock</strong>方法来控制数据的提供。</li>
</ul>
<h2 id="创建波形图"><a href="#创建波形图" class="headerlink" title="创建波形图"></a>创建波形图</h2><blockquote>
<p>创建波形需要<br><strong>读取</strong>:读取音频样本进行渲染，需要读取或者解压音频数据。<br><strong>缩减</strong>:读取到的样本远比我们需要的多，可以将样本分成小的样本块，并在每个样本块上找到最大值最小值和平均值。<br><strong>渲染</strong>:将缩减后的样本呈现在屏幕上。</p>
</blockquote>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><blockquote>
<p>使用AVAssetReader实例从AVAsset中读取音频样本并返回一个NSData对象</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//载入资源，读取asset样本</span></span><br><span class="line">+ (<span class="keyword">void</span>)loadAudioSamplesFromAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line">                  completionBlock:(THSampleDataCompletionBlock)completionBlock &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *tracks = <span class="string">@"tracks"</span>;</span><br><span class="line">    <span class="comment">//异步载入键对应的资源</span></span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracks] completionHandler:^&#123;   <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">//获取tracks键载入状态</span></span><br><span class="line">        <span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracks error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSData</span> *sampleData = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//如果载入成功，则从资源音频轨道中读取样本</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;                             <span class="comment">// 2</span></span><br><span class="line">            sampleData = [<span class="keyword">self</span> readAudioSamplesFromAsset:asset];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;                        <span class="comment">// 3</span></span><br><span class="line">            completionBlock(sampleData);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)readAudioSamplesFromAsset:(<span class="built_in">AVAsset</span> *)asset &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//创建AVAssetReader实例</span></span><br><span class="line">    <span class="built_in">AVAssetReader</span> *assetReader =                                            <span class="comment">// 1</span></span><br><span class="line">        [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:asset error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!assetReader) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error creating asset reader: %@"</span>, [error localizedDescription]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取资源中第一个音频轨道（最好是根据需求的媒体类型来获取轨道）</span></span><br><span class="line">    <span class="built_in">AVAssetTrack</span> *track =                                                   <span class="comment">// 2</span></span><br><span class="line">        [[asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] firstObject];</span><br><span class="line">    <span class="comment">//设置从资源轨道读取音频样本的解压设置，可以在AVAudioSettings.h文件中找到更多的键值</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *outputSettings = @&#123;                                       <span class="comment">// 3</span></span><br><span class="line">        <span class="built_in">AVFormatIDKey</span>               : @(kAudioFormatLinearPCM),</span><br><span class="line">        <span class="built_in">AVLinearPCMIsBigEndianKey</span>   : @NO,</span><br><span class="line">		<span class="built_in">AVLinearPCMIsFloatKey</span>		: @NO,</span><br><span class="line">		<span class="built_in">AVLinearPCMBitDepthKey</span>		: @(<span class="number">16</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建AVAssetReaderTrackOutput 作为AVAssetReader的输出，并调用startReading来允许资源管理器开启预收取样本数据</span></span><br><span class="line">    <span class="built_in">AVAssetReaderTrackOutput</span> *trackOutput =                                 <span class="comment">// 4</span></span><br><span class="line">        [[<span class="built_in">AVAssetReaderTrackOutput</span> alloc] initWithTrack:track</span><br><span class="line">                                         outputSettings:outputSettings];</span><br><span class="line">    </span><br><span class="line">    [assetReader addOutput:trackOutput];</span><br><span class="line">    </span><br><span class="line">    [assetReader startReading];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableData</span> *sampleData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (assetReader.status == <span class="built_in">AVAssetReaderStatusReading</span>) &#123;</span><br><span class="line">        <span class="comment">//调用跟踪输出的copyNextSampleBuffer开始每个迭代，每次都返回一个包含音频样本的下一个可用样本buffer</span></span><br><span class="line">        <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [trackOutput copyNextSampleBuffer];<span class="comment">// 5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sampleBuffer) &#123;</span><br><span class="line">            <span class="comment">//CMSampleBufferRef的音频样本被包含在CMBlockBufferRef类型中</span></span><br><span class="line">            <span class="built_in">CMBlockBufferRef</span> blockBufferRef =                               <span class="comment">// 6</span></span><br><span class="line">                <span class="built_in">CMSampleBufferGetDataBuffer</span>(sampleBuffer);</span><br><span class="line">            <span class="comment">//使用CMBlockBufferGetDataLength来确定blockBufferRef的长度，并使用一个16位带符号的整型数组来保存这写音频样本</span></span><br><span class="line">            size_t length = <span class="built_in">CMBlockBufferGetDataLength</span>(blockBufferRef);</span><br><span class="line">            SInt16 sampleBytes[length];</span><br><span class="line">            <span class="comment">//使用CMBlockBufferCopyDataBytes生成一个数组，内容来自CMBlockBufferRef包含的数据</span></span><br><span class="line">            <span class="built_in">CMBlockBufferCopyDataBytes</span>(blockBufferRef,                      <span class="comment">// 7</span></span><br><span class="line">                                       <span class="number">0</span>,</span><br><span class="line">                                       length,</span><br><span class="line">                                       sampleBytes);</span><br><span class="line">            <span class="comment">//将数组的内容附加到NSData实例后</span></span><br><span class="line">            [sampleData appendBytes:sampleBytes length:length];</span><br><span class="line">            <span class="comment">//CMSampleBufferInvalidate函数来指定样本buffer已经处理和不可再继续使用，</span></span><br><span class="line">            <span class="built_in">CMSampleBufferInvalidate</span>(sampleBuffer);                         <span class="comment">// 8</span></span><br><span class="line">            <span class="comment">//然后用CFRelease释放CMSampleBufferRef副本</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果资源读取器的状态为AVAssetReaderStatusCompleted表示数据被成功读取</span></span><br><span class="line">    <span class="keyword">if</span> (assetReader.status == <span class="built_in">AVAssetReaderStatusCompleted</span>) &#123;               <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> sampleData;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Failed to read audio samples from asset"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缩减音频样本"><a href="#缩减音频样本" class="headerlink" title="缩减音频样本"></a>缩减音频样本</h3><blockquote>
<p>处理带有音频信息的NSData对象，根据指定的大小，将样本分成一个个样本块，找到样本块中的最大样本，得到筛选结果。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)filteredSamplesForSize:(<span class="built_in">CGSize</span>)size &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//filteredSamples保存筛选的样本数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *filteredSamples = [[<span class="built_in">NSMutableArray</span> alloc] init];        <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//sampleCount表示样本总数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> sampleCount = <span class="keyword">self</span>.sampleData.length / <span class="keyword">sizeof</span>(SInt16);</span><br><span class="line">    <span class="comment">//binSize表示每个样本块的大小</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> binSize = sampleCount / size.width;</span><br><span class="line"></span><br><span class="line">    SInt16 *bytes = (SInt16 *) <span class="keyword">self</span>.sampleData.bytes;</span><br><span class="line">    </span><br><span class="line">    SInt16 maxSample = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//迭代全部音频样本集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; sampleCount; i += binSize) &#123;</span><br><span class="line">        <span class="comment">//样本块</span></span><br><span class="line">        SInt16 sampleBin[binSize];</span><br><span class="line">        <span class="comment">//使用CFSwapInt16LittleToHost函数确保样本是按主机内置的字节顺序处理的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> j = <span class="number">0</span>; j &lt; binSize; j++) &#123;                          <span class="comment">// 2</span></span><br><span class="line">			sampleBin[j] = <span class="built_in">CFSwapInt16LittleToHost</span>(bytes[i + j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到样本块中的最大绝对值,并存入筛选结果</span></span><br><span class="line">        SInt16 value = [<span class="keyword">self</span> maxValueInArray:sampleBin ofSize:binSize];     <span class="comment">// 3</span></span><br><span class="line">        [filteredSamples addObject:@(value)];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value &gt; maxSample) &#123;                                            <span class="comment">// 4</span></span><br><span class="line">            maxSample = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//约束筛选样本</span></span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = (size.height / <span class="number">2</span>) / maxSample;                    <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; filteredSamples.count; i++) &#123;                <span class="comment">// 6</span></span><br><span class="line">        filteredSamples[i] = @([filteredSamples[i] integerValue] * scaleFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filteredSamples;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到样本块中的最大绝对值</span></span><br><span class="line">- (SInt16)maxValueInArray:(SInt16[])values ofSize:(<span class="built_in">NSUInteger</span>)size &#123;</span><br><span class="line">    SInt16 maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (abs(values[i]) &gt; maxValue) &#123;</span><br><span class="line">            maxValue = abs(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="渲染音频样本"><a href="#渲染音频样本" class="headerlink" title="渲染音频样本"></a>渲染音频样本</h3><blockquote>
<p>创建UIView子类, 使用<strong>QuartzCore</strong>渲染筛选后的结果</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="comment">//适当缩放上下文</span></span><br><span class="line">	<span class="built_in">CGContextScaleCTM</span>(context, THWidthScaling, THHeightScaling);            <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">//适当在x y 轴上偏移</span></span><br><span class="line">	<span class="built_in">CGFloat</span> xOffset = <span class="keyword">self</span>.bounds.size.width -</span><br><span class="line">                     (<span class="keyword">self</span>.bounds.size.width * THWidthScaling);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">CGFloat</span> yOffset = <span class="keyword">self</span>.bounds.size.height -</span><br><span class="line">                     (<span class="keyword">self</span>.bounds.size.height * THHeightScaling);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, xOffset / <span class="number">2</span>, yOffset / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//获取筛选后的音频样本</span></span><br><span class="line">	<span class="built_in">NSArray</span> *filteredSamples =                                              <span class="comment">// 2</span></span><br><span class="line">        [<span class="keyword">self</span>.filter filteredSamplesForSize:<span class="keyword">self</span>.bounds.size];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGFloat</span> midY = <span class="built_in">CGRectGetMidY</span>(rect);</span><br><span class="line">    <span class="comment">//创建CGMutablePathRef对象 用来绘制Bezier路径的上半部</span></span><br><span class="line">	<span class="built_in">CGMutablePathRef</span> halfPath = <span class="built_in">CGPathCreateMutable</span>();                      <span class="comment">// 3</span></span><br><span class="line">	<span class="built_in">CGPathMoveToPoint</span>(halfPath, <span class="literal">NULL</span>, <span class="number">0.0</span>f, midY);</span><br><span class="line">    <span class="comment">//迭代样本 每次向路径中添加一个点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; filteredSamples.count; i++) &#123;</span><br><span class="line">		<span class="keyword">float</span> sample = [filteredSamples[i] floatValue];</span><br><span class="line">		<span class="built_in">CGPathAddLineToPoint</span>(halfPath, <span class="literal">NULL</span>, i, midY - sample);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGPathAddLineToPoint</span>(halfPath, <span class="literal">NULL</span>, filteredSamples.count, midY);</span><br><span class="line">    <span class="comment">//绘制完整波形</span></span><br><span class="line">	<span class="built_in">CGMutablePathRef</span> fullPath = <span class="built_in">CGPathCreateMutable</span>();                      <span class="comment">// 4</span></span><br><span class="line">	<span class="built_in">CGPathAddPath</span>(fullPath, <span class="literal">NULL</span>, halfPath);</span><br><span class="line">w</span><br><span class="line">	<span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;                <span class="comment">// 5</span></span><br><span class="line">	transform = <span class="built_in">CGAffineTransformTranslate</span>(transform, <span class="number">0</span>, <span class="built_in">CGRectGetHeight</span>(rect));</span><br><span class="line">	transform = <span class="built_in">CGAffineTransformScale</span>(transform, <span class="number">1.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">	<span class="built_in">CGPathAddPath</span>(fullPath, &amp;transform, halfPath);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CGContextAddPath</span>(context, fullPath);                                    <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, <span class="keyword">self</span>.waveColor.CGColor);</span><br><span class="line">    <span class="built_in">CGContextDrawPath</span>(context, kCGPathFill);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPathRelease</span>(halfPath);                                                <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">CGPathRelease</span>(fullPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-缩放</title>
    <url>/essay/AVFoundation/AVFoundation-%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<h2 id="iOS7以前使用AVCaptureConnection"><a href="#iOS7以前使用AVCaptureConnection" class="headerlink" title="iOS7以前使用AVCaptureConnection"></a>iOS7以前使用AVCaptureConnection</h2><blockquote>
<p>通过 <strong>AVCaptureConnection</strong> 的属性对摄像头缩放进行有限制的支持，开发者可以通过调整连接缩放的值从默认的1.0增加到 <code>videoMaxScaleAndCropFactor</code>属性定义的最大值</p>
</blockquote>
<p>需要用到AVCaptureConnection的两个属性</p>
<ul>
<li>@property(nonatomic) CGFloat videoScaleAndCropFactor</li>
<li>@property(nonatomic, readonly) CGFloat videoMaxScaleAndCropFactor</li>
</ul>
<p>videoScaleAndCropFactor这个属性取值范围是1.0-videoMaxScaleAndCropFactor</p>
<a id="more"></a>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureStillImageOutput</span>* output = (<span class="built_in">AVCaptureStillImageOutput</span>*)[<span class="keyword">self</span>.captureSession.outputs objectAtIndex:<span class="number">0</span>];</span><br><span class="line"> <span class="built_in">AVCaptureConnection</span> *videoConnection = [output connectionWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"> <span class="built_in">CGFloat</span> maxScale = videoConnection.videoMaxScaleAndCropFactor;</span><br><span class="line"> <span class="built_in">CGFloat</span> zoom = maxScale / <span class="number">50</span>;</span><br><span class="line"> <span class="keyword">if</span> (zoom &lt; <span class="number">1.0</span>f || zoom &gt; maxScale)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> videoConnection.videoScaleAndCropFactor += zoom;</span><br><span class="line"> <span class="keyword">self</span>.preVideoView.transform = <span class="built_in">CGAffineTransformScale</span>(<span class="keyword">self</span>.preVideoView.transform, zoom, zoom);</span><br></pre></td></tr></table></figure>
<h2 id="iOS7以后-使用-AVCaptureDevice"><a href="#iOS7以后-使用-AVCaptureDevice" class="headerlink" title="iOS7以后 使用 AVCaptureDevice"></a>iOS7以后 使用 AVCaptureDevice</h2><blockquote>
<p><strong>AVCaptureDevice</strong> 提供了属性 videoZoomFactor用于控制捕捉设备的缩放等级，这个值最小为1.0，最大值由捕捉设备的 activeFormat 值确定</p>
</blockquote>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//videoMaxZoomFactor值大于1.0，则捕捉设备支持缩放功能</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cameraSupportsZoom &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">self</span>.activeCamera.activeFormat.videoMaxZoomFactor &gt; <span class="number">1.0</span>f;        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确定最大缩放因子，4.0f是随意设置的</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)maxZoomFactor &#123;</span><br><span class="line">	<span class="keyword">return</span> MIN(<span class="keyword">self</span>.activeCamera.activeFormat.videoMaxZoomFactor, <span class="number">4.0</span>f);    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setZoomValue:(<span class="built_in">CGFloat</span>)zoomValue &#123;                                   <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">self</span>.activeCamera.isRampingVideoZoom) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSError</span> *error;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.activeCamera lockForConfiguration:&amp;error]) &#123;              <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Provide linear feel to zoom slider</span></span><br><span class="line">			<span class="built_in">CGFloat</span> zoomFactor = pow([<span class="keyword">self</span> maxZoomFactor], zoomValue);      <span class="comment">// 5</span></span><br><span class="line">            <span class="comment">//应用程序提供的缩放范围1X到4X 是指数形式的，所以要提供范围线性增长的感觉</span></span><br><span class="line">            <span class="keyword">self</span>.activeCamera.videoZoomFactor = zoomFactor;</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span>.activeCamera unlockForConfiguration];                     <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.delegate deviceConfigurationFailedWithError:error];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加监听缩放"><a href="#添加监听缩放" class="headerlink" title="添加监听缩放"></a>添加监听缩放</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupSessionInputs:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	<span class="built_in">BOOL</span> success = [<span class="keyword">super</span> setupSessionInputs:error];                        <span class="comment">// 1</span></span><br><span class="line">	<span class="keyword">if</span> (success) &#123;</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera addObserver:<span class="keyword">self</span>                                 <span class="comment">// 2</span></span><br><span class="line">							forKeyPath:<span class="string">@"videoZoomFactor"</span></span><br><span class="line">							   options:<span class="number">0</span></span><br><span class="line">							   context:&amp;THRampingVideoZoomFactorContext];</span><br><span class="line">		[<span class="keyword">self</span>.activeCamera addObserver:<span class="keyword">self</span>                                 <span class="comment">// 3</span></span><br><span class="line">							forKeyPath:<span class="string">@"rampingVideoZoom"</span></span><br><span class="line">							   options:<span class="number">0</span></span><br><span class="line">							   context:&amp;THRampingVideoZoomContext];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">					  ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">						change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">					   context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (context == &amp;THRampingVideoZoomContext) &#123;</span><br><span class="line">        [<span class="keyword">self</span> updateZoomingDelegate];                                       <span class="comment">// 4</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == &amp;THRampingVideoZoomFactorContext) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">self</span>.activeCamera.isRampingVideoZoom) &#123;</span><br><span class="line">			[<span class="keyword">self</span> updateZoomingDelegate];                                   <span class="comment">// 5</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		[<span class="keyword">super</span> observeValueForKeyPath:keyPath</span><br><span class="line">							 ofObject:object</span><br><span class="line">							   change:change</span><br><span class="line">							  context:context];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-视频处理</title>
    <url>/essay/AVFoundation/AVFoundation-%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>之前在 <a href="../AVFoundation拍照和录像/">AVFoundation拍照和录像</a> 中使用 <strong>AVCaptureMovieFileOutput</strong>类来捕捉 QuickTime影片，这个类定义了捕捉视频数据的简单方法。当对捕捉到的视频数据进行更底层的操作时，就需要用到 <strong>AVCaptureVideoDataOutput</strong></p>
</blockquote>
<h2 id="AVCaptureVideoDataOutputSampleBufferDelegate"><a href="#AVCaptureVideoDataOutputSampleBufferDelegate" class="headerlink" title="AVCaptureVideoDataOutputSampleBufferDelegate"></a>AVCaptureVideoDataOutputSampleBufferDelegate</h2><blockquote>
<p>与AVCaptureMovieFileOutput的委托回调不同，AVCaptureVideoDataOutput的委托回调为AVCaptureVideoDataOutputSampleBufferDelegate</p>
</blockquote>
<p>它定义了一下两个方法：</p>
<ul>
<li><code>- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection;</code><ul>
<li>每当有一个视频帧写入该方法就会被调用</li>
</ul>
</li>
<li><code>- (void)captureOutput:(AVCaptureOutput *)captureOutput didDropSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection NS_AVAILABLE(10_7, 6_0);</code><ul>
<li>每当一个迟到的视频帧被丢弃时，就会被调用。通常是因为 在didOutputSampleBuffer中调用了耗时的操作。</li>
</ul>
</li>
</ul>
<h3 id="CMSampleBufferRef"><a href="#CMSampleBufferRef" class="headerlink" title="CMSampleBufferRef"></a>CMSampleBufferRef</h3><blockquote>
<p>CMSampleBufferRef将基本的样本数据进行封装并提供格式和时间信息，还会家伙是哪个所有在转换和处理数据时用到的元数据。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>样本数据 <strong>CVImageBufferRef</strong><ul>
<li><code>CVImageBufferRef  pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer)</code> </li>
</ul>
</li>
<li>格式信息 <strong>CMFormatDescriptionRef</strong> <ul>
<li><code>CMFormatDescriptionRef formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer);</code> </li>
</ul>
</li>
<li>时间信息 <strong>CMTime</strong> </li>
<li>附加元数据 <code>CMGetAttachment 获取</code></li>
</ul>
<h2 id="AVCaptureVideoDataOutput"><a href="#AVCaptureVideoDataOutput" class="headerlink" title="AVCaptureVideoDataOutput"></a>AVCaptureVideoDataOutput</h2><blockquote>
<p>配置</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupSessionOutputs:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">self</span>.videoDataOutput = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.videoDataOutput.alwaysDiscardsLateVideoFrames = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">self</span>.videoDataOutput.videoSettings =</span><br><span class="line">    <span class="comment">//色度子抽样初始格式为 420v，不过openGL ES一般会使用bgra</span></span><br><span class="line">    @&#123;(<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	[<span class="keyword">self</span>.videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span></span><br><span class="line">                                            queue:dispatch_get_main_queue()];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.captureSession canAddOutput:<span class="keyword">self</span>.videoDataOutput]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.captureSession addOutput:<span class="keyword">self</span>.videoDataOutput];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">       fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OpenGL-ES处理数据，将视频数据贴在立方体上"><a href="#OpenGL-ES处理数据，将视频数据贴在立方体上" class="headerlink" title="OpenGL ES处理数据，将视频数据贴在立方体上"></a>OpenGL ES处理数据，将视频数据贴在立方体上</h2><p>OpenGL ES 参考<br><a href="https://developer.apple.com/library/content/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Apple guide - About OpenGl ES</a><br><a href="https://www.raywenderlich.com/3664/opengl-tutorial-for-ios-opengl-es-2-0" target="_blank" rel="noopener">OpenGL Tutorial for iOS: OpenGL ES 2.0</a><br><a href="http://blog.csdn.net/column/details/opengl-es2-ios.html" target="_blank" rel="noopener">OpenGL ES 2.0 iOS教程</a></p>
<h3 id="创建CVOpenGLESTextureCacheCreate"><a href="#创建CVOpenGLESTextureCacheCreate" class="headerlink" title="创建CVOpenGLESTextureCacheCreate"></a>创建CVOpenGLESTextureCacheCreate</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"THCameraController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;OpenGLES/ES2/gl.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;OpenGLES/ES2/glext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">THCameraController</span> () &lt;<span class="title">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) EAGLContext *context;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput;</span><br><span class="line"><span class="comment">//Core Video 提供了CVOpenGLESTextureCacheRef 作为Core Vide像素buffer和OpenGL ES贴图之间的桥梁。</span></span><br><span class="line"><span class="comment">//缓存的目的是减少数据从CPU何GPU之间转移的消耗</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) CVOpenGLESTextureCacheRef textureCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) CVOpenGLESTextureRef cameraTexture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">THCameraController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithContext:(EAGLContext *)context &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _context = context;</span><br><span class="line">        <span class="comment">//这个函数关键是后备EAGLContext和textureCache指针</span></span><br><span class="line">        CVReturn err = CVOpenGLESTextureCacheCreate(kCFAllocatorDefault,</span><br><span class="line">                                                    <span class="literal">NULL</span>,</span><br><span class="line">                                                    _context,</span><br><span class="line">                                                    <span class="literal">NULL</span>,</span><br><span class="line">                                                    &amp;_textureCache);</span><br><span class="line">        <span class="keyword">if</span> (err != kCVReturnSuccess) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Error creating texture cache. %d"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建OpenGL-ES贴图"><a href="#创建OpenGL-ES贴图" class="headerlink" title="创建OpenGL ES贴图"></a>创建OpenGL ES贴图</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">       fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    CVReturn err;</span><br><span class="line">    <span class="comment">//从sampleBuffer中获取数据</span></span><br><span class="line">	CVImageBufferRef pixelBuffer =                                          <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line">    <span class="comment">//获取视频帧维度 返回带有宽高的CMVideoDimensions</span></span><br><span class="line">    <span class="built_in">CMFormatDescriptionRef</span> formatDescription =                              <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">CMSampleBufferGetFormatDescription</span>(sampleBuffer);</span><br><span class="line">    <span class="built_in">CMVideoDimensions</span> dimensions =</span><br><span class="line">        <span class="built_in">CMVideoFormatDescriptionGetDimensions</span>(formatDescription);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CVOpenGLESTextureCacheCreateTextureFromImage创建贴图</span></span><br><span class="line">    err = CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault, <span class="comment">// 3</span></span><br><span class="line">                                                       _textureCache,</span><br><span class="line">                                                       pixelBuffer,</span><br><span class="line">                                                       <span class="literal">NULL</span>,</span><br><span class="line">                                                       GL_TEXTURE_2D,</span><br><span class="line">                                                       GL_RGBA,</span><br><span class="line">                                                       dimensions.height,</span><br><span class="line">                                                       dimensions.height,</span><br><span class="line">                                                       GL_BGRA,</span><br><span class="line">                                                       GL_UNSIGNED_BYTE,</span><br><span class="line">                                                       <span class="number">0</span>,</span><br><span class="line">                                                       &amp;_cameraTexture);</span><br><span class="line">    <span class="comment">//GLenum GLuint 用于将贴图对象与旋转的小方块表面进行核实的绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        GLenum target = CVOpenGLESTextureGetTarget(_cameraTexture);         <span class="comment">// 4</span></span><br><span class="line">        GLuint name = CVOpenGLESTextureGetName(_cameraTexture);</span><br><span class="line">        [<span class="keyword">self</span>.textureDelegate textureCreatedWithTarget:target name:name];   <span class="comment">// 5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error at CVOpenGLESTextureCacheCreateTextureFromImage %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> cleanupTextures];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放贴图并刷新贴图缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)cleanupTextures &#123;                                                   <span class="comment">// 6</span></span><br><span class="line">    <span class="keyword">if</span> (_cameraTexture) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(_cameraTexture);</span><br><span class="line">        _cameraTexture = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CVOpenGLESTextureCacheFlush(_textureCache, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-avspeechsynthesizer文字转语音</title>
    <url>/essay/AVFoundation/AVFoundation-avspeechsynthesizer%E6%96%87%E5%AD%97%E8%BD%AC%E8%AF%AD%E9%9F%B3/</url>
    <content><![CDATA[<h2 id="AVSpeechSynthesizer-文字转语音"><a href="#AVSpeechSynthesizer-文字转语音" class="headerlink" title="AVSpeechSynthesizer 文字转语音"></a>AVSpeechSynthesizer 文字转语音</h2><blockquote>
<p>  简单示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">AVSpeechSynthesizer</span> *synthesizer = [<span class="built_in">AVSpeechSynthesizer</span> new];</span><br><span class="line"><span class="built_in">AVSpeechUtterance</span> * utterance = [[<span class="built_in">AVSpeechUtterance</span> alloc] initWithString:<span class="string">@"需要转化的文字"</span>];</span><br><span class="line"><span class="comment">//语音合成器会生成音频</span></span><br><span class="line">[synthesizer speakUtterance:utterance];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定声音：</p>
</blockquote>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置语言类别（不能被识别，返回值为nil）</span></span><br><span class="line"><span class="built_in">AVSpeechSynthesisVoice</span> *voice = [<span class="built_in">AVSpeechSynthesisVoice</span> voiceWithLanguage:<span class="string">@"en-US"</span>];</span><br><span class="line">utterance.voice = voiceType;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>语速：</p>
</blockquote>
<pre><code class="objc"><span class="comment">//设置语速快慢</span>
utterance.rate *= <span class="number">0.5</span>;    
</code></pre>
<blockquote>
<p>队列中插入语音</p>
</blockquote>
<p>使用 <a href="https://github.com/quentinhayot/QHSpeechSynthesizerQueue" target="_blank" rel="noopener">https://github.com/quentinhayot/QHSpeechSynthesizerQueue</a></p>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation-高帧率捕捉</title>
    <url>/essay/AVFoundation/AVFoundation-%E9%AB%98%E5%B8%A7%E7%8E%87%E6%8D%95%E6%8D%89/</url>
    <content><![CDATA[<blockquote>
<p>以高帧率（FPS）捕捉视频内容带来很多好处</p>
</blockquote>
<p><strong>AVCaptureDeviceFormat</strong>实例具有 <code>videoSupportedFrameRateRanges</code> 属性，它包含一个<strong>AVFrameRateRange</strong>对象数组，其中带有格式所支持的最小帧率、最大帧率和时长信息。</p>
<blockquote>
<p>确定是否支持高帧率</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AVCaptureDevice</span> (<span class="title">THAdditions</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否支持高帧率</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)supportsHighFrameRateCapture &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) &#123;                            <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> findHighestQualityOfService].isHighFrameRate;              <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找设备所支持的帧率等信息</span></span><br><span class="line">- (THQualityOfService *)findHighestQualityOfService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVCaptureDeviceFormat</span> *maxFormat = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVFrameRateRange</span> *maxFrameRateRange = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureDeviceFormat</span> *format <span class="keyword">in</span> <span class="keyword">self</span>.formats) &#123;</span><br><span class="line"></span><br><span class="line">        FourCharCode codecType =                                            <span class="comment">// 3</span></span><br><span class="line">            <span class="built_in">CMVideoFormatDescriptionGetCodecType</span>(format.formatDescription);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (codecType == kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange) &#123; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSArray</span> *frameRateRanges = format.videoSupportedFrameRateRanges;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">AVFrameRateRange</span> *range <span class="keyword">in</span> frameRateRanges) &#123;              <span class="comment">// 5</span></span><br><span class="line">                <span class="keyword">if</span> (range.maxFrameRate &gt; maxFrameRateRange.maxFrameRate) &#123;</span><br><span class="line">                    maxFormat = format;</span><br><span class="line">                    maxFrameRateRange = range;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [THQualityOfService qosWithFormat:maxFormat                      <span class="comment">// 6</span></span><br><span class="line">                              frameRateRange:maxFrameRateRange];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启高帧率</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)enableMaxFrameRateCapture:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"></span><br><span class="line">    THQualityOfService *qos = [<span class="keyword">self</span> findHighestQualityOfService];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qos.isHighFrameRate) &#123;                                             <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *message = <span class="string">@"Device does not support high FPS capture"</span>;</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : message&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSUInteger</span> code = THCameraErrorHighFrameRateCaptureNotSupported;</span><br><span class="line"></span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:THCameraErrorDomain</span><br><span class="line">                                         code:code</span><br><span class="line">                                     userInfo:userInfo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> lockForConfiguration:error]) &#123;                                <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">CMTime</span> minFrameDuration = qos.frameRateRange.minFrameDuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.activeFormat = qos.format;                                     <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">self</span>.activeVideoMinFrameDuration = minFrameDuration;                <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">self</span>.activeVideoMaxFrameDuration = minFrameDuration;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> unlockForConfiguration];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>辅助类</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">THQualityOfService</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)qosWithFormat:(<span class="built_in">AVCaptureDeviceFormat</span> *)format</span><br><span class="line">               frameRateRange:(<span class="built_in">AVFrameRateRange</span> *)frameRateRange &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithFormat:format frameRateRange:frameRateRange];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFormat:(<span class="built_in">AVCaptureDeviceFormat</span> *)format</span><br><span class="line">                frameRateRange:(<span class="built_in">AVFrameRateRange</span> *)frameRateRange &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _format = format;</span><br><span class="line">        _frameRateRange = frameRateRange;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于30就看成高帧率</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isHighFrameRate &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.frameRateRange.maxFrameRate &gt; <span class="number">30.0</span>f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>AudioToolbox-播放和录制音频</title>
    <url>/essay/AVFoundation/AudioToolbox-%E6%92%AD%E6%94%BE%E5%92%8C%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<h1 id="使用System-Sound-Service播放音效"><a href="#使用System-Sound-Service播放音效" class="headerlink" title="使用System Sound Service播放音效"></a>使用System Sound Service播放音效</h1><p>参考 <a href="http://www.cnblogs.com/kenshincui/p/4186022.html" target="_blank" rel="noopener">http://www.cnblogs.com/kenshincui/p/4186022.html</a></p>
<blockquote>
<p>步骤</p>
</blockquote>
<ol>
<li>调用<code>AudioServicesCreateSystemSoundID(   CFURLRef  inFileURL, SystemSoundID*   outSystemSoundID)</code>函数获得系统声音ID。</li>
<li>如果需要监听播放完成操作，则使用<code>AudioServicesAddSystemSoundCompletion(  SystemSoundID inSystemSoundID,
 CFRunLoopRef  inRunLoop, CFStringRef  inRunLoopMode, AudioServicesSystemSoundCompletionProc  inCompletionRoutine, void*  inClientData)</code>方法注册回调函数。</li>
<li>调用<code>AudioServicesPlaySystemSound(SystemSoundID inSystemSoundID)</code>或者<code>AudioServicesPlayAlertSound(SystemSoundID inSystemSoundID)</code> 方法播放音效（后者带有震动效果）。</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AudioToolbox/AudioToolbox.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放完成回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param soundID    系统声音ID</span></span><br><span class="line"><span class="comment"> *  @param clientData 回调时传递的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> soundCompleteCallback(SystemSoundID soundID,<span class="keyword">void</span> * clientData)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"播放完成..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  播放音效文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param name 音频文件名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">-(<span class="keyword">void</span>)playSoundEffect:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *audioFile=[[<span class="built_in">NSBundle</span> mainBundle] pathForResource:name ofType:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *fileUrl=[<span class="built_in">NSURL</span> fileURLWithPath:audioFile];</span><br><span class="line">    <span class="comment">//1.获得系统声音ID</span></span><br><span class="line">    SystemSoundID soundID=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * inFileUrl:音频文件url</span></span><br><span class="line"><span class="comment">     * outSystemSoundID:声音id（此函数会将音效文件加入到系统音频服务中并返回一个长整形ID）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AudioServicesCreateSystemSoundID((__bridge <span class="built_in">CFURLRef</span>)(fileUrl), &amp;soundID);</span><br><span class="line">    <span class="comment">//如果需要在播放完之后执行某些操作，可以调用如下方法注册一个播放完成回调函数</span></span><br><span class="line">    AudioServicesAddSystemSoundCompletion(soundID, <span class="literal">NULL</span>, <span class="literal">NULL</span>, soundCompleteCallback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//2.播放音频</span></span><br><span class="line">    AudioServicesPlaySystemSound(soundID);<span class="comment">//播放音效</span></span><br><span class="line"><span class="comment">//    AudioServicesPlayAlertSound(soundID);//播放音效并震动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AVAudioPlayer播放音频"><a href="#AVAudioPlayer播放音频" class="headerlink" title="AVAudioPlayer播放音频"></a>AVAudioPlayer播放音频</h1><h2 id="AVAudioPlayer-简介"><a href="#AVAudioPlayer-简介" class="headerlink" title="AVAudioPlayer 简介"></a>AVAudioPlayer 简介</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><em>一般通过 使用本地音频文件的 NSURL 或者包含音频的内存的 NSData。</em></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithContentsOfURL:(<span class="built_in">NSURL</span> *)url error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithData:(<span class="built_in">NSData</span> *)data error:(<span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>
<p>使用 <strong>prepareToPlay</strong> 方法 可以取得需要的音频硬件并预加载 Audio Queue 的缓冲区。在创建的时候调用可以降低调用 <strong>play</strong> 方法和听到声音输出之间的延迟。</p>
<h3 id="对播放进行控制"><a href="#对播放进行控制" class="headerlink" title="对播放进行控制"></a>对播放进行控制</h3><blockquote>
<p>常见的 <code>play</code>、<code>stop</code>和 <code>pause</code>的播放暂停功能。<br>其中 stop 和 pause 的区别是 stop 方法会撤销调用 prepareToPlay时所做的设置，而 pause 方法不会。</p>
</blockquote>
<p>除此之外还有：</p>
<ul>
<li><strong>修改播放器的音量</strong> （volume）：从0.0（静音）到1.0（最大音量之间）。</li>
<li><strong>修改播放器的 pan 值</strong>：允许使用立体声播放声音，从 -1.0（极左）到 1.0（极右）。默认 0.0（居中）。</li>
<li><strong>调整播放率</strong> （rate）：需要配合 enableRate 使用。范围从 0.5（半数）到2.0（2倍数）。</li>
<li><strong>无缝循环</strong> (numberOfLoops): 播放 n+1次，若 n&lt;-1 则播放无限次直到被停止。</li>
<li><strong>音频计量</strong>： 可以读取音量力度的平均值和峰值。</li>
</ul>
<h3 id="配置音频会话-后台播放"><a href="#配置音频会话-后台播放" class="headerlink" title="配置音频会话,后台播放"></a>配置音频会话,后台播放</h3><p><em>默认会话类型为 <code>AVAudioSessionCategorySoloAmbient</code> 这个类型不能后台播放</em></p>
<blockquote>
<p>添加后台播放 -设置会话：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">AVAudioSession</span> *session = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line">   <span class="built_in">NSError</span> *error;</span><br><span class="line">   <span class="comment">//设置会话</span></span><br><span class="line">   <span class="keyword">if</span> (![session setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:&amp;error]) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"Category Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//激活会话</span></span><br><span class="line">   <span class="keyword">if</span> (![session setActive:<span class="literal">YES</span> error:&amp;error]) &#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"Activation Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>添加后台播放 -修改info.plist ：</p>
</blockquote>
<p>设置后台运行模式：在plist文件中添加Required background modes，并且设置item 0=App plays audio or streams audio/video using AirPlay（其实可以直接通过Xcode在Project Targets-Capabilities-Background Modes中设置）</p>
<h2 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h2><p><em>使用设备的过程中，经常会出现电话呼入等情况，默认情况下，中断发生时音频会慢慢消失暂停，但是当中断结束时，音频不会自动开始。</em></p>
<blockquote>
<p>接收中断事件，并作出处理</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//接收中断</span></span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *nsnc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        [nsnc addObserver:<span class="keyword">self</span></span><br><span class="line">                 selector:<span class="keyword">@selector</span>(handleInterrruption:)</span><br><span class="line">                     name:<span class="built_in">AVAudioSessionInterruptionNotification</span></span><br><span class="line">                   object:[<span class="built_in">AVAudioSession</span> sharedInstance]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理中断</span></span><br><span class="line">-(<span class="keyword">void</span>)handleInterrruption:(<span class="built_in">NSNotification</span>*)noti&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span>* info = noti.userInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">AVAudioSessionInterruptionType</span> type= [[info objectForKey:<span class="string">@"AVAudioSessionInterruptionOptionKey"</span>] unsignedIntegerValue];</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="built_in">AVAudioSessionInterruptionTypeBegan</span>)&#123;</span><br><span class="line">        <span class="comment">//中断开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//中断结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对线路改变的响应"><a href="#对线路改变的响应" class="headerlink" title="对线路改变的响应"></a>对线路改变的响应</h2><p><em>默认情况下，播放音频时插入耳机，音频输出变为耳机并播放；断开耳机时，音频输出变为扬声器并播放。 希望改为断开耳机的时候停止播放</em></p>
<blockquote>
<p>接收线路变化通知，并作出处理</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//注册通知</span></span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *nsnc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        [nsnc addObserver:<span class="keyword">self</span></span><br><span class="line">                 selector:<span class="keyword">@selector</span>(handleRouteChange:)</span><br><span class="line">                     name:<span class="built_in">AVAudioSessionRouteChangeNotification</span></span><br><span class="line">                   object:[<span class="built_in">AVAudioSession</span> sharedInstance]];</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//处理通知</span></span><br><span class="line">- (<span class="keyword">void</span>)handleRouteChange:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *info = notification.userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVAudioSessionRouteChangeReason</span> reason =</span><br><span class="line">        [info[<span class="built_in">AVAudioSessionRouteChangeReasonKey</span>] unsignedIntValue];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reason == <span class="built_in">AVAudioSessionRouteChangeReasonOldDeviceUnavailable</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAudioSessionRouteDescription</span> *previousRoute =</span><br><span class="line">            info[<span class="built_in">AVAudioSessionRouteChangePreviousRouteKey</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">AVAudioSessionPortDescription</span> *previousOutput = previousRoute.outputs[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSString</span> *portType = previousOutput.portType;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//原设备为耳机则暂停播放</span></span><br><span class="line">        <span class="keyword">if</span> ([portType isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line"> 				<span class="comment">//停止播放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AVAudioRecorder-录制音频"><a href="#AVAudioRecorder-录制音频" class="headerlink" title="AVAudioRecorder 录制音频"></a>AVAudioRecorder 录制音频</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)url settings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)settings error:(<span class="built_in">NSError</span> **)outError;</span><br></pre></td></tr></table></figure>
<p>参数分别表示</p>
<ul>
<li>url，用于表示音频流写入文件的本地文件URL</li>
<li>setting，包含录音会话键值信息的NSDictionary对象<ul>
<li>AVFormatIDKey:写入的音频格式 </li>
<li>AVSampleRateKey：采样率 。一般使用8000、16000、22050或44100</li>
<li>AVNumberOfChannelsKey：通道数，1为单声道，2表示立体声</li>
</ul>
</li>
<li>outError，捕捉初始化阶段各种错误的NSError指针</li>
</ul>
<p>例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *tmpDir = <span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line"><span class="built_in">NSString</span> *filePath = [tmpDir stringByAppendingPathComponent:<span class="string">@"memo.caf"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:filePath];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *settings = @&#123;</span><br><span class="line">                           <span class="built_in">AVFormatIDKey</span> : @(kAudioFormatAppleIMA4),</span><br><span class="line">                           <span class="built_in">AVSampleRateKey</span> : @<span class="number">44100.0</span>f,</span><br><span class="line">                           <span class="built_in">AVNumberOfChannelsKey</span> : @<span class="number">1</span>,</span><br><span class="line">                           <span class="built_in">AVEncoderBitDepthHintKey</span> : @<span class="number">16</span>,</span><br><span class="line">                           <span class="built_in">AVEncoderAudioQualityKey</span> : @(<span class="built_in">AVAudioQualityMedium</span>)</span><br><span class="line">                           &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">self</span>.recorder = [[<span class="built_in">AVAudioRecorder</span> alloc] initWithURL:fileURL settings:settings error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.recorder) &#123;</span><br><span class="line">    <span class="keyword">self</span>.recorder.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.recorder.meteringEnabled = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.recorder prepareToRecord];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, [error localizedDescription]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置音频会话"><a href="#配置音频会话" class="headerlink" title="配置音频会话"></a>配置音频会话</h3><blockquote>
<p>默认AVAudioSessionCategorySoloAmbient 不支持音频输入，改为AVAudioSessionCategoryPlayAndRecord</p>
</blockquote>
<h3 id="对录制进行控制"><a href="#对录制进行控制" class="headerlink" title="对录制进行控制"></a>对录制进行控制</h3><ul>
<li>录制暂停停止：record，pause，stop；</li>
<li>恢复录制：pause之后调用record，AVAudioSession会帮你记录上次录音的地方并追加录音</li>
<li>获取时间：currentTime录制时长（秒），不能使用kvo监测</li>
</ul>
<h2 id="Audio-Metering测量音频"><a href="#Audio-Metering测量音频" class="headerlink" title="Audio Metering测量音频"></a>Audio Metering测量音频</h2><p><em>AVAudioRecoder 和 AVAudioPlayer 可以对音频进行测量。Audio Metering可以让开发者读取音频的平均分贝和峰值分贝</em></p>
<blockquote>
<p>获取音频分贝数据</p>
</blockquote>
<ul>
<li>设置录音器的 meteringEnabled属性为true</li>
<li>每次获取的时候 调用 updateMeters 方法获取最新的值</li>
<li><code>- (float)peakPowerForChannel:(NSUInteger)channelNumber;</code> 获取峰值分贝（对数形式的 -160 到 0）</li>
<li><code>- (float)averagePowerForChannel:(NSUInteger)channelNumber;</code> 获取平均分贝（对数形式的 -160 到 0）</li>
</ul>
]]></content>
      <categories>
        <category>essay</category>
        <category>AVFoundation</category>
      </categories>
      <tags>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控1 Cpu 和 Memory信息</title>
    <url>/essay/APM/iOSAPM1/</url>
    <content><![CDATA[<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 占用率的采集原理其实很简单：App 作为进程运行时会有多个线程，每个线程对 CPU 的使用率不同。各个线程对 CPU 使用率的总和，就是当前 App 对 CPU 的占用率。</p>
<p>wiki上比较全的iPhone CPU信息 : <a href="https://en.wikipedia.org/wiki/Apple-designed_processors" target="_blank" rel="noopener">Apple-designed_processors</a>)</p>
<h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，XNU（X is not UNIX） 是 Darwin 的内核，一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，如文件操作和设备访问，都是由 BSD 层实现。</p>
<p>事实上，Mach 并不能识别 UNIX 中的所有进程，而是采用一种稍微不同的方式，使用了比进程更轻量级的概念：任务（Task）。经典的 UNIX 采用了自上而下的方式：最基本的对象是进程，然后进一步划分为一个或多个线程；Mach 则采用了自底向上的方式：最基本的单元是线程，一个或多个线程包含在一个任务中。</p>
<ul>
<li>线程<ul>
<li>线程定义了 Mach 中最小的执行单元。线程表示的是底层的机器寄存器状态以及各种调度统计数据，其从设计上提供了调度所需要的大量信息。</li>
</ul>
</li>
<li>任务<ul>
<li>任务是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此，资源的共享实际上相当于允许对对应端口进行访问。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>严格来说，Mach 的任务并不是hi操作系统中所谓的进程，因为 Mach 作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。在 BSD 模型中，这两个概念有一对一的简单映射，每个 BSD 进程（即 OS X 进程）都在底层关联了一个 Mach 任务对象。实现这种映射的方法是指定一个透明的指针 bsd_info，Mach 对 bsd_info 完全无知。Mach 将内核也用任务表示（全局范围称为 kernel_task），尽管该任务没有对应的 PID，但可以想象 PID 为 0。</p>
<p>下图所示为权威著作《OS X Internal: A System Approach》中提供的 Mach OS X 中进程子系统组成的概念图。与 Mac OS X 类似，iOS 的线程技术也是基于 Mach 线程技术实现的。</p>
<p><img src="/res/apm/mach-task-thread-system.png" alt></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>上述提到线程表示的是底层的机器寄存器状态以及各种给调度统计数据。再来看 Mach 层中的 thread_basic_info 结构体的定义，其成员信息也证实了这一点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;      <span class="comment">// 用户运行时长</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;    <span class="comment">// 系统运行时长</span></span><br><span class="line">        <span class="keyword">integer_t</span>       cpu_usage;      <span class="comment">// CPU 使用率</span></span><br><span class="line">        <span class="keyword">policy_t</span>        policy;         <span class="comment">// 调度策略</span></span><br><span class="line">        <span class="keyword">integer_t</span>       run_state;      <span class="comment">// 运行状态</span></span><br><span class="line">        <span class="keyword">integer_t</span>       flags;          <span class="comment">// 各种标记</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;  <span class="comment">// 暂停线程的计数</span></span><br><span class="line">        <span class="keyword">integer_t</span>       sleep_time;     <span class="comment">// 休眠时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个线程都有这个结构体，所以我们只需要定时去遍历每个线程，累加每个线程的 cpu_usage 字段的值，就可以得到当前 App 所在进程的 CPU 使用率。</p>
<p>如下所示为 CPU 占用率 的代码实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 CPU 使用率</span></span><br><span class="line">+ (CGFloat)appCpuUsage &#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">task_info_data_t</span> tinfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> task_info_count;</span><br><span class="line">    </span><br><span class="line">    task_info_count = TASK_INFO_MAX;</span><br><span class="line">    kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>)tinfo, &amp;task_info_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_array_t</span>         thread_list;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> thread_count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_info_data_t</span>     thinfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> thread_info_count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">thread_basic_info_t</span> basic_info_th;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get threads in the task</span></span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> total_time     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_userTime = <span class="number">0</span>;</span><br><span class="line">    CGFloat total_cpu   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for each thread</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)thread_count; j++) &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">                         (<span class="keyword">thread_info_t</span>)thinfo, &amp;thread_info_count);</span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        basic_info_th = (<span class="keyword">thread_basic_info_t</span>)thinfo;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            total_time     = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">            total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">            total_cpu      = total_cpu + basic_info_th-&gt;cpu_usage / (<span class="keyword">float</span>)TH_USAGE_SCALE * kMaxPercent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (<span class="keyword">vm_offset_t</span>)thread_list, thread_count * <span class="keyword">sizeof</span>(<span class="keyword">thread_t</span>));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中使用 task_threads API 调用获取指定的 task 的线程列表。task_threads 将 target_task 任务中的所有线程保存在 act_list 数组中，数组包含 act_listCnt 个条目。上述源码中，在调用 task_threads API 时，target_task 参数传入的是 mach_task_self()，表示获取当前的 Mach task。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span> task_threads</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">task_t</span> target_task,</span><br><span class="line">	<span class="keyword">thread_act_array_t</span> *act_list,</span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span> *act_listCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在获取到线程列表后，代码中使用 thread_info API 调用获取指定线程的线程信息。thread_info 查询 flavor 指定的线程信息，将信息返回到长度为 thread_info_outCnt 字节的 thread_info_out 缓存区中。上述源码，在调用 thread_info API 时，flavor 参数传入的是 THREAD_BASIC_INFO，使用这个类型会返回线程的基本信息，即 thread_basic_info_t 结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span> thread_info</span><br><span class="line">(</span><br><span class="line">	<span class="keyword">thread_act_t</span> target_act,</span><br><span class="line">	<span class="keyword">thread_flavor_t</span> flavor,</span><br><span class="line">	<span class="keyword">thread_info_t</span> thread_info_out,</span><br><span class="line">	<span class="keyword">mach_msg_type_number_t</span> *thread_info_outCnt</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上述源码的最后，使用 vm_deallocate API 以防止出现内存泄露。</p>
<h3 id="总的-CPU-占用率"><a href="#总的-CPU-占用率" class="headerlink" title="总的 CPU 占用率"></a>总的 CPU 占用率</h3><p>使用 <code>host_statistics</code> 函数拿到 host_cpu_load_info 的值，这个结构体的成员变量 cpu_ticks 包含了 CPU 运行的时钟脉冲的数量，cpu_ticks 是一个数组，里面分别包含了 CPU_STATE_USER, CPU_STATE_SYSTEM, CPU_STATE_IDLE 和 CPU_STATE_NICE 模式下的时钟脉冲。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (CGFloat)cpuUsage &#123;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">host_cpu_load_info_data_t</span> previous_info = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">host_cpu_load_info_data_t</span> info;</span><br><span class="line">    </span><br><span class="line">    count = HOST_CPU_LOAD_INFO_COUNT;</span><br><span class="line">    </span><br><span class="line">    kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (<span class="keyword">host_info_t</span>)&amp;info, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">natural_t</span> user   = info.cpu_ticks[CPU_STATE_USER] - previous_info.cpu_ticks[CPU_STATE_USER];</span><br><span class="line">    <span class="keyword">natural_t</span> nice   = info.cpu_ticks[CPU_STATE_NICE] - previous_info.cpu_ticks[CPU_STATE_NICE];</span><br><span class="line">    <span class="keyword">natural_t</span> system = info.cpu_ticks[CPU_STATE_SYSTEM] - previous_info.cpu_ticks[CPU_STATE_SYSTEM];</span><br><span class="line">    <span class="keyword">natural_t</span> idle   = info.cpu_ticks[CPU_STATE_IDLE] - previous_info.cpu_ticks[CPU_STATE_IDLE];</span><br><span class="line">    <span class="keyword">natural_t</span> total  = user + nice + system + idle;</span><br><span class="line">    previous_info    = info;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (user + nice + system) * <span class="number">100.0</span> / total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过计算 info 和 previous_info 的差值，分别得到在这几个模式下的 cpu_ticks，除 idle 以外都属于 CPU 被占用的情况，最后就能求出 CPU 的占用率。</p>
<h3 id="CPU-核数"><a href="#CPU-核数" class="headerlink" title="CPU 核数"></a>CPU 核数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (NSUInteger)cpuNumber &#123;</span><br><span class="line">    <span class="keyword">return</span> [NSProcessInfo processInfo].activeProcessorCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CPU-频率"><a href="#CPU-频率" class="headerlink" title="CPU 频率"></a>CPU 频率</h3><p>CPU 频率，就是 CPU 的时钟频率， 是 CPU 运算时的工作的频率（1秒内发生的同步脉冲数）的简称。单位是 Hz，它决定移动设备的运行速度。</p>
<p>由于安全性考虑，苹果已经禁止访问内核变量来获取 CPU 频率。现实现方法是通过硬编码方式获取 CPU 频率，新机发布需更新。</p>
<p>我们通过硬编码的方式，建立一张机型和 CPU 主频的映射表，然后根据机型找到对应的 CPU 主频即可。</p>
<p>可以在其中找到对应机型cpu的对应 : <a href="https://en.wikipedia.org/wiki/Apple-designed_processors" target="_blank" rel="noopener">Apple-designed_processors</a></p>
<h3 id="CPU-类型"><a href="#CPU-类型" class="headerlink" title="CPU 类型"></a>CPU 类型</h3><p>我们知道 iPhone 使用的处理器架构都是 ARM 的，而 ARM 又分为 ARMV7、ARMV7S 和 ARM64等。而想要获取设备具体的处理器架构则需要使用 NXGetLocalArchInfo() 函数。这个函数的返回值是 NXArchInfo 结构体类型，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">cpu_type_t</span> cputype;</span><br><span class="line">    <span class="keyword">cpu_subtype_t</span> cpusubtype;</span><br><span class="line">    <span class="keyword">enum</span> NXByteOrder byteorder;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *description;</span><br><span class="line">&#125; NXArchInfo;</span><br></pre></td></tr></table></figure>
<p>NXArchInfo 结构体成员变量中就包含我们需要的信息：cputype 和 cpusubtype，这两个变量类型的定义在 mach/machine.h 头文件中给出，本质上都是 int 类型 typedef 得到的。</p>
<p>根据 mach/machine.h 头文件给出的 CPU 架构类型的定义，可以很容易建立起各 CPU 架构到其对应描述的映射关系，代码实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (NSInteger)cpuType &#123;</span><br><span class="line">    <span class="keyword">return</span> (NSInteger)NXGetLocalArchInfo()-&gt;cputype;</span><br><span class="line">&#125;</span><br><span class="line">+ (NSInteger)cpuSubtype &#123;</span><br><span class="line">    <span class="keyword">return</span> (NSInteger)NXGetLocalArchInfo()-&gt;cpusubtype;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)p_stringFromCpuType:(NSInteger)cpuType &#123;</span><br><span class="line">    <span class="keyword">switch</span> (cpuType) &#123;</span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_VAX:          <span class="keyword">return</span> @<span class="string">"VAX"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC680x0:      <span class="keyword">return</span> @<span class="string">"MC680x0"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_X86:          <span class="keyword">return</span> @<span class="string">"X86"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_X86_64:       <span class="keyword">return</span> @<span class="string">"X86_64"</span>;       </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC98000:      <span class="keyword">return</span> @<span class="string">"MC98000"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_HPPA:         <span class="keyword">return</span> @<span class="string">"HPPA"</span>;         </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_ARM:          <span class="keyword">return</span> @<span class="string">"ARM"</span>;          </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_ARM64:        <span class="keyword">return</span> @<span class="string">"ARM64"</span>;        </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_MC88000:      <span class="keyword">return</span> @<span class="string">"MC88000"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_SPARC:        <span class="keyword">return</span> @<span class="string">"SPARC"</span>;        </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_I860:         <span class="keyword">return</span> @<span class="string">"I860"</span>;         </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_POWERPC:      <span class="keyword">return</span> @<span class="string">"POWERPC"</span>;      </span><br><span class="line">        <span class="keyword">case</span> CPU_TYPE_POWERPC64:    <span class="keyword">return</span> @<span class="string">"POWERPC64"</span>;    </span><br><span class="line">        <span class="keyword">default</span>:                    <span class="keyword">return</span> @<span class="string">"Unknown"</span>;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (NSString *)cpuTypeString &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cpuTypeString) &#123;</span><br><span class="line">        _cpuTypeString = [self p_stringFromCpuType:[[self class] cpuType]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _cpuTypeString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)cpuSubtypeString &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cpuSubtypeString) &#123;</span><br><span class="line">        _cpuSubtypeString = [NSString stringWithUTF8String:NXGetLocalArchInfo()-&gt;description];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _cpuSubtypeString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经测试发现 NXArchInfo 结构体成员变量 description 包含的就是 CPU 架构的详尽信息，所以可以用它作为 cpuSubtypeString，当然也可以自己建立 cpuSubtype 的映射关系。</p>
]]></content>
      <categories>
        <category>APM</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控3 FPS与卡顿</title>
    <url>/essay/APM/iOSAPM3/</url>
    <content><![CDATA[<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><p>FPS（Frames Per Second）是指画面每秒传输的帧数。每秒帧数越多，所显示的动画就越流畅，一般只要保持 FPS 在 50-60，App 就会有流畅的体验，反之会感觉到卡顿。</p>
<h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p><code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。</p>
<p>一旦 CADisplayLink 以特定的模式注册到 runloop 之后，每当屏幕需要刷新时，runloop 就会调用 CADisplayLink 绑定的 target 上的 selector，此时 target 可以读取到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。如：一个视频应用使用时间戳来计算下一帧要显示的视频数据。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>现阶段，常用的 FPS 监控几乎都是基于 CADisplayLink 实现的。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swift</span></span><br><span class="line">final <span class="class"><span class="keyword">class</span> <span class="title">FPSMonitor</span>:</span> NSObject &#123;</span><br><span class="line">    <span class="keyword">private</span> var timer: Timer?</span><br><span class="line">    <span class="keyword">private</span> var link: CADisplayLink?</span><br><span class="line">    <span class="keyword">private</span> var count: UInt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> var lastTime: TimeInterval = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    func enableMonitor() &#123;</span><br><span class="line">        <span class="keyword">if</span> link == nil &#123;</span><br><span class="line">            link = CADisplayLink(target: self, selector: #selector(fpsInfoCalculate(_:)))</span><br><span class="line">            link?.add(to: RunLoop.main, forMode: .common)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link?.isPaused = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func disableMonitor() &#123;</span><br><span class="line">        <span class="keyword">if</span> let link = link &#123;</span><br><span class="line">            link.isPaused = <span class="literal">true</span></span><br><span class="line">            link.invalidate()</span><br><span class="line">            self.link = nil</span><br><span class="line">            lastTime = <span class="number">0</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc</span><br><span class="line">    func fpsInfoCalculate(_ link: CADisplayLink) &#123;</span><br><span class="line">        <span class="keyword">if</span> lastTime == <span class="number">0</span> &#123;</span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        let delta = link.timestamp - lastTime</span><br><span class="line">        <span class="keyword">if</span> delta &gt;= <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 间隔超过 1 秒</span></span><br><span class="line">            lastTime = link.timestamp</span><br><span class="line">            let fps = Double(count) / delta</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            let intFps = Int(fps + <span class="number">0.5</span>)</span><br><span class="line">            print(<span class="string">"帧率：\(intFps)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CADisplayLink 实现的 FPS 在生产场景中只有指导意义，不能代表真实的 FPS。因为基于 CADisplayLink 实现的 FPS 无法完全检测出当前 Core Animation 的性能情况，只能检测出当前 RunLoop 的帧率。</p>
<h3 id="如何监控卡顿"><a href="#如何监控卡顿" class="headerlink" title="如何监控卡顿"></a>如何监控卡顿</h3><p>那怎么监控应用的卡顿情况？通常有以下两种方案</p>
<ul>
<li>FPS 监控：这是最容易想到的一种方案，如果帧率越高意味着界面越流畅，上文也给出了计算 FPS 的实现方式，通过一段连续的 FPS 计算丢帧率来衡量当前页面绘制的质量。<ul>
<li>FPS 的刷新频率非常快，并且容易发生抖动，因此直接通过比较 FPS 来侦测卡顿是比较困难的；此外，主线程卡顿监控也会发生抖动，所以微信读书团队给出一种综合方案，结合主线程监控、FPS 监控，以及 CPU 使用率等指标，作为判断卡顿的标准。Bugly 的卡顿检测也是基于这套标准。</li>
</ul>
</li>
<li>线程卡顿监控：这是业内常用的一种检测卡顿的方法，通过开辟一个子线程来监控主线程的 RunLoop，当两个状态区域之间的耗时大于阈值时，就记为发生一次卡顿。美团的移动端性能监控方案 Hertz 采用的就是这种方式</li>
</ul>
<p>主线程卡顿监控的实现思路：开辟一个子线程，然后实时计算 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 两个状态区域之间的耗时是否超过某个阀值，来断定主线程的卡顿情况，可以将这个过程想象成操场上跑圈的运动员，我们会每隔一段时间间隔去判断是否跑了一圈，如果发现在指定时间间隔没有跑完一圈，则认为在消息处理的过程中耗时太多，视为主线程卡顿。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以通过 CFRunLoopObserverRef 实时获取 NSRunLoop 的状态。具体使用方法如下：</p>
<p>首先创建一个 CFRunLoopObserverContext 观察者 observer。然后将观察者 observer 添加到主线程 RunLoop 的 kCFRunLoopCommonModes 模式下进行观察。</p>
<p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。为了让计算更精确，需要让子线程更及时的获知主线程 RunLoop 状态变化，dispatch_semaphore_t 是一个不错的选择。另外，卡顿需要覆盖多次连续短时间卡顿和单次长时间卡顿两种情景，所以判定条件也需要做适当优化。优化后的代码实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runLoopObserverCallBack</span><span class="params">(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="keyword">void</span> *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass *object = (__bridge MyClass*)info;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录状态值</span></span><br><span class="line">    object-&gt;activity = activity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送信号</span></span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> semaphore = moniotr-&gt;semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">    CFRunLoopObserverContext context = &#123;<span class="number">0</span>,(__bridge <span class="keyword">void</span>*)self,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            YES,</span><br><span class="line">                                                            <span class="number">0</span>,</span><br><span class="line">                                                            &amp;runLoopObserverCallBack,</span><br><span class="line">                                                            &amp;context);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建信号</span></span><br><span class="line">    semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子线程监控时长</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (YES)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span></span><br><span class="line">            <span class="keyword">long</span> st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span>*NSEC_PER_MSEC));</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++timeoutCount &lt; <span class="number">5</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 检测到卡顿，进行卡顿上报</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            timeoutCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>APM</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控2 Memory信息</title>
    <url>/essay/APM/iOSAPM2/</url>
    <content><![CDATA[<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>我们可以联想：内存使用情况是否也可以通过类似CPU的方式获取到呢？答案是肯定的。</p>
<h3 id="相关系统原理"><a href="#相关系统原理" class="headerlink" title="相关系统原理"></a>相关系统原理</h3><p>内存是有限且系统共享的资源，一个程序占用越多，系统和其他程序所能用的就越少。程序启动前都需要先加载到内存中，并且在程序运行过程中的数据操作也会占用一定的内存资源。减少内存占用也能同时减少其对 CPU 时间维度上的消耗，从而使不仅使 App 以及整个系统也都能表现的更好。</p>
<p>MacOS 和 iOS 都采用了虚拟内存技术来突破物理内存的大小限制，每个进程都有一段由多个大小相同的页（Page）所构成的逻辑地址空间。处理器和内存管理单元（MMU，Memory Management Unit）维护着由逻辑地址到物理地址的 页面映射表（简称 页表），当程序访问逻辑内存地址时，由 MMU 根据页表将逻辑地址转换为真实的物理地址。在早期的苹果设备中，每个页的大小为 4KB；基于 A7 和 A8 处理器的系统为 64 位程序提供了 16KB 的虚拟内存分页和 4KB 的物理内存分页；在 A9 之后，虚拟内存和物理内存的分页大小都达到了 16KB。</p>
<p>虚拟内存分页（Virtual Page，VP）有两种类型：</p>
<ul>
<li>Clean：指能够被系统清理出内存且在需要时能重新加载的数据，包括：<ul>
<li>内存映射文件</li>
<li>Frameworks 中的 __DATA_CONST 部分</li>
<li>应用的二进制可执行文件</li>
</ul>
</li>
<li>Dirty：指不能被系统回收的内存占用，包括：<ul>
<li>所有堆上的对象</li>
<li>图片解码缓冲数据</li>
<li>Framework 中的 DATA 和 DATA_DIRTY 部分</li>
</ul>
</li>
</ul>
<a id="more"></a>
<p>由于内存容量和读写寿命的限制，iOS 上没有 Disk Swap 机制，取而代之使用 Compressed Memory 技术。 Disk Swap 是指在 macOS 以及一些其他桌面操作系统中，当内存可用资源紧张时，系统将内存中的内容写入磁盘中的backing store（Swapping out），并且在需要访问时从磁盘中再读入 RAM（Swapping in）。与大多数 UNIX 系统不同的是，macOS 没有预先分配磁盘中的一部分作为 backing store，而是利用引导分区所有可用的磁盘空间。</p>
<p>苹果最初只是公开了从 OS X Mavericks 开始使用 Compressed Memory 技术，但 iOS 系统也从 iOS 7 开始悄悄地使用。</p>
<p>Compressed Memory 技术在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，其特点可以归结为：</p>
<ul>
<li>减少了不活跃内存占用</li>
<li>改善电源效率，通过压缩减少磁盘 IO 带来的损耗</li>
<li>压缩/解压非常快，能够尽可能减少 CPU 的时间开销</li>
<li>支持多核操作</li>
</ul>
<p>本质上，Compressed Memory 也是 Dirty Memory。因此，memory footprint = dirty size + compressed size，这也是我们需要并且能够尝试去减少的内存占用。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>在 /usr/include/mach/task_info.h 中，我们可以看到 mach_task_basic_info 和 task_basic_info 结构体的定义，分别如下所示。事实上，苹果公司已经不建议再使用 task_basic_info 结构体了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACH_TASK_BASIC_INFO     20         <span class="comment">/* always 64-bit basic info */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_task_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  virtual_size;       <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  resident_size;      <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">mach_vm_size_t</span>  resident_size_max;  <span class="comment">/* maximum resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;          <span class="comment">/* total user run time for</span></span><br><span class="line"><span class="comment">                                               terminated threads */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;        <span class="comment">/* total system run time for</span></span><br><span class="line"><span class="comment">                                               terminated threads */</span></span><br><span class="line">        <span class="keyword">policy_t</span>        policy;             <span class="comment">/* default policy for new threads */</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;      <span class="comment">/* suspend count for task */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* localized structure - cannot be safely passed between tasks of differing sizes */</span></span><br><span class="line"><span class="comment">/* Don't use this, use MACH_TASK_BASIC_INFO instead */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_basic_info</span> &#123;</span></span><br><span class="line">        <span class="keyword">integer_t</span>       suspend_count;  <span class="comment">/* suspend count for task */</span></span><br><span class="line">        <span class="keyword">vm_size_t</span>       virtual_size;   <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">vm_size_t</span>       resident_size;  <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    user_time;      <span class="comment">/* total user run time for</span></span><br><span class="line"><span class="comment">                                           terminated threads */</span></span><br><span class="line">        <span class="keyword">time_value_t</span>    system_time;    <span class="comment">/* total system run time for</span></span><br><span class="line"><span class="comment">                                           terminated threads */</span></span><br><span class="line">	<span class="keyword">policy_t</span>	policy;		<span class="comment">/* default policy for new threads */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mach_task_basic_info 结构体存储了 Mach task 的内存使用信息，其中 resident_size 是 App 使用的驻留内存大小，virtual_size 是 App 使用的虚拟内存大小。</p>
<p>如下所示为内存使用情况的代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前 app 内存使用量</span></span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mach_task_basic_info</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">kern_return_t</span> kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (<span class="keyword">task_info_t</span>) &amp;info, &amp;count);</span><br><span class="line">	<span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line">		<span class="keyword">return</span> info.resident_size;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，我用 通过此方法获取到的内存信息与 Instruments 中的 Activity Monitor 采集到的内存信息进行比较，发现前者要多出将近 100MB。经过调研发现，苹果使用了上述的 Compressed Memory，我猜测：resident_size 可能是将 Compressed Memory 解压后所统计到的一个数值。<strong>真实的物理内存的值应该是 task_vm_info 结构体中的 pyhs_footprint 成员的值。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_VM_INFO            22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_VM_INFO_PURGEABLE  23</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_vm_info</span> &#123;</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  virtual_size;       <span class="comment">/* virtual memory size (bytes) */</span></span><br><span class="line">	<span class="keyword">integer_t</span>       region_count;       <span class="comment">/* number of memory regions */</span></span><br><span class="line">	<span class="keyword">integer_t</span>       page_size;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  resident_size;      <span class="comment">/* resident memory size (bytes) */</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  resident_size_peak; <span class="comment">/* peak resident size (bytes) */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  device;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  device_peak;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  internal;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  internal_peak;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  external;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  external_peak;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  reusable;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  reusable_peak;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  purgeable_volatile_pmap;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  purgeable_volatile_resident;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  purgeable_volatile_virtual;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  compressed;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  compressed_peak;</span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  compressed_lifetime;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* added for rev1 */</span></span><br><span class="line">	<span class="keyword">mach_vm_size_t</span>  phys_footprint;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* added for rev2 */</span></span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>       min_address;</span><br><span class="line">	<span class="keyword">mach_vm_address_t</span>       max_address;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因此，正确的内存使用情况的代码实现应该如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前 app 内存使用量</span></span><br><span class="line">+ (NSInteger)useMemoryForApp &#123;</span><br><span class="line">    <span class="keyword">task_vm_info_data_t</span> vmInfo;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> count = TASK_VM_INFO_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (<span class="keyword">task_info_t</span>) &amp;vmInfo, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (kernelReturn == KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> memoryUsageInByte = (<span class="keyword">int64_t</span>) vmInfo.phys_footprint;</span><br><span class="line">        <span class="keyword">return</span> memoryUsageInByte / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设备所有物理内存大小"><a href="#设备所有物理内存大小" class="headerlink" title="设备所有物理内存大小"></a>设备所有物理内存大小</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[NSProcessInfo processInfo].physicalMemory</span><br></pre></td></tr></table></figure>
<h3 id="设备使用的内存"><a href="#设备使用的内存" class="headerlink" title="设备使用的内存"></a>设备使用的内存</h3><p>获取当前设备的 Memory 使用情况</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">int64_t getUsedMemory()</span><br><span class="line">&#123;</span><br><span class="line">    size_t length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pagesize = <span class="number">0</span>;</span><br><span class="line">    mib[<span class="number">0</span>] = <span class="built_in">CTL_HW</span>;</span><br><span class="line">    mib[<span class="number">1</span>] = HW_PAGESIZE;</span><br><span class="line">    length = <span class="keyword">sizeof</span>(pagesize);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;pagesize, &amp;length, <span class="literal">NULL</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line">    </span><br><span class="line">    vm_statistics_data_t vmstat;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> wireMem = vmstat.wire_count * pagesize;</span><br><span class="line">    <span class="keyword">int</span> activeMem = vmstat.active_count * pagesize;</span><br><span class="line">    <span class="keyword">return</span> wireMem + activeMem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设备可用的内存"><a href="#设备可用的内存" class="headerlink" title="设备可用的内存"></a>设备可用的内存</h3><p>获取当前设备可用的 Memory</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">uint64_t</span>)availableMemory &#123;</span><br><span class="line">    <span class="keyword">vm_statistics64_data_t</span> vmStats;</span><br><span class="line">    <span class="keyword">mach_msg_type_number_t</span> infoCount = HOST_VM_INFO_COUNT;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kernReturn = host_statistics(mach_host_self(),</span><br><span class="line">                                               HOST_VM_INFO,</span><br><span class="line">                                               (<span class="keyword">host_info_t</span>)&amp;vmStats,</span><br><span class="line">                                               &amp;infoCount);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (kernReturn != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NSNotFound;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> vm_page_size * (vmStats.free_count + vmStats.inactive_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者可能会看到有些代码会使用 vm_statistics_data_t 结构体，但是这个结构体是32位机器的，随着 Apple 逐渐放弃对32位应用的支持，所以建议读者还是使用 vm_statistics64_data_t 64位的结构体。</p>
]]></content>
      <categories>
        <category>APM</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 性能监控4 网络监控-NSURLProtocol</title>
    <url>/essay/APM/iOSAPM4/</url>
    <content><![CDATA[<p>在iOS中苹果提供了NSURLConnection、NSURLSession等优秀的网路接口供我们来调用，开源社区也有很多的开源库，如之前的ASIHttpRequest 现在的AFNetworking和Alamofire，我们接下来介绍的NSURLProtocol，都可以监控到这些开源库的网络请求。</p>
<h3 id="NSURLProtocol"><a href="#NSURLProtocol" class="headerlink" title="NSURLProtocol"></a>NSURLProtocol</h3><p>NSURLProtocol是iOS网络加载系统中很强的一部分，它其实是一个抽象类，我们可以通过继承子类化来拦截APP中的网络请求。</p>
<p>举几个例子：</p>
<ul>
<li>我们的APP内的所有请求都需要增加公共的头，像这种我们就可以直接通过NSURLProtocol来实现，当然实现的方式有很多种</li>
<li>我们需要将APP某个API进行一些访问的统计</li>
<li>我们需要统计APP内的网络请求失败率</li>
</ul>
<p>等等，都可以用到 NSURLProtocol是一个抽象类，我们需要子类化才能实现网络请求拦截。</p>
<a id="more"></a>
<h3 id="新建-NSURLProtocol的子类"><a href="#新建-NSURLProtocol的子类" class="headerlink" title="新建 NSURLProtocol的子类"></a>新建 NSURLProtocol的子类</h3><p>新建 NSURLProtocol的子类 并且需要重写一些方法 </p>
<h3 id="重写-can​Init​With​Request"><a href="#重写-can​Init​With​Request" class="headerlink" title="重写 can​Init​With​Request :"></a>重写 <code>can​Init​With​Request</code> :</h3><p>我们需要告诉它哪些网络请求是需要我们拦截的，这个是通过方法can​Init​With​Request:​来实现的，比如我们现在需要拦截全部的HTTP和HTTPS请求，那么这个逻辑我们就可以在can​Init​With​Request:​中来定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 需要控制的请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param request 此次请求</span></span><br><span class="line"><span class="comment"> @return 是否需要监控</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![request.URL.scheme isEqualToString:@<span class="string">"http"</span>] &amp;&amp;</span><br><span class="line">        ![request.URL.scheme isEqualToString:@<span class="string">"https"</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重写-canonicalRequestForRequest"><a href="#重写-canonicalRequestForRequest" class="headerlink" title="重写 canonicalRequestForRequest:"></a>重写 <code>canonicalRequestForRequest:</code></h3><p>我们可以自定义当前的请求request，通过重写 canonicalRequestForRequest: 来实现。当然如果不需要自定义，直接返回就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 设置我们自己的自定义请求</span></span><br><span class="line"><span class="comment"> 可以在这里统一加上头之类的</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param request 应用的此次请求</span></span><br><span class="line"><span class="comment"> @return 我们自定义的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们通过这两个方法，就已经能够拦截住iOS的网络请求了 </p>
<h3 id="can​Init​With​Request-与-canonicalRequestForRequest"><a href="#can​Init​With​Request-与-canonicalRequestForRequest" class="headerlink" title="can​Init​With​Request: 与 canonicalRequestForRequest"></a><code>can​Init​With​Request:</code> 与 <code>canonicalRequestForRequest</code></h3><p>在我们上层业务调用网络请求的时候，首先会调用我们的can​Init​With​Request:方法，询问是否对该请求进行处理，接着会调用我们的canonicalRequestForRequest:来自定义一个request，接着又会去调用can​Init​With​Request:询问自定义的request是否需要处理，我们又返回YES，然后又去调用了canonicalRequestForRequest:，这样，就形成了一个死循环了，这肯定是我们不希望看到的。</p>
<p>有个处理方法，我们可以对每个处理过的request进行标记，在判断如果这个request已经处理过了，那么我们就不再进行处理，这样就有效避免了死循环</p>
<p>在我们自定义request的方法中，我们来设置处理标志</p>
<ul>
<li><p>(NSURLRequest <em>)canonicalRequestForRequest:(NSURLRequest </em>)request {<br>  NSMutableURLRequest *mutableReqeust = [request mutableCopy];<br>  [NSURLProtocol setProperty:@YES</p>
<pre><code>   forKey:PPSHTTP
inRequest:mutableReqeust];
</code></pre><p>  return [mutableReqeust copy];<br>}<br>然后在我们的询问处理方法中，通过判断是否有处理过的标志，来进行拦截</p>
</li>
<li><p>(BOOL)canInitWithRequest:(NSURLRequest *)request {</p>
<p>  if (![request.URL.scheme isEqualToString:@”http”] &amp;&amp;</p>
<pre><code>![request.URL.scheme isEqualToString:@&quot;https&quot;]) {
return NO;
</code></pre><p>  }<br>  //如果是已经拦截过的  就放行<br>  if ([NSURLProtocol propertyForKey:PPSHTTP inRequest:request] ) {</p>
<pre><code>return NO;
</code></pre><p>  }<br>  return YES;<br>}<br>这样，我们就避免了死循环</p>
</li>
</ul>
<h3 id="重写-startLoading-和-stopLoading"><a href="#重写-startLoading-和-stopLoading" class="headerlink" title="重写 startLoading 和 stopLoading"></a>重写 <code>startLoading</code> 和 <code>stopLoading</code></h3><p>接下来，就是需要将这个request发送出去了，因为如果我们不处理这个request请求，系统会自动发出这个网络请求，但是当我们处理了这个请求，就需要我们手动来进行发送了。</p>
<p>我们要手动发送这个网络请求，需要重写startLoading方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startLoading &#123;</span><br><span class="line">    NSURLRequest *request = [[self class] canonicalRequestForRequest:self.request];</span><br><span class="line">    self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self startImmediately:YES];</span><br><span class="line">    self.pps_request = self.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码，因为我们拦截的这个请求是一个真实的请求，所以我们需要创建这样一个真实的网络请求，在第二行代码中，将我们自定义创建的request发了出了，第三行是为了保存当前的request，作为我们后面的处理对象。</p>
<p>当然，有start就有stop，stop就很简单了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stopLoading &#123;</span><br><span class="line">    [self.connection cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLConnectionDelegate-转发"><a href="#NSURLConnectionDelegate-转发" class="headerlink" title="NSURLConnectionDelegate 转发"></a>NSURLConnectionDelegate 转发</h3><p>在startLoading中，我们发起了一个NSURLConnection的请求，因为NSURLProtocol使我们自己定义的，所以我们需要将网络请求的一系列操作全部传递出去，不然上层就不知道当前网络的一个请求状态，那我们怎么将这个网络状态传到上层？每个protocol有一个NSURLProtocolClient实例，我们就通过这个client来传递。</p>
<p>传递一个网络请求，无外乎就是传递请求的一些过程，数据，结果等等。 发起了发起了一个NSURLConnection的请求，实现它的delegate就能够知道网络请求的一系列操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDelegate</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;</span><br><span class="line">    [self.client URLProtocol:self didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)connectionShouldUseCredentialStorage:(NSURLConnection *)connection&#123;</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge&#123;</span><br><span class="line">    [self.client URLProtocol:self didReceiveAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection</span><br><span class="line">didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123;</span><br><span class="line">    [self.client URLProtocol:self didCancelAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLConnectionDataDelegate</span></span><br><span class="line">-(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != nil) &#123;</span><br><span class="line">        self.pps_response = response;</span><br><span class="line">        [self.client URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</span><br><span class="line">    self.pps_response = response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    [self.client URLProtocol:self didLoadData:data];</span><br><span class="line">    [self.pps_data appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSCachedURLResponse *)connection:(NSURLConnection *)connection</span><br><span class="line">                  willCacheResponse:(NSCachedURLResponse *)cachedResponse &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedResponse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    [[self client] URLProtocolDidFinishLoading:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拦截网络"><a href="#拦截网络" class="headerlink" title="拦截网络"></a>拦截网络</h3><p>这样，基本的protocol就已经实现完成，那么怎样来拦截网络。我们需要将我们自定义的PPSURLProtocol通过NSURLProtocol注册到我们的网络加载系统中，告诉系统我们的网络请求处理类不再是默认的NSURLProtocol，而是我们自定义的PPSURLProtocol</p>
<p>。我们需要将我们自定义的PPSURLProtocol通过NSURLProtocol注册到我们的网络加载系统中，告诉系统我们的网络请求处理类不再是默认的NSURLProtocol，而是我们自定义的PPSURLProtocol</p>
<p>我们在PPSURLProtocol暴露两个方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@interface PPSURLProtocol : NSURLProtocol</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)start;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>然后在我们的APP启动的时候，调用start，就可以监听到我们的网络请求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    PPSURLSessionConfiguration *sessionConfiguration = [PPSURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    [NSURLProtocol registerClass:[PPSURLProtocol <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)end &#123;</span><br><span class="line">    PPSURLSessionConfiguration *sessionConfiguration = [PPSURLSessionConfiguration defaultConfiguration];</span><br><span class="line">    [NSURLProtocol unregisterClass:[PPSURLProtocol <span class="class"><span class="keyword">class</span>]];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><p>上面的代码已经能够监控到绝大部分的网络请求，但是呢，有一个却是特殊的。</p>
<p>对于NSURLSession发起的网络请求，我们发现通过shared得到的session发起的网络请求都能够监听到，但是通过方法<em>sessionWithConfiguration:delegate:delegateQueue:</em>得到的session，我们是不能监听到的，原因就出在NSURLSessionConfiguration上，我们进到NSURLSessionConfiguration里面看一下，他有一个属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">@property (nullable, copy) NSArray&lt;Class&gt; *protocolClasses;</span><br></pre></td></tr></table></figure>
<p>我们能够看出，这是一个NSURLProtocol数组，上面我们提到了，我们监控网络是通过注册NSURLProtocol来进行网络监控的，但是通过<em>sessionWithConfiguration:delegate:delegateQueue:得到的session，他的configuration中已经有一个NSURLProtocol，所以他不会走我们的protocol来，怎么解决这个问题呢？ 其实很简单，我们将NSURLSessionConfiguration的属性protocolClasses的get方法hook掉，通过返回我们自己的protocol，这样，我们就能够监控到通过sessionWithConfiguration:delegate:delegateQueue:</em>得到的session的网络请求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> hook 状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> BOOL isHookWorking = NO;</span><br><span class="line"></span><br><span class="line">@<span class="function">implementation <span class="title">NSURLSessionConfiguration</span> <span class="params">(FSAPM)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Life Cycle</span></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> swizzle method</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 避免使用私有 APIm，不过审</span></span><br><span class="line">        Class cls = NSClassFromString([NSString stringWithFormat:@<span class="string">"%@%@%@"</span>, @<span class="string">"__NSCFU"</span>, @<span class="string">"RLSessionCon"</span>, @<span class="string">"figuration"</span>]) ?: NSClassFromString(@<span class="string">"NSURLSessionConfiguration"</span>);</span><br><span class="line">        Method origMethod = class_getInstanceMethod(cls, @selector(protocolClasses));</span><br><span class="line">        Method replMethod = class_getInstanceMethod(self, @selector(fs_protocolClasses));</span><br><span class="line">        <span class="keyword">if</span> (origMethod &amp;&amp; replMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (class_addMethod(cls, @selector(protocolClasses), method_getImplementation(replMethod), method_getTypeEncoding(replMethod))) &#123;</span><br><span class="line">                class_replaceMethod(self, @selector(fs_protocolClasses), method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                method_exchangeImplementations(origMethod, replMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Public Method</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启 hook</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    isHookWorking = YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 关闭 hook</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    isHookWorking = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private Method</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将 FSURLProtocol 对象放在首位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @return NSArray&lt;NSURLProtocol&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (NSArray&lt;Class&gt; *)fs_protocolClasses &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHookWorking) &#123;</span><br><span class="line">        <span class="keyword">return</span> [self fs_protocolClasses];</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *<span class="built_in">array</span> = [[self fs_protocolClasses] mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> @[[FSURLProtocol class]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">array</span> containsObject:[FSURLProtocol class]]) &#123;</span><br><span class="line">        [<span class="built_in">array</span> insertObject:[FSURLProtocol <span class="class"><span class="keyword">class</span>] <span class="title">atIndex</span>:</span><span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动的时候，将这个方法替换掉，在移除监听的时候，恢复之前的方法</p>
<p>至此，我们的监听就完成了，如果我们需要将这所有的监听存起来，在protocol的start或者stop中获取到request和response，将他们存储起来就行，需要说明的是，据苹果的官方说明，因为请求参数可能会很大，为了保证性能，请求参数是没有被拦截掉的，就是post的HTTPBody是没有的</p>
]]></content>
      <categories>
        <category>APM</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Instruments介绍</title>
    <url>/essay/Instruments/Instruments1/</url>
    <content><![CDATA[<p><img src="/res/Instrument/instrument1.png" width="80%"></p>
<h2 id="Instruments-是什么"><a href="#Instruments-是什么" class="headerlink" title="Instruments 是什么"></a>Instruments 是什么</h2><p><a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="noopener">Instruments</a> 是 Xcode 的一个工具集，为我们提供了强大的程序性能分析及测试能力。使用 Instruments 你可以做下面这些事：<br><a id="more"></a></p>
<ol>
<li>检查一个或多个应用或进程的行为。</li>
<li>检查设备相关的功能，比如：Wi-Fi、蓝牙等。</li>
<li>在真机或模拟器上进行性能测试。</li>
<li>创建自定义的 DTrace 来分析系统以及应用的各种行为。</li>
<li>跟踪源码中的问题。</li>
<li>对 App 进行性能分析。</li>
<li>查找 App 中的内存问题，比如：内存泄露(Leaked memory)、废弃内存(Abandoned memory)、僵尸(zombies)等。</li>
<li>给出程序优化的建议。</li>
<li>进行系统级别的问题定位。</li>
<li>通过脚本记录一个用户行为序列，从而可以通过运行脚本对你的 iOS 应用进行可重复多次的自动化测试。</li>
<li>保存测试配置模板以供复用。</li>
</ol>
<h2 id="我们看一下开始模板。"><a href="#我们看一下开始模板。" class="headerlink" title="我们看一下开始模板。"></a>我们看一下开始模板。</h2><table>
<thead>
<tr>
<th>项目           模板</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.Blank</td>
<td>创建一个空的模板，你可以自定义的添加各种工具。</td>
</tr>
<tr>
<td>2.Activity Monitor</td>
<td>可以只用这个模板，研究系统工作负载和虚拟内存大小的关系</td>
</tr>
<tr>
<td>3.Allocations</td>
<td>将Allocations和VM跟踪器加到跟踪文档中，使用该工具可以监视内存和对象的内存分配方式和情况。</td>
</tr>
<tr>
<td>4.CocoaLayout</td>
<td>是一种Cocoa布局工具 ，可以应用于iOS模拟器和Cocoa桌面应用，但是不能和连接的iOS设备一起使用。观察NSLayoutConstraint对象的改变，帮助我们判断什么时间什么地点的constraint是否合理</td>
</tr>
<tr>
<td>5.Core Animation</td>
<td>将CoreAnimation加入到跟踪文档中，可以测量ios设备上每秒的CoreAnimation帧数，这可以帮助你理解内容是如何渲染到屏幕上的，（图形性能）这个模块显示程序显卡性能以及CPU使用情况。</td>
</tr>
<tr>
<td>6.CoreData</td>
<td>将CoreData数据提取、缓存缺失和存储加入到跟踪文档中，使用这个工具可以检测应用程序中数据的存储交互。</td>
</tr>
<tr>
<td>7.Counters</td>
<td>收集使用时间或基于事件的抽样方法的性能监控计数器（PMC）事件。</td>
</tr>
<tr>
<td>8.Energy Log</td>
<td>耗电量监控，将Energy Diagnostics, CPU Activity, Display Brightness, Sleep/Wake, Bluetooth, WiFi, and GPS instruments加入到跟踪文档中进行检测。</td>
</tr>
<tr>
<td>9.File Activity</td>
<td>将File Activity, Reads/Writes, File Attributes, and Directory I/O instruments 加入到跟踪文档中，只用这个模板可以让你检查系统文件的使用情况，可以检查文件的打开、关闭、读和写操作，同时也可以检测文件系统本身的改变，包括权限和所有权发生的改变。</td>
</tr>
<tr>
<td>10.Leaks</td>
<td>将the Allocations and Leaks instruments加入到模板中，使用这个模板可以帮助你检测内存的泄漏。</td>
</tr>
<tr>
<td>11.Metal System Trace</td>
<td>它是是apple 2014年在ios平台上推出的高效底层的3D图形API，它通过减少驱动层的API调用CPU的消耗提高渲染效率。</td>
</tr>
<tr>
<td>12.Network</td>
<td>用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接。</td>
</tr>
<tr>
<td>13.OpenGL ES Analysis</td>
<td>将OpenGL ES Analyzer and OpenGL ES Driver加入到模板中，这个模块测量分析OpenGL ES活动正确性检测以及表现问题，提供解决建议。</td>
</tr>
<tr>
<td>14.System Trace</td>
<td>系统跟踪，通过显示当前被调度线程提供综合的系统表现，显示从用户到系统的转换代码通过两个系统调用或内存操作。</td>
</tr>
<tr>
<td>15.System Usage</td>
<td>这个模板记录关于文件读写，sockets，I/O系统活动， 输入输出。</td>
</tr>
<tr>
<td>16.Time Profile</td>
<td>执行对系统的CPU上运行的进程低负载时间为基础采样。</td>
</tr>
<tr>
<td>17. Zombies</td>
<td>测量一般的内存使用，专注于检测过度释放的野指针对象，也提供对象分配统计，以及主动分配的内存地址历史。</td>
</tr>
</tbody>
</table>
<h2 id="下面看一下这些工具是怎么使用的。"><a href="#下面看一下这些工具是怎么使用的。" class="headerlink" title="下面看一下这些工具是怎么使用的。"></a>下面看一下这些工具是怎么使用的。</h2><p><strong><em>定位内存问题</em></strong></p>
<ul>
<li>内存不合理引用，检测重复操作内存是否持续增长 Allocations每次操作后，点击mark generations button，会设置一个flag，然后查看每个迭代的详细数据。</li>
<li>内存泄漏Leaks，内存泄漏使用Leaks检测，如果对象发生内存泄漏，detail panel 中会看到对象的retain release历史记录，如果非对象发生内存泄漏，就会看到malloc和free的调用历史。</li>
<li>野指针Zombies，Zombie问题，引用retaincount为0的对象，使用Debug模式，将环境变量NSZombieEnabled设为true。</li>
</ul>
<p><strong><em>检测I/O活动</em></strong></p>
<p>检测iOS app如何使用TCP/IP和UDP/IP，与connections Instruments一起使用，检测app发送和接收的包数目。</p>
<p><strong><em>图像性能检测</em></strong></p>
<ul>
<li>core animation graphics 用来检测帧频率</li>
<li>OpenGL activity</li>
<li>GPU Driver</li>
</ul>
<p><strong><em>CPU使用</em></strong></p>
<ul>
<li>Performance Monitor Counters。</li>
<li>电量：Energry 跟踪电量、CPU、网络、显示亮度、睡眠/唤醒、蓝牙、wifi、GPS。可以全天开启Energry Diagnostics Log模式，在开发手机设备中，（重启或关机会丢失该数据），数据收集结束后，将log数据传到PC上。</li>
<li>线程使用Multicore Trace Template，分析多核性能，线程状态、调度队列、块使用情况。Multicore Trace Template包含Thread states和dispatch Instruments。</li>
<li>Timer Profiler Trace Template检测内核使用情况。</li>
</ul>
<p><strong><em>自动化测试</em></strong></p>
<p>UI automation Automation instrument 工具允许你让 iOS 应用的用户界面测试自动化。自动化界面测试可以让你：</p>
<ul>
<li>省去关键人员和释放其他工作资源</li>
<li>执行更多综合测试</li>
<li>开发可重复的回归测试</li>
<li>减少程序错误</li>
<li>提高开发周期，产品更新</li>
</ul>
]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Instruments</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Instruments使用</title>
    <url>/essay/Instruments/Instruments2/</url>
    <content><![CDATA[<p>介绍一下使用<code>查看 CPU 性能</code> 、<code>图形性能</code>和<code>内存性能</code>,要执行Instruments需要先在Xcode 中对当前的项目做 Profile (Command-I ：</p>
<p><img src="/res/Instrument/2.png" width="80%"><br><a id="more"></a><br>这时就会打开 Profiling Template 选项对话框：<br><img src="/res/Instrument/3.png" width="80%"></p>
<h2 id="查看-CPU-性能"><a href="#查看-CPU-性能" class="headerlink" title="查看 CPU 性能"></a>查看 CPU 性能</h2><p><strong>1、</strong> 选择 Time Profiler 这个模板，并点击 Choose 按钮。<br><img src="/res/Instrument/4.png" width="20%"></p>
<p><strong>2、</strong> 进入 Instruments 后，选择正确的设备和应用程序：<br><img src="/res/Instrument/5.png" width="80%"></p>
<p><strong>3、</strong>点击红色按钮运行后，就能得到 CPU 性能的结果了：<br><img src="/res/Instrument/6.png" width="80%"></p>
<p><strong>4、</strong>我们还能在时间轴面板里面去选择一段时间来查看该时间段里更为细节的 CPU 性能<br><img src="/res/Instrument/7.png" width="80%"></p>
<p>从这个结果中，我们可以看到不同的线程以及方法调用占用的时间，从而可以评估出 CPU 性能的瓶颈和优化方向。</p>
<p><strong>5、</strong>除此之外，我们还能在 Instruments 选择使用 Counters、Activity Monitor、System Trace 等 Profiling Template 对程序做 CPU 性能考量。</p>
<p><strong>6、</strong>需要注意的是，有时候如果你使用 Instruments 查看调用堆栈时可能看到的都是地址而不是函数名，这样就不太好定位问题了。这时候你可以把相关项目的 Build Settings - Debug Information Format 的 Debug 和 Release 都设置为 DWARF with dSYM File，这样就能将对应的堆栈信息符号化显示了。</p>
<h2 id="图形性能"><a href="#图形性能" class="headerlink" title="图形性能"></a>图形性能</h2><p>关于图形性能方面，我们平时最关注的应该就是「帧率」这个概念了。在 Instruments 中，我们可以使用 <code>Core Animation</code> + <code>Time Profiler</code> 来评估图形性能。使用步骤如下：</p>
<p><strong>1、</strong>同「CPU 占用性能测试」一样，先在 Xcode 中对当前的项目执行 Profile (Command-I ，并在打开的对话框中选择 Core Animaiton 这个模板：<br><img src="/res/Instrument/8.png" width="20%"><br><strong>2、</strong>进入 Instruments 后，选择正确的设备和应用程序。</p>
<p><strong>3、</strong>点击红色按钮运行应用程序，随着我们操作 App 界面，就可以看到帧率的变化和数据了：</p>
<p><img src="/res/Instrument/9.png" width="80%"><br>在滑动屏幕时，帧率越高表示性能越好，帧率过低则意味着屏幕可能会出现卡顿。</p>
<p><strong>4、</strong>在右下角面板的 Display Settings 区域，我们可以看到多个 Debug Options：</p>
<ul>
<li><code>Color Blended Layers</code>，这个选项选项基于渲染程度对屏幕中的混合区域进行绿到红的高亮显示，<strong>越红表示性能越差</strong>，会对帧率等指标造成较大的影响。红色通常是由于多个半透明图层叠加引起。</li>
<li><code>Color Hits Green and Misses Red</code>，当 UIView.layer.shouldRasterize = YES 时，耗时的图片绘制会被缓存，并当做一个简单的扁平图片来呈现。这时候，如果页面的其他区块(比如 UITableViewCell 的复用’ width=’80%’/&gt;使用缓存直接命中，就显示绿色，反之，如果不命中，这时就显示红色。<strong>红色越多，性能越差</strong>。因为栅格化生成缓存的过程是有开销的，如果缓存能被大量命中和有效使用，则总体上会降低开销，反之则意味着要频繁生成新的缓存，这会让性能问题雪上加霜。</li>
<li><code>Color Copied Images</code>，对于 GPU 不支持的色彩格式的图片只能由 CPU 来处理，把这样的图片标为蓝色。<strong>蓝色越多，性能越差</strong>。因为，我们不希望在滚动视图的时候，由 CPU 来处理图片，这样可能会对主线程造成阻塞。</li>
<li><code>Color Immediately</code>，通常 Core Animation Instruments 以每毫秒 10 次的频率更新图层调试颜色。对某些效果来说，这显然太慢了。这个选项就可以用来设置每帧都更新（可能会影响到渲染性能，而且会导致帧率测量不准，所以不要一直都设置它）。</li>
<li><code>Color Misaligned Images</code>，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。<strong>黄色、紫色越多，性能越差。</strong></li>
<li><code>Color Offscreen-Rendered Yellow</code>，这个选项会把那些离屏渲染的图层显示为黄色。<strong>黄色越多，性能越差</strong>。这些显示为黄色的图层很可能需要用 shadowPath 或者 shouldRasterize 来优化。</li>
<li><code>Color OpenGL Fast Path Blue</code>，这个选项会把任何直接使用 OpenGL 绘制的图层显示为蓝色。<strong>蓝色越多，性能越好</strong>。如果仅仅使用 UIKit 或者 Core Animation 的 API，那么不会有任何效果。如果使用 GLKView 或者 CAEAGLLayer`，那如果不显示蓝色块的话就意味着你正在强制 CPU 渲染额外的纹理，而不是绘制到屏幕。</li>
<li><code>Flash Updated Regions</code>，这个选项会把重绘的内容显示为黄色。不该出现的<strong>黄色越多，性能越差</strong>。通常我们希望只是更新的部分被标记完黄色。</li>
</ul>
<p>我们可以使用这些选项，来监测更加具体的图形性能。</p>
<p><strong>5、</strong>我们还可以选择使用 OpenGL ES Analysis、GPU Driver 等模板来监测图形相关性能。</p>
<h2 id="内存性能"><a href="#内存性能" class="headerlink" title="内存性能"></a>内存性能</h2><p>Instruments 可以帮我们了解到应用程序使用内存的几个方面：</p>
<ul>
<li><strong>全局内存使用情况(Overall Memory Use</strong>: 从全局的角度监测应用程序的内存使用情况，捕捉非预期的或大幅度的内存增长。</li>
<li><strong>内存泄露(Leaked memory </strong>: 未被你的程序引用，同时也不能被使用或释放的内存。</li>
<li><strong>废弃内存(Abandoned memory </strong>: 被你的程序引用，但是没什么卵用的内存。<br>僵尸对象(Zombies’ width=’80%’/&gt;: 僵尸对象指的是对应的内存已经被释放并且不再会使用到，但是你的程序却在某处依然有指向它的引用。在 iOS 中有一个 NSZombie 机制，这个是为了内存调试的目的而设计的一种机制。在这个机制下，当你 NSZombieEnabled 为 YES 时，当一个对应的引用计数减为 0 时，这个对象不会被释放，当这个对象再收到任何消息时，它会记录一条 warning，而不是直接崩溃，以方便我们进行程序调试。<br>这里我们介绍下查找内存泄露的过程：</li>
</ul>
<p><strong>1、</strong>同「CPU 占用性能测试」一样，先在 Xcode 中对当前的项目执行 Profile (Command-I ，并在打开的对话框中选择 Leaks 这个模板：<br><img src="/res/Instrument/10.png" width="20%"></p>
<p><strong>2、</strong>进入 Instruments 后，选择正确的设备和应用程序。</p>
<p><strong>3、</strong>点击红色按钮运行应用程序，我们可以看到如下界面：<br><img src="/res/Instrument/11.png" width="80%"></p>
<p><strong>4、</strong>在 Display Settings 中勾选 <code>Invert Call Tree</code> 和 <code>Hide System Libraries</code> 或其他选项可以过滤显示的数据。<br><img src="/res/Instrument/12.png" width="80%"></p>
<p><strong>5、</strong>在导航栏的筛选框中，我们可以输入关键字来筛选数据。<br><img src="/res/Instrument/13.png" width="80%"></p>
<p><strong>6、</strong>在实际使用中，我们进入一个页面后再退出，发现相关的内存分配没有清空，这时候就发生内存泄露了。我们查看更细节的调用信息，追踪到可能造成内存泄露的代码位置：<br><img src="/res/Instrument/14.png" width="80%"><br><strong>7、</strong>我们还可以使用 Activity Monitor、Allocations、Zombies 等模板来针对性地做内存监测。</p>
]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Instruments</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Instruments实践-解决卡顿 使你的界面保持流畅</title>
    <url>/essay/Instruments/Instruments3/</url>
    <content><![CDATA[<p>结合Instrument CoreAnimation分析影响性能的因素： <strong>图层混合</strong>,<strong>光栅化</strong>,<strong>颜色格式</strong>,<strong>图片大小</strong>,<strong>离屏渲染</strong></p>
<p>在使用UIKit的过程中，性能优化是永恒的话题。很多人都看过分析优化滑动性能的文章，但其中不少文章只介绍了优化方法却对背后的原理避而不谈，或者是晦涩难懂而且读者缺乏实践体验的机会。不妨思考一下下面的问题自己是否有一个清晰的认识：</p>
<ol>
<li>为什么要把控件尽量设置成不透明的，如果是透明的会有什么影响，如何检测这种影响？</li>
<li>为什么cell中的图片，尽可能要使用正确的大小、格式，如果错误会有什么影响，如何检测这种影响？</li>
<li>为什么设置阴影和圆角有可能影响滑动时流畅度？</li>
<li>shouldRasterize和离屏渲染的关系是什么，何时应该使用？</li>
</ol>
<a id="more"></a>
<p><img src="/res/Instrument/9.png" width="80%"></p>
<p>打开CoreAnimation可以看到主体的PFS数据和右边的Debug Options。</p>
<p>我们知道任何屏幕总是有一个刷新率，比如iphone推荐的刷新率是60Hz，也就是说GPU每秒钟刷新屏幕60次，因此两次刷新之间的间隔为16.67ms。这段时间内屏幕内容保持不变，称为一帧(frame)，fps表示frames per second，也就是每秒钟显示多少帧画面。对于静止不变的内容，我们不需要考虑它的刷新率，但在执行动画或滑动时，fps的值直接反映出滑动的流畅程度。</p>
<h2 id="图层混合"><a href="#图层混合" class="headerlink" title="图层混合"></a>图层混合</h2><p>首先我们要明白像素的概念，屏幕上每一个点都是一个像素，像素有R、G、B三种颜色构成(有时候还带有alpha值)。如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</p>
<p>第一个调试选项”Color Blended Layers”正是用于检测哪里发生了图层混合，并用红色标记出来。因此我们需要尽可能减少看到的红色区域。一旦发现应该想法设法消除它。</p>
<p><img src="/res/Instrument/15.png" width="40%"></p>
<p>解决办法如下：</p>
<ol>
<li>透明度设置为100%<ul>
<li>如果某一块区域上覆盖了多个layer,最后的显示效果受到这些layer的共同影响。举个例子，上层是蓝色(RGB=0,0,1),透明度为50%，下层是红色(RGB=1,0,0)。那么最终的显示效果是紫色(RGB=0.5,0,0.5)。这种颜色的混合(blending)需要消耗一定的GPU资源，因为实际上可能不止只有两层。如果只想显示最上层的蓝色，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。</li>
</ul>
</li>
<li>UIImageView的图片也不能含有alpha通道<ul>
<li>图像自身的性质可能会对结果有影响</li>
</ul>
</li>
<li>设置 backgroundColor 属性（如果不设置背景颜色，控件依然会被认为是透明的）<ul>
<li>虽然在白色背景下，无法肉眼看到效果，但重新调试后我们可以发现label的红色消失了。也正是因为对背景颜色的不重视，它成了影响滑动性能的第一个杀手。</li>
</ul>
</li>
<li>如果label文字有中文，依然会出现图层混合，这是因为此时label多了一个sublayer</li>
</ol>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>第二个调试选项是<strong>“Color Hits Green and Misses Red</strong>”，它表示如果命中缓存则显示为绿色，否则显示为红色，显然绿色越多越好，红色越少越好。勾选这个选项后我们看到如下的场景：</p>
<p><img src="/res/Instrument/16.png" width="40%"></p>
<p>光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这一行代码表示将label的layer光栅化：</span></span><br><span class="line">label.layer.shouldRasterize = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>因为layer进行光栅化后渲染成位图放在缓存中。缓存中的对象有效期只有100ms，即如果在0.1s内没有被使用就会自动从缓存中清理出去。光栅化的缓存机制是一把双刃剑，先写入缓存再读取有可能消耗较多的时间。因此光栅化仅适用于较复杂的、静态的效果。 光栅化会导致离屏渲染</p>
<p>所以我们做的第二个优化是注释掉下面这行代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    label.layer.shouldRasterize = true</span></span><br></pre></td></tr></table></figure>
<h2 id="颜色格式"><a href="#颜色格式" class="headerlink" title="颜色格式"></a>颜色格式</h2><p>像素在内存中的布局和它在磁盘中的存储方式并不相同。考虑一种简单的情况：每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。</p>
<p>当我们打开JPEG格式的图片时，CPU会进行一系列运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。借用WWDC上的一页PPT来说明：</p>
<p><img src="/res/Instrument/t_UIKit性能优化22.png" alt></p>
<p>Commit Transaction和Decode在同一帧内进行，如果这两个操作的耗时超过16.67s，Draw Calls就会延迟到下一帧，从而导致fps值的降低。下面是Commit Transaction的详细流程：</p>
<p><img src="/res/Instrument/t_UIKit性能优化23.png" alt></p>
<p>在第三步的Prepare中，CPU主要处理两件事：</p>
<ol>
<li>把图片从PNG或JPEG等格式中解压出来，得到像素数据</li>
<li>如果GPU不支持这种颜色各式，CPU需要进行格式转换</li>
</ol>
<p>使用core animation 的 <strong>Color Copied Images</strong>检测图片格式,确保图片颜色格式能被GPU支持</p>
<h2 id="图片大小"><a href="#图片大小" class="headerlink" title="图片大小"></a>图片大小</h2><p>使用core animation 的第五个选项“<strong>Color Misaligned Images”</strong>。它表示如果图片需要缩放则标记为黄色，如果没有像素对齐则标记为紫色。勾选上这个选项并进行调试，可以看到如下场景：</p>
<p><img src="/res/Instrument/17.png" width="40%"></p>
<p>图片如果需要缩放会占用一定时间，确保图片大小与frame一致，不要在滑动的时候缩放图片</p>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>开始调试并勾选“<strong>Color Offscreen-Rendered Yellow”</strong>，会看到这样的场景：</p>
<p><img src="/res/Instrument/20.png" width="40%"></p>
<p>这表示产生了离屏渲染。离屏渲染表示渲染发生在屏幕之外，你可能认为这是一句废话。为了真正解释清楚什么是离屏渲染，我们先来看一下正常的渲染通道(Render-Pass)：</p>
<p><img src="/res/Instrument/18.png"> </p>
<p>首先，OpenGL提交一个命令到Command Buffer，随后GPU开始渲染，渲染结果放到Render Buffer中，这是正常的渲染流程。但是有一些复杂的效果无法直接渲染出结果，它需要分步渲染最后再组合起来，比如添加一个蒙版(mask)：</p>
<p><img src="/res/Instrument/19.png"> </p>
<p>在前两个渲染通道中，GPU分别得到了纹理(texture，也就是那个相机图标)和layer(蓝色的蒙版)的渲染结果。但这两个渲染结果没有直接放入Render Buffer中，也就表示这是离屏渲染。直到第三个渲染通道，才把两者组合起来放入Render Buffer中。离屏渲染意味着把渲染结果临时保存，等用到时再取出，因此相对于普通渲染更占用资源。</p>
<p>以下情况可能会导致触发离屏渲染：</p>
<ol>
<li>重写drawRect方法</li>
<li>有mask或者是阴影(layer.masksToBounds, layer.shadow*)，模糊效果也是一种mask</li>
<li>layer.shouldRasterize = true</li>
</ol>
<h2 id="卡顿的解决方案"><a href="#卡顿的解决方案" class="headerlink" title="卡顿的解决方案"></a>卡顿的解决方案</h2><p>CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h3 id="CPU-资源消耗原因和解决方案"><a href="#CPU-资源消耗原因和解决方案" class="headerlink" title="CPU 资源消耗原因和解决方案"></a>CPU 资源消耗原因和解决方案</h3><p><strong>1. 对象创建：</strong></p>
<p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</p>
<p>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</p>
<p><strong>2. 对象调整: </strong></p>
<p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p>
<p><strong>3. 对象销毁: </strong></p>
<p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4. 布局计算: </strong></p>
<p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</p>
<p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p>
<p><strong>5. Autolayout: </strong></p>
<p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<a href="http://pilky.me/36/" target="_blank" rel="noopener">http://pilky.me/36/</a>。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p>
<p><strong>6. 文本计算: </strong></p>
<p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p>
<p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p>
<p><strong>7. 文本渲染:</strong></p>
<p>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<p><strong>8. 图片的解码:</strong></p>
<p>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</p>
<p><strong>9. 图像的绘制:</strong></p>
<p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GPU-资源消耗原因和解决方案"><a href="#GPU-资源消耗原因和解决方案" class="headerlink" title="GPU 资源消耗原因和解决方案"></a>GPU 资源消耗原因和解决方案</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p>
<p><strong>1. 纹理的渲染</strong></p>
<p>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</p>
<p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。</p>
<p><strong>2. 视图的混合 (Composing)</strong></p>
<p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</p>
<p><strong>3. 图形的生成</strong></p>
<p>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</p>
<!--iOS 保持界面流畅的技巧 https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/ -->
<!--内存恶鬼drawRect https://bihongbo.com/2016/01/03/memoryGhostdrawRect/ -->
<!-- UIKit性能调试 https://bestswifter.com/uikitxing-neng-diao-you-shi-zhan-jiang-jie/-->]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Instruments</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>LLDB教程-命令篇</title>
    <url>/essay/LLDB/LLDB_tutorial/</url>
    <content><![CDATA[<p>你是否曾经苦恼于理解项目的代码，而去尝试打印一个变量的值？然后使用NSLog 并且每次必须重新编译，从头开始？但是不一定要这么做。你可以使用调试器。而且即使你已经知道如何使用调试器检查变量，它可以做的还有很多。</p>
<h2 id="LLDB-是什么？"><a href="#LLDB-是什么？" class="headerlink" title="LLDB 是什么？"></a>LLDB 是什么？</h2><p><a href="http://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a>是Mac OS X上Xcode的默认调试器，支持再桌面和iOS设备和模拟器上调试C ，Objective-C和C++。它是新一代高性能调试器，它可以高效利用LLVM项目中的现有库，例如Clang表达式解析器和LLVM反汇编程序。</p>
<p>随着Xcode 5的发布，LLDB调试器已经取代了GDB，成为了Xcode工程中默认的调试器。它与LLVM编译器一起，带给我们更丰富的流程控制和数据检测的调试功能。LLDB为Xcode提供了底层调试环境，其中包括内嵌在Xcode IDE中的位于调试区域的控制面板。</p>
<p><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a> 是facebook下一个开源LLDB命令集合。</p>
<p>与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。</p>
<a id="more"></a>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><img src="/res/LLDB/1.png" alt></p>
<p>这是一个简单加了断点的程序，程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。这时候我们应该打些什么命令呢？</p>
<p><strong><em>帮助 help</em></strong></p>
<p>最简单命令是 <code>help</code>，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 <code>help &lt;command-name&gt;</code> 来了解更多细节，例如 <code>help print</code> 或者 <code>help thread</code>。只需要在控制台 上图lldb字样的地方键入 help即可。</p>
<p><img src="/res/LLDB/2.png" alt></p>
<p><strong><em>打印对象 print</em></strong><br>打印值很简单；只要试试 print 命令:</p>
<p><img src="/res/LLDB/3.png" alt></p>
<p>LLDB 实际上会作前缀匹配。所以你也可以使用 prin，pri，或者 p。但你不能使用 pr，因为 LLDB 不能消除和 process 的歧义 (幸运的是 p 并没有歧义)。而print 则是<code>expression --</code>的简写方式。</p>
<p>你可能还注意到了，结果中有个 $0。实际上你可以使用它来指向这个结果。试试 print $0 + 7，你会看到 130。任何以$符开头的东西都是存在于 LLDB 的命名空间的，它们是为了帮助你进行调试而存在的。</p>
<p>打印复杂对象时，print可能显得力不从心 ，我们想看的是对象的 description 方法的结果，这时可以使用 <code>po</code> ，po 其实是 <code>e -o --</code>的别名。</p>
<p>甚至可以给print 指定不同的打印格式。它们都是以 <code>print/&lt;fmt&gt;</code> 或者简化的 <code>p/&lt;fmt&gt;</code> 格式书写。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的格式</span></span><br><span class="line">(lldb) p <span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="comment">//十六进制:</span></span><br><span class="line">(lldb) p/x <span class="number">16</span></span><br><span class="line"><span class="number">0x10</span></span><br><span class="line"><span class="comment">//二进制 (t 代表 two)：</span></span><br><span class="line">(lldb) p/t <span class="number">16</span></span><br><span class="line"><span class="number">0</span>b00000000000000000000000000010000</span><br><span class="line">(lldb) p/t (<span class="keyword">char</span>)<span class="number">16</span></span><br><span class="line"><span class="number">0</span>b00010000</span><br></pre></td></tr></table></figure>
<p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">这里是格式的完整清单</a></p>
<p><strong><em>修改对象 expression</em></strong></p>
<p>如果想改变一个值怎么办？我们要用到的是 <code>expression</code> 这个方便的命令。</p>
<p><img src="/res/LLDB/4.png" alt></p>
<p>上图中修改了num的值，断点步进后可以看到NSLog的对应值已经发生了变化。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>现在你已经可以打印对象和简单类型，并且知道如何使用 expression 命令在调试器中修改它们了。现在让我们使用一些变量来减少输入量。就像你可以在 C 语言中用 int a = 0 来声明一个变量一样，你也可以在 LLDB 中做同样的事情。不过为了能使用声明的变量，变量必须以$符开头。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) e <span class="keyword">int</span> $a = <span class="number">2</span></span><br><span class="line">(lldb) p $a * <span class="number">19</span></span><br><span class="line"><span class="number">38</span></span><br><span class="line">(lldb) e <span class="built_in">NSArray</span> *$array = @[ <span class="string">@"Saturday"</span>, <span class="string">@"Sunday"</span>, <span class="string">@"Monday"</span> ]</span><br><span class="line">(lldb) p [$array count]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">(lldb) po [[$array objectAtIndex:<span class="number">0</span>] uppercaseString]</span><br><span class="line">SATURDAY</span><br><span class="line">(lldb) p (<span class="keyword">char</span>)[[$array objectAtIndex:$a] characterAtIndex:<span class="number">0</span>]</span><br><span class="line"><span class="string">'M'</span></span><br><span class="line">(lldb) p/d (<span class="keyword">char</span>)[[$array objectAtIndex:$a] characterAtIndex:<span class="number">0</span>]</span><br><span class="line"><span class="number">77</span></span><br></pre></td></tr></table></figure>
<h3 id="UI调试"><a href="#UI调试" class="headerlink" title="UI调试"></a>UI调试</h3><p>因为全局变量是可访问的,可以像这样打印整个视图层级：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</span><br><span class="line">&lt;UIWindow: 0x7fe5ac70c6a0; frame = (0 0; 375 812); gestureRecognizers = &lt;NSArray: 0x6000034cb780&gt;; layer = &lt;UIWindowLayer: 0x600003a84680&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x7fe5ac5069b0; frame = (0 0; 375 812); autoresize = W+H; layer = &lt;CALayer: 0x600003ad3620&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong><em>1、更新UI</em></strong></p>
<p>就像上文变量中提到那样，我们可以拿到这个view:</p>
<p><code>(lldb) expression id $myView = (id)0x7fe5ac5069b0</code></p>
<p>尝试做一些修改：</p>
<p><code>(lldb) expression (void)[$myView setBackgroundColor:[UIColor redColor]]</code></p>
<p>但是只有程序继续运行之后才会看到界面的变化。因为改变的内容必须被发送到渲染服务中，然后显示才会被更新。</p>
<p>渲染服务实际上是一个另外的进程 (被称作 backboardd)。这就是说即使我们正在调试的内容所在的进程被打断了，backboardd 也还是继续运行着的。</p>
<p>这意味着你可以运行下面的命令，而不用继续运行程序：</p>
<p><code>(lldb) expression (void)[CATransaction flush]</code></p>
<p>这个时候就能看到背景颜色的改变了。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>通过xcode加断点调试时，调试条上回出现四个可以控制程序执行流程的按钮：<br><img src="/res/LLDB/5.png" alt></p>
<p>从左到右分别是 continue program execution 、 step over 、 step into 和 step out。</p>
<p><strong><em>1、 continue program execution</em></strong> 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。<br>在 LLDB 中，你可以使用 <code>process continue</code> 或者 <code>thread continue</code> 命令来达到同样的效果。</p>
<p><strong><em>2、 step over</em></strong> 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。<br>LLDB 则可以使用 <code>thread step-over</code>，<code>next</code>，或者 <code>n</code> 命令。</p>
<p><strong><em>3、 step in</em></strong>按钮，可以跳进一个函数调用来调试或者检查程序的执行情况。<br>在LLDB中使用 <code>thread step-in</code>，<code>step</code>，或者 s 命令。注意，当前行不是函数调用时，next 和 step 效果是一样的。</p>
<p><strong><em>4、step out</em></strong>按钮 ，如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 n 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。<br>在LLDB中使用 <code>thread step-out</code>，</p>
<p><strong><em>thread return</em></strong> 使用<code>help thread</code>可以看到这个比较实用的函数。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。</p>
<h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>Xcode在断点导航中提供了一系列工具创建和管理断点，我们可以来看LLDB中等价的命令,主要是<code>breakpoint</code>命令。</p>
<p><strong><em>1、查看 启用/禁用</em></strong></p>
<p><img src="/res/LLDB/6.png" alt></p>
<p>上图是xcode查看断点的地方，点击断点会开启或关闭断点。对应的LLDB如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看断点 命令输出列表显示每个逻辑断点都有一个整数标识</span></span><br><span class="line"><span class="comment">//输出列表中另一个信息是断点位置是否是已解析的(resolved)。这个标识表示当与之相关的文件地址被加载到程序进行调试时，其位置是已解析的。</span></span><br><span class="line">  <span class="comment">//例如，如果在共享库中设置的断点之后被卸载了，则断点的位置还会保留，但其不能再被解析。</span></span><br><span class="line">(lldb) breakpoint list</span><br><span class="line">Current breakpoints:</span><br><span class="line">1: file = '/Users/suntongsheng/Desktop/tmp/asdasd/asdasd/main.m', line = 23, exact_match = 0, locations = 1, resolved = 1, hit count = 1</span><br><span class="line"></span><br><span class="line">  <span class="number">1.1</span>: where = asdasd`main + <span class="number">51</span> at main.m:<span class="number">23</span>, address = <span class="number">0x00000001070195d3</span>, resolved, hit count = <span class="number">1</span> </span><br><span class="line"><span class="comment">//禁用断点</span></span><br><span class="line">(lldb) breakpoint disable <span class="number">1</span></span><br><span class="line"><span class="number">1</span> breakpoints disabled.</span><br><span class="line"><span class="comment">//启用断点</span></span><br><span class="line">(lldb) breakpoint enable <span class="number">1</span></span><br><span class="line"><span class="number">1</span> breakpoints enabled.</span><br></pre></td></tr></table></figure>
<p><strong><em>2、 创建/删除</em></strong></p>
<p>在Xcode创建断点的方式一种是 直接在代码左边的行数出点击 即可创建断点。对应的LLDB如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main.m的第24行创建断点</span></span><br><span class="line">(lldb) breakpoint set -f main.m -l <span class="number">24</span></span><br><span class="line">Breakpoint <span class="number">3</span>: where = asdasd`main + <span class="number">59</span> at main.m:<span class="number">24</span>, address = <span class="number">0x00000001070195db</span></span><br><span class="line"><span class="comment">//删除刚才的断点</span></span><br><span class="line">(lldb) breakpoint delete <span class="number">3</span></span><br><span class="line"><span class="number">1</span> breakpoints deleted; <span class="number">0</span> breakpoint locations disabled.</span><br></pre></td></tr></table></figure>
<p>还有一种是在断点导航，点击左下角的加号按钮，选择Symbolic BreakPoint会出现：</p>
<p><img src="/res/LLDB/7.png" alt></p>
<p>对应的LLDB如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行</span></span><br><span class="line">(lldb) breakpoint set  -F isEven</span><br><span class="line">Breakpoint <span class="number">6</span>: where = asdasd`isEven + <span class="number">16</span> at main.m:<span class="number">13</span>, address = <span class="number">0x0000000107019750</span></span><br><span class="line"><span class="comment">//Objective-C 的方法也完全可以</span></span><br><span class="line">(lldb) breakpoint set -F <span class="string">"-[NSArray objectAtIndex:]"</span></span><br><span class="line">Breakpoint <span class="number">5</span>: where = CoreFoundation`-[<span class="built_in">NSArray</span> objectAtIndex:], address = <span class="number">0x000000010ac7a950</span></span><br></pre></td></tr></table></figure>
<p>在 <code>[NSArray objectAtIndex:]</code>这个断点上，我们怎么能知道设置了什么呢？接下来我们可以用$arg1、$arg2等命令来打印出我们想要的信息。<br>在这里$arg1是指对象本身，$arg2是对象被调用的函数，po命令无法直接输出函数名，需要加上(SEL)，$arg3是被赋给函数的参数。</p>
<p><strong><em>3、 断点行为</em></strong></p>
<p>在Xcode中邮件断点可以编辑添加action信息，你可以添加多个行为：</p>
<p><img src="/res/LLDB/8.png" alt></p>
<p>对应的LLDB如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint set -f main.m -l <span class="number">31</span></span><br><span class="line">Breakpoint <span class="number">2</span>: where = asdasd`main + <span class="number">205</span> at main.m:<span class="number">31</span>, address = <span class="number">0x000000010ab2166d</span></span><br><span class="line"><span class="comment">//添加条件</span></span><br><span class="line">(lldb) breakpoint modify -c 'i == 80' 2</span><br><span class="line"><span class="comment">//添加行为</span></span><br><span class="line">(lldb) breakpoint command add <span class="number">2</span></span><br><span class="line">Enter your debugger command(s).  Type 'DONE' to end.</span><br><span class="line">&gt; po i</span><br><span class="line">&gt; DONE</span><br><span class="line"><span class="comment">//显示刚才的断点</span></span><br><span class="line">(lldb) breakpoint list <span class="number">2</span></span><br><span class="line">2: file = 'main.m', line = 31, exact_match = 0, locations = 1, resolved = 1, hit count = 0</span><br><span class="line">    Breakpoint commands:</span><br><span class="line">      po i</span><br><span class="line"></span><br><span class="line">Condition: i == <span class="number">80</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2.1</span>: where = asdasd`main + <span class="number">205</span> at main.m:<span class="number">31</span>, address = <span class="number">0x000000010ab2166d</span>, resolved, hit count = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 expression 命令来改变变量，然后继续运行。</p>
<h2 id="查看-线程-调用栈-状态"><a href="#查看-线程-调用栈-状态" class="headerlink" title="查看 线程/调用栈 状态"></a>查看 线程/调用栈 状态</h2><p>在进程停止后，LLDB会选择一个当前线程和线程中当前帧(frame)。很多检测状态的命令可以用于这个线程或帧。</p>
<p>为了检测进程的当前状态，可以从以下命令<code>thread list</code>开始：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) thread list</span><br><span class="line">Process <span class="number">48541</span> stopped</span><br><span class="line">* thread <span class="meta">#1: tid = 0x3bd1d2, 0x000000010eae0b66 libsystem_kernel.dylib`__pthread_kill + 10, queue = 'com.apple.main-thread', stop reason = signal SIGABRT</span></span><br><span class="line">  thread <span class="meta">#2: tid = 0x3bd24c, 0x000000010eae128a libsystem_kernel.dylib`__workq_kernreturn + 10</span></span><br></pre></td></tr></table></figure>
<p>星号(*)表示thread #1为当前线程。为了获取线程的跟踪栈，可以使用以下命令<code>thread backtrace</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认为当前线程 也可以指定线程 : thread backtrace 2</span></span><br><span class="line">(lldb) thread backtrace</span><br><span class="line">thread <span class="meta">#1: tid = 0x2c03, stop reason = breakpoint 1.1, queue = com.apple.main-thread</span></span><br><span class="line"> frame <span class="meta">#0: 0x0000000100010d5b, where = Sketch`-[SKTGraphicView alignLeftEdges:] + 33 at /Projects/Sketch/SKTGraphicView.m:1405</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果想查看所有线程的调用栈，则可以使用以下命令：<code>(lldb) thread backtrace all</code></p>
<p>检查帧参数和本地变量的最简便的方式是使用<code>frame variable</code>命令：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span>) argc = <span class="number">1</span></span><br><span class="line">(<span class="keyword">char</span> **) argv = <span class="number">0x00007ffee4150ff0</span></span><br><span class="line">(<span class="built_in">NSUInteger</span>) num = <span class="number">123</span></span><br><span class="line">(__NSCFConstantString *) str = <span class="number">0x000000010bab00d8</span> <span class="string">@"learning LLDB"</span></span><br><span class="line">(__NSArrayI *) arr = <span class="number">0x0000600002982fa0</span> <span class="string">@"2 elements"</span></span><br><span class="line">(<span class="keyword">int</span>) i = <span class="number">80</span></span><br><span class="line">(<span class="built_in">BOOL</span>) result0 = <span class="literal">YES</span></span><br><span class="line">(<span class="built_in">BOOL</span>) result1 = <span class="literal">NO</span></span><br></pre></td></tr></table></figure>
<p>如果没有指定任何变量名，则会显示所有参数和本地变量。如果指定参数名或变量名，则只打印指定的值。如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) frame variable <span class="keyword">self</span></span><br><span class="line">(<span class="built_in">SKTGraphicView</span> *) <span class="keyword">self</span> = <span class="number">0x0000000100208b40</span></span><br></pre></td></tr></table></figure>
<p>如果想查看另外一帧，可以使用<code>frame select</code>命令，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) frame select <span class="number">2</span></span><br><span class="line">frame <span class="meta">#2: 0x000000010e88dc45 libsystem_c.dylib`abort + 127</span></span><br></pre></td></tr></table></figure>
<h2 id="image"><a href="#image" class="headerlink" title="image"></a>image</h2><p>image指令是target module指令的缩写，借助它我们能够查看当前的Binary Images相关的信息。日常开发我们主要利用它寻址。<code>image</code>命令的用法也挺多，首先可以用它来查看工程中使用的库，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) image list</span><br><span class="line">[  <span class="number">0</span>] <span class="number">9E11</span>F0C7<span class="number">-9</span>AB1<span class="number">-36</span>A8<span class="number">-8</span>FE4<span class="number">-8821</span>DBA05A2F <span class="number">0x000000010baad000</span> /Users/suntongsheng/Library/Developer/Xcode/DerivedData/asdasd-dufvhftdhjomdkcnrilgxlwykarv/Build/Products/Debug-iphonesimulator/asdasd.app/asdasd </span><br><span class="line">[  <span class="number">1</span>] <span class="number">8</span>A72DE9C-A136<span class="number">-3506</span>-AA02<span class="number">-4</span>BA2B82DCAF3 <span class="number">0x0000000115aa8000</span> /usr/lib/dyld</span><br></pre></td></tr></table></figure>
<p>我们还可以用它来查找可执行文件或共享库的原始地址，这一点还是很有用的，当我们的程序崩溃时，我们可以使用这条命令来查找崩溃所在的具体位置，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>, @<span class="number">2</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array 3: %@"</span>, array[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//这段代码会抛出</span></span><br><span class="line">2019-03-19 16:10:32.841204+0800 asdasd[49351:4010863] *** Terminating app due to uncaught exception 'NSRangeException', reason: '*** -[__NSArrayI objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1]'</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">	<span class="number">0</span>   CoreFoundation                      <span class="number">0x0000000102c7f1bb</span> __exceptionPreprocess + <span class="number">331</span></span><br><span class="line">	<span class="number">1</span>   libobjc.A.dylib                     <span class="number">0x000000010221d735</span> objc_exception_throw + <span class="number">48</span></span><br><span class="line">	<span class="number">2</span>   CoreFoundation                      <span class="number">0x0000000102bcb4ec</span> _CFThrowFormattedException + <span class="number">194</span></span><br><span class="line">	<span class="number">3</span>   CoreFoundation                      <span class="number">0x0000000102d01b00</span> +[__NSArrayI allocWithZone:] + <span class="number">0</span></span><br><span class="line">	<span class="number">4</span>   asdasd                              <span class="number">0x00000001019004ff</span> -[ViewController viewDidLoad] + <span class="number">287</span></span><br></pre></td></tr></table></figure>
<p>根据以上信息，我们可以判断崩溃位置是在ViewController中，要想知道具体在哪一行，可以使用以下命令<code>image lookup --address</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">(lldb) image lookup --address <span class="number">0x00000001019004ff</span></span><br><span class="line">      Address: asdasd[<span class="number">0x00000001000014ff</span>] (asdasd.__TEXT.__text + <span class="number">287</span>)</span><br><span class="line">      Summary: asdasd`-[ViewController viewDidLoad] + <span class="number">287</span> at ViewController.m:<span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>可以看到，最后定位到了ViewController.m:23行，正是我们代码所在的位置。</p>
<p>image更多用法可以参考： <a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/lldb-command-examples.html#//apple_ref/doc/uid/TP40012917-CH3-SW5" target="_blank" rel="noopener">Executable and Shared Library Query Commands。</a></p>
<!-- http://southpeak.github.io/2015/01/25/tool-lldb/ -->
<!-- https://juejin.im/post/5b1cd870e51d4506dc0ac76c -->
<!-- https://www.jianshu.com/p/67f08a4d8cf2 -->]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O文件格式字段简介</title>
    <url>/essay/LLDB/Mach-O_file/</url>
    <content><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本次来学习下Mach-O文件的格式,Mach-O（Mach Object File Format） 是针对不同运行时可执行文件的文件类型。</p>
<p>文件类型：</p>
<p>Executable： 应用的主要二进制<br>Dylib： 动态链接库（又称 DSO 或 DLL）<br>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。</p>
<p>Mach-O 文件格式如下:</p>
<p><img src="/res/MachO/macho_struct.png" width="70%"><br><a id="more"></a></p>
<p><strong>如何查看文件格式:</strong></p>
<p>我们可以通过file指令查看文件的具体格式:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ file asdasd</span><br><span class="line">asdasd: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure>
<p>目前已知的架构分为armv7,armv7s,arm64,i386,x86_64等等，MachO中其实也是这些架构的集合。MachO可以是多架构的二进制文件，称之为「通用二进制文件」</p>
<p><strong>拆分、重组MachO</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用lipo -info 可以查看MachO文件包含的架构</span></span><br><span class="line">$ lipo -info MachO文件</span><br><span class="line"><span class="comment">#  使用lipo –thin 拆分某种架构</span></span><br><span class="line">$ lipo MachO文件 –thin 架构 –output 输出文件路径</span><br><span class="line"><span class="comment">#  使用lipo -create  合并多种架构</span></span><br><span class="line">$ lipo -create MachO1  MachO2  -output 输出文件路径</span><br></pre></td></tr></table></figure>
<h2 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a>Mach-O文件格式</h2><p>新建一个单页面工程 使用 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView</a> 来查看.app包内的mach-o文件:</p>
<p><img src="/res/MachO/macho1.png" alt></p>
<p>结合可知 Mach-O 文件包含了三部分内容：</p>
<ul>
<li>Header（头部），指明了 cpu 架构、大小端序、文件类型、Load Commands 个数等一些基本信息</li>
<li>Load Commands（加载命令)，正如官方的图所示，描述了怎样加载每个 Segment 的信息。在 Mach-O 文件中可以有多个 Segment，每个 Segment 可能包含一个或多个 Section。</li>
<li>Data（数据区），Segment 的具体数据，包含了代码和数据等。</li>
</ul>
<p><em>需要注意的是，不仅仅是可执行文件是Macho-O，目标文件(.o)以及动态库，静态库都是Mach-O格式。</em></p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>Mach-O 文件的头部定义如下 <a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h.auto.html" target="_blank" rel="noopener">loader.h</a>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* 标志符 0xfeedface 是 32 位， 0xfeedfacf 是 64 位。*/</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu 类型、平台 */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* cpu 类型、平台 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* 文件类型，可执行文件、符号文件（DSYM）、内核扩展等 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* 加载 Load Commands 的数量 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* 加载 Load Commands 的大小 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* dyld 动态链接器 加载的标志*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* 64 位的保留字段 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上图中看出<code>asdasd</code>这个文件header对应的是 <code>MH_MAGIC_64</code> 、<code>CPU_TYPE_X86_64_ALL</code> 、<code>MH_EXECUTE</code>…等</p>
<p>filetype的定义有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_OBJECT    0x1        <span class="comment">/* Target 文件：编译器对源码编译后得到的中间结果 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_EXECUTE    0x2        <span class="comment">/* 可执行二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_FVMLIB    0x3        <span class="comment">/* VM 共享库文件（还不清楚是什么东西） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_CORE        0x4        <span class="comment">/* Core 文件，一般在 App Crash 产生 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_PRELOAD    0x5        <span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLIB    0x6        <span class="comment">/* 动态库 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLINKER    0x7        <span class="comment">/* 动态连接器 /usr/lib/dyld */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_BUNDLE    0x8        <span class="comment">/* 非独立的二进制文件，往往通过 gcc-bundle 生成 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DYLIB_STUB    0x9        <span class="comment">/* 静态链接文件（还不清楚是什么东西） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_DSYM        0xa        <span class="comment">/* 符号文件以及调试信息，在解析堆栈符号中常用 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_KEXT_BUNDLE    0xb        <span class="comment">/* x86_64 内核扩展 */</span></span></span><br></pre></td></tr></table></figure>
<p>和部分flags定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_NOUNDEFS    0x1        <span class="comment">/* Target 文件中没有带未定义的符号，常为静态二进制文件 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS    0x20  <span class="comment">/* Target 文件中的只读 Segment 和可读写 Segment 分开  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL    0x80        <span class="comment">/* 该 Image 使用二级命名空间(two name space binding)绑定方案 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT    0x100 <span class="comment">/* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES    0x8000 <span class="comment">/* 二进制文件使用了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000 <span class="comment">/* 二进制文件链接了弱符号 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* 允许 Stack 可执行 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    MH_PIE 0x200000  <span class="comment">/* 对可执行的文件类型启用地址空间 layout 随机化 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000 <span class="comment">/* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Mach-O 文件头主要目的是为加载命令提供信息。加载命令过程紧跟在头之后，并且 ncmds 和 sizeofcmds 来能个字段将会用在加载命令的过程中。</p>
<h3 id="Load-Commands"><a href="#Load-Commands" class="headerlink" title="Load Commands"></a>Load Commands</h3><p>Headers之后就是Load Commands,其占用的内存和加载命令总数已经在Header中 ncmds/sizeofcmds 中指出。</p>
<p><img src="/res/MachO/loadcommand1.png" alt></p>
<p>load commands的定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/*  load command 类型*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* command大小 用于计算出到下一个 command 的偏移量*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cmd 字段指出了 command 类型,主要有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line">LC_SEGMENT、LC_SEGMENT_64 将 segment 映射到进程的内存空间，</span><br><span class="line">LC_UUID 二进制文件 id，与符号表 uuid 对应，可用作符号表匹配，</span><br><span class="line">LC_LOAD_DYLINKER 启动动态加载器，</span><br><span class="line">LC_SYMTAB 描述在 __LINKEDIT 段的哪找字符串表、符号表，</span><br><span class="line">LC_CODE_SIGNATURE 代码签名等</span><br></pre></td></tr></table></figure>
<p>LC_SEGMENT_64和LC_SEGMENT是加载的主要命令，它负责指导内核来设置进程的内存空间。一般Mach-O文件有多个段(Segement)，段每个段有不同的功能，一般包括：</p>
<ol>
<li>__PAGEZERO: 空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用；</li>
<li>__TEXT: 包含了执行代码以及其他只读数据。该段数据的保护级别为：VM_PROT_READ（读）、VM_PROT_EXECUTE(执行)，防止在内存中被修改；</li>
<li>__DATA: 包含了程序数据，该段可写；</li>
<li>__LINKEDIT: 链接器使用的符号以及其他表</li>
</ol>
<h3 id="Segment-amp-Section"><a href="#Segment-amp-Section" class="headerlink" title="Segment &amp; Section"></a>Segment &amp; Section</h3><p>Segment定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* section_64 结构体所需要的空间 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment 名字，上述宏中的定义 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;        <span class="comment">/* 所描述段的虚拟内存地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;        <span class="comment">/* 为当前段分配的虚拟内存大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;    <span class="comment">/* 当前段在文件中的偏移量 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;    <span class="comment">/* 当前段在文件中占用的字节 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    maxprot;    <span class="comment">/* 段所在页所需要的最高内存保护，用八进制表示 */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    initprot;    <span class="comment">/* 段所在页原始内存保护 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;        <span class="comment">/* 段中 Section 数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 标识符 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 segname 在源码中定义的宏，有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_PAGEZERO    <span class="meta-string">"__PAGEZERO"</span> <span class="comment">/* 当时 MH_EXECUTE 文件时，捕获到空指针 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_TEXT    <span class="meta-string">"__TEXT"</span> <span class="comment">/* 代码/只读数据段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_DATA    <span class="meta-string">"__DATA"</span> <span class="comment">/* 数据段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_OBJC    <span class="meta-string">"__OBJC"</span> <span class="comment">/* Objective-C runtime 段 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SEG_LINKEDIT    <span class="meta-string">"__LINKEDIT"</span> <span class="comment">/* 包含需要被动态链接器使用的符号和其他表，包括符号表、字符串表等 */</span></span></span><br></pre></td></tr></table></figure>
<p>部分的 Segment （主要指的 <code>__TEXT</code> 和 <code>__DATA</code>）可以进一步分解为 Section。之所以按照 Segment -&gt; Section 的结构组织方式，是因为在同一个 Segment 下的 Section，可以控制相同的权限，也可以不完全按照 Page 的大小进行内存对其，节省内存的空间。而 Segment 对外整体暴露，在程序载入阶段映射成一个完整的虚拟内存，更好的做到内存对齐（可以继续参考 OS X &amp; iOS Kernel Programming 一书的第一章内容)</p>
<p>Section定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include / mach-o / loader.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> </span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];    <span class="comment">/* Section 名字 */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* Section 所在的 Segment 名称 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    addr;        <span class="comment">/* Section 所在的内存地址 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    size;        <span class="comment">/* Section 的大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;        <span class="comment">/* Section 所在的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;        <span class="comment">/* Section 的内存对齐边界 (2 的次幂) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;        <span class="comment">/* 重定位信息的文件偏移 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;        <span class="comment">/* 重定位条目的数目 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* 标志属性 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;    <span class="comment">/* 保留字段1 (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;    <span class="comment">/* 保留字段2 (for count or sizeof) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved3;    <span class="comment">/* 保留字段3 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面列举一些常见的 Section。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Section</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>__TEXT.__text</code></td>
<td style="text-align:center">主程序代码</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__cstring</code></td>
<td style="text-align:center">C 语言字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__const</code></td>
<td style="text-align:center">const 关键字修饰的常量</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__stubs</code></td>
<td style="text-align:center">用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__stubs_helper</code></td>
<td style="text-align:center">当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__objc_methname</code></td>
<td style="text-align:center">Objective-C 方法名称</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__objc_methtype</code></td>
<td style="text-align:center">Objective-C 方法类型</td>
</tr>
<tr>
<td style="text-align:left"><code>__TEXT.__objc_classname</code></td>
<td style="text-align:center">Objective-C 类名称</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__data</code></td>
<td style="text-align:center">初始化过的可变数据</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__la_symbol_ptr</code></td>
<td style="text-align:center">lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__nl_symbol_ptr</code></td>
<td style="text-align:center">非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__const</code></td>
<td style="text-align:center">没有初始化过的常量</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__cfstring</code></td>
<td style="text-align:center">程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__bss</code></td>
<td style="text-align:center">BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__common</code></td>
<td style="text-align:center">没有初始化过的符号声明</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_classlist</code></td>
<td style="text-align:center">Objective-C 类列表</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_protolist</code></td>
<td style="text-align:center">Objective-C 原型</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_imginfo</code></td>
<td style="text-align:center">Objective-C 镜像信息</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_selfrefs</code></td>
<td style="text-align:center">Objective-C self 引用</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_protorefs</code></td>
<td style="text-align:center">Objective-C 原型引用</td>
</tr>
<tr>
<td style="text-align:left"><code>__DATA.__objc_superrefs</code></td>
<td style="text-align:center">Objective-C 超类引用</td>
</tr>
</tbody>
</table>
<p><code>__TEXT.__text</code> 这里存放的是汇编后的代码，当我们进行编译时，每个.m文件会经过预编译-&gt;编译-&gt;汇编形成.o文件，称之为目标文件。汇编后，所有的代码会形成汇编指令存储在.o文件的(<strong>TEXT,</strong>text)区（（<strong>DATA,</strong>data）也是类似）。链接后，所有的.o文件会合并成一个文件，所有.o文件的(<strong>TEXT,</strong>text)数据都会按链接顺序存放到应用文件的(<strong>TEXT,</strong>text)中。</p>
<p><code>__DATA.__data</code> 存储数据的section，static在进行非零赋值后会存储在这里，如果static 变量没有赋值或者赋值为0，那么它会存储在<code>__DATA.__bss</code>中。</p>
<p>另外还有 <code>Symbol Table</code>符号表，这个是重点中的重点，符号表是将地址和符号联系起来的桥梁。符号表并不能直接存储符号，而是存储符号位于字符串表的位置。</p>
<p><code>String Table</code>字符串表所有的变量名、函数名等，都以字符串的形式存储在字符串表中。</p>
<h3 id="实践：关联类的方法名"><a href="#实践：关联类的方法名" class="headerlink" title="实践：关联类的方法名"></a>实践：关联类的方法名</h3><p>上面说了一大堆定义，来查看使用Mach-O文件呢。这里来看一下如何用 MachO 文件关联类的方法名。</p>
<p>先来看看 <code>Load Commands</code>里的表示类名的 <code>__objc_classname</code> :</p>
<p><img src="/res/MachO/macho-find.png" alt></p>
<p>根据 offset字段 <code>0000425F</code> 值可以找到 section中对应的 <code>__TEXT,__objc_classname</code> 信息:</p>
<p><img src="/res/MachO/macho-find2.png" alt></p>
<p>同理可以找到对应方法名的 <code>__objc_methname</code> 和 表示类虚拟地址的 <code>__objc_classlist</code> :</p>
<p><img src="/res/MachO/macho-find3.png" alt></p>
<p>其中我们需要查看类的方法名信息就在<code>__objc_classlist</code>中，根据上图中 <code>_OBJC_CLASS_$_ViewController</code> 对应的data : <code>00000001000060E8</code>,可以在<code>__DATA,__objc_data</code>中找到类结构信息：</p>
<p><img src="/res/MachO/macho-find4.png" alt></p>
<p>其中data 是我们感兴趣的，它指向 class_ro_t， class_ro_t 存储了类在编译器就确定的属性、方法、协议等。根据data的值 <code>0x100005370</code>就找到了<code>__DATA,__objc_const</code>中：</p>
<p><img src="/res/MachO/macho-find5.png" alt></p>
<p>其中baseMethods <code>0x100005350</code> 指向了第一个方法。这样我们就就找到了类的方法名。</p>
<h2 id="使用命令查看Mach-O信息"><a href="#使用命令查看Mach-O信息" class="headerlink" title="使用命令查看Mach-O信息"></a>使用命令查看Mach-O信息</h2><p>上文是借助 MachOView 这个工具 和 <code>loader.h</code> 来了解Mach-O文件的大概定义，现在我们来使用<code>size</code>和<code>otool</code> 查看一下Mach-O文件。</p>
<p>如下这样一个 hello.c文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用clang生成Mach-O文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成 hello.out 的 Mach-O 二进制文件</span></span><br><span class="line">xcrun clang hello.c -o hello.out</span><br></pre></td></tr></table></figure>
<p>可以通过 <code>file</code> 命令来查看简要的架构信息:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file hello.out </span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line">hello.out: Mach-O 64-bit executable x86_64</span><br></pre></td></tr></table></figure>
<h3 id="一、-Section"><a href="#一、-Section" class="headerlink" title="一、 Section"></a>一、 Section</h3><p>就像我们上面提到的一样，这里有些东西叫做 section。一个可执行文件包含多个段，也就是多个 section。可执行文件不同的部分将加载进不同的 section，并且每个 section 会转换进某个 segment 里。这个概念对于所有的可执行文件都是成立的。</p>
<p>我们来看看 hello.out 二进制中的 section。我们可以使用 size 工具来观察</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">size -x -l -m hello.out </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</span><br><span class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</span><br><span class="line">	Section __text: 0x2a (addr 0x100000f60 offset 3936)</span><br><span class="line">	Section __stubs: 0x6 (addr 0x100000f8a offset 3978)</span><br><span class="line">	Section __stub_helper: 0x1a (addr 0x100000f90 offset 3984)</span><br><span class="line">	Section __cstring: 0xd (addr 0x100000faa offset 4010)</span><br><span class="line">	Section __unwind_info: 0x48 (addr 0x100000fb8 offset 4024)</span><br><span class="line">	total 0x9f</span><br><span class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</span><br><span class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</span><br><span class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</span><br><span class="line">	total 0x18</span><br><span class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</span><br><span class="line">total 0x100003000</span><br></pre></td></tr></table></figure>
<p>如上代码所示，我们的 <code>hello.out</code> 文件有 4 个 segment。有些 segment 中有多个 section。</p>
<p>当运行一个可执行文件时，虚拟内存 (VM - virtual memory) 系统将 segment 映射到进程的地址空间上。映射完全不同于我们一般的认识，如果你对虚拟内存系统不熟悉，可以简单的想象虚拟内存系统将整个可执行文件加载进内存 – 虽然在实际上不是这样的。VM 使用了一些技巧来避免全部加载。</p>
<p>当虚拟内存系统进行映射时，segment 和 section 会以不同的参数和权限被映射。</p>
<p>上面的代码中，__TEXT segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</p>
<p>__DATA segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</p>
<p>第一个 segment 是 __PAGEZERO。它的大小为 4GB。这 4GB 并不是文件的真实大小，但是规定了进程地址空间的前 4GB 被映射为 不可执行、不可写和不可读。这就是为什么当读写一个 NULL 指针或更小的值时会得到一个 EXC_BAD_ACCESS 错误。这是操作系统在尝试防止引起系统崩溃。</p>
<p>在 segment中，一般都会有多个 section。它们包含了可执行文件的不同部分。在 <strong>TEXT segment 中，</strong>text section 包含了编译所得到的机器码。<strong>stubs 和 </strong>stub_helper 是给动态链接器 (dyld) 使用的。通过这两个 section，在动态链接代码中，可以允许延迟链接。<strong>const (在我们的代码中没有) 是常量，不可变的，就像 </strong>cstring (包含了可执行文件中的字符串常量 – 在源码中被双引号包含的字符串) 常量一样。</p>
<p><strong>DATA segment 中包含了可读写数据。在我们的程序中只有 </strong>nl_symbol_ptr 和 __la_symbol_ptr，它们分别是 non-lazy 和 lazy 符号指针。延迟符号指针用于可执行文件中调用未定义的函数，例如不包含在可执行文件中的函数，它们将会延迟加载。而针对非延迟符号指针，当可执行文件被加载同时，也会被加载。</p>
<p>在 _DATA segment 中的其它常见 section 包括 <strong>const，在这里面会包含一些需要重定向的常量数据。例如 char * const p = “foo”; – p 指针指向的数据是可变的。</strong>bss section 没有被初始化的静态变量，例如 static int a; – ANSI C 标准规定静态变量必须设置为 0。并且在运行时静态变量的值是可以修改的。<strong>common section 包含未初始化的外部全局变量，跟 static 变量类似。例如在函数外面定义的 int a;。最后，</strong>dyld 是一个 section 占位符，被用于动态链接器。</p>
<h3 id="二、Section-中的内容"><a href="#二、Section-中的内容" class="headerlink" title="二、Section 中的内容"></a>二、Section 中的内容</h3><p>可以通过 <code>otool</code> 来了解section中的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">otool -s  __TEXT __text  hello.out </span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">hello.out:</span><br><span class="line">Contents of (__TEXT,__text) section</span><br><span class="line">0000000100000f60	55 48 89 e5 48 83 ec 10 c7 45 <span class="built_in">fc</span> 00 00 00 00 48 </span><br><span class="line">0000000100000f70	8d 3d 34 00 00 00 b0 00 e8 0d 00 00 00 31 c9 89 </span><br><span class="line">0000000100000f80	45 f8 89 c8 48 83 c4 10 5d c3</span><br></pre></td></tr></table></figure>
<p>我们还可以通过添加 -v 来查看反汇编代码 , 由于 -s <strong>TEXT </strong>text 很常见，otool 对其设置了一个缩写 -t ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">otool -v -t  hello.out</span><br><span class="line"><span class="comment">#输出 </span></span><br><span class="line">hello.out:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line">_main:</span><br><span class="line">0000000100000f60	pushq	%rbp</span><br><span class="line">0000000100000f61	movq	%rsp, %rbp</span><br><span class="line">0000000100000f64	subq	<span class="variable">$0x10</span>, %rsp</span><br><span class="line">0000000100000f68	movl	<span class="variable">$0x0</span>, -0x4(%rbp)</span><br><span class="line">0000000100000f6f	leaq	0x34(%rip), %rdi</span><br><span class="line">0000000100000f76	movb	<span class="variable">$0x0</span>, %al</span><br><span class="line">0000000100000f78	callq	0x100000f8a</span><br><span class="line">0000000100000f7d	xorl	%ecx, %ecx</span><br><span class="line">0000000100000f7f	movl	%eax, -0x8(%rbp)</span><br><span class="line">0000000100000f82	movl	%ecx, %eax</span><br><span class="line">0000000100000f84	addq	<span class="variable">$0x10</span>, %rsp</span><br><span class="line">0000000100000f88	popq	%rbp</span><br><span class="line">0000000100000f89	retq</span><br></pre></td></tr></table></figure>
<p>上面的内容是一样的，只不过以反汇编形式显示出来。你应该感觉很熟悉，这就是我们在前面编译时候的代码。唯一的不同就是，在这里我们没有任何的汇编指令在里面。这是纯粹的二进制执行文件。</p>
<!-- ## 应用

了解Mach-O文件的主要应用之一是代码大小性能优化。


### 可执行文件瘦身

__objc_classlist 和 __objc_classrefs

### 获取调用堆栈 -->]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Mach-O</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O应用 fishhook动态修改C函数</title>
    <url>/essay/LLDB/Mach-O_fishhook/</url>
    <content><![CDATA[<h2 id="fishhook简介"><a href="#fishhook简介" class="headerlink" title="fishhook简介"></a>fishhook简介</h2><p>C 语言往往会给我们留下不可修改的这一印象,而 <a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> 是一个由 facebook 开源的第三方框架，其主要作用就是<strong>动态修改 C 语言函数实现</strong>。</p>
<p>这个框架的代码其实非常的简单，只包含两个文件：fishhook.c 以及 fishhook.h；两个文件所有的代码加起来也不超过 300 行。不过它的实现原理是非常有意思并且精妙的</p>
<p>fishhook 提供非常简单的两个接口以及一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="keyword">void</span> *replacement;</span><br><span class="line">	<span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,<span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们可以从 fishhook 提供的demo中上手实践一下,这里的demo对 <code>close</code> 进行修改:</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"dlfcn.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"fishhook.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个与原函数签名相同的函数指针,用保存原始的函数的地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> (*orig_close)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的close</span></span><br><span class="line"><span class="keyword">int</span> my_close(<span class="keyword">int</span> fd) &#123;</span><br><span class="line">    printf(<span class="string">"做一些额外操作\n"</span>);</span><br><span class="line">    printf(<span class="string">"调用原 close(%d)\n"</span>, fd);</span><br><span class="line">    <span class="comment">//调用的 orig_close 其实相当于执行原 close</span></span><br><span class="line">    <span class="keyword">return</span> orig_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> rebinding closeBind;</span><br><span class="line">        <span class="comment">//函数的名称</span></span><br><span class="line">        closeBind.name = <span class="string">"close"</span>;</span><br><span class="line">        <span class="comment">//新的函数地址</span></span><br><span class="line">        closeBind.replacement = my_close;</span><br><span class="line">        <span class="comment">//保存原始函数地址的变量的指针</span></span><br><span class="line">        closeBind.replaced = (<span class="keyword">void</span> *)&amp;orig_close;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        <span class="keyword">struct</span> rebinding rebs[] = &#123;closeBind&#125;;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         对符号进行重绑定 arg1 : 存放rebinding结构体的数组 arg2 : 数组的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rebind_symbols(rebs, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始测试:</span></span><br><span class="line">        <span class="keyword">int</span> fd = open(argv[<span class="number">0</span>], O_RDONLY);</span><br><span class="line">        uint32_t magic_number = <span class="number">0</span>;</span><br><span class="line">        read(fd, &amp;magic_number, <span class="number">4</span>);</span><br><span class="line">        printf(<span class="string">"Mach-O Magic Number: %x \n"</span>, magic_number);</span><br><span class="line">        close(fd);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后查看输出的信息可以看到 在对符号进行重绑定之后，所有调用 <code>close</code> 函数的地方实际上都会执行 <code>my_close</code> 的实现，也就完成了对 <code>close</code> 的修改。</p>
<p>那么 fishhook 是如何做到的呢？</p>
<h2 id="fishhook-原理"><a href="#fishhook-原理" class="headerlink" title="fishhook 原理"></a>fishhook 原理</h2><p>fishhook 是 FaceBook 开源的可以动态修改 MachO 符号表的工具。fishhook 的强大之处在于它可以 HOOK 系统的静态 C 函数。</p>
<p>大家都知道 OC 的方法之所以可以 HOOK 是因为它的运行时特性，OC 的方法调用在底层都是 msg_send（id,SEL）的形式，这为我们提供了交换方法实现（IMP）的机会，但 C 函数在编译链接时就确定了函数指针的地址偏移量（Offset），这个偏移量在编译好的可执行文件中是固定的。既然 C 函数的指针地址是相对固定且不可修改的，那么 fishhook 又是怎么实现 对 C 函数的 HOOK 呢？<strong>其实内部/自定义的 C 函数 fishhook 也 HOOK 不了，它只能HOOK Mach-O 外部（共享缓存库中）的函数</strong>。</p>
<p>现在先来看一下以下这几个知识点:</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接就是负责将各种各样程序需要的镜像加载到程序运行的内存空间中，这个过程发生的时间非常早： <em>在 objc 运行时初始化之前</em> 。</p>
<p>先来看一个简单的demo为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// helloFishhook.m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如我们在 <a href="/essay/LLDB/iOS_Compiler/">iOS编译过程</a> 中实践的一样 ，先用clang编译一下，再用<code>nm</code>命令查看符号:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#clang helloFishhook.m</span></span><br><span class="line"><span class="comment">#nm -nm a.out </span></span><br><span class="line">                 (undefined) external _printf (from libSystem)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000f30 (__TEXT,__text) external _hello_world</span><br><span class="line">0000000100000f50 (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure>
<p>可以看到自己写的方法 <code>_hello_world</code> ,它包含一个内存地址以及 __TEXT 段。也就是说手写的一些函数，在编译之后，其地址并不是未定义的</p>
<p>与之对比的是看到 <code>_printf</code> 这个符号是未定义的(undefined),<code>dyld_stub_binder</code> 会在目标符号（例如 printf）被调用时，将其链接到指定的动态链接库 libSystem，再执行 printf 的实现</p>
<p>每一个镜像中的 <strong>DATA 端都包含两个与动态链接有关的表，其中一个是 </strong>nl_symbol_ptr，另一个是 <code>__la_symbol_ptr</code>：</p>
<ul>
<li><code>__nl_symbol_ptr</code> 中的 non-lazy 符号是在动态链接库绑定的时候进行加载的</li>
<li><code>__la_symbol_ptr</code> 中的符号会在该符号被第一次调用时，通过 dyld 中的 dyld_stub_binder 过程来进行加载</li>
</ul>
<p>了解这两点的区别，你也大概可以猜出 fishhook 为什么能替换原C函数了。</p>
<h3 id="PIC（Position-independent-code"><a href="#PIC（Position-independent-code" class="headerlink" title="PIC（Position-independent code)"></a>PIC（Position-independent code)</h3><p>为什么 printf 是未定义的？</p>
<p>ASLR技术：是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度。对于我们APP而言，它保证每次MachO文件加载的时候是随机地址  <strong>这个我们可以通过LLDB指令的image list去查看</strong></p>
<p>苹果采用了PIC（Position-independent code）技术成功让 C 的底层也能有动态的表现：</p>
<ul>
<li>编译时在 Mach-O 文件 _DATA 段的符号表中为每一个被引用的系统 C 函数建立一个指针（8字节的数据，放的全是0），这个指针用于动态绑定时重定位到共享库中的函数实现。</li>
<li>在运行时当系统 C 函数被第一次调用时会动态绑定一次，然后将 Mach-O 中的 _DATA 段符号表中对应的指针，指向外部函数（其在共享库中的实际内存地址）。</li>
</ul>
<p>fishhook 正是利用了 PIC 技术做了这么两个操作：</p>
<ul>
<li>将指向系统方法（外部函数）的指针重新进行绑定指向内部函数/自定义 C 函数。</li>
<li>将内部函数的指针在动态链接时指向系统方法的地址。</li>
</ul>
<p>这样就把系统方法与自己定义的方法进行了交换，达到 HOOK 系统 C 函数（共享库中的）的目的。</p>
<h3 id="dyld-加载回调"><a href="#dyld-加载回调" class="headerlink" title="dyld 加载回调"></a>dyld 加载回调</h3><p>在 dyld 加载镜像时，会执行注册过的回调函数; 对于每一个已经存在的镜像，当它被动态链接时，都会执行回调 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*func)(<span class="keyword">const</span> struct mach_header* mh, <span class="keyword">intptr_t</span> vmaddr_slide)</span><br></pre></td></tr></table></figure>
<p>传入文件的 <code>mach_header</code> 以及一个虚拟内存地址 <code>intptr_t</code>。</p>
<p>dyld 通过更新 Mach-O 二进制文件 __DATA 段中的一些指针来绑定 lazy 和 non-lazy 的符号；</p>
<p>而 fishhook 先确定某一个符号在 __DATA 段中的位置，<strong>然后保存原符号对应的函数指针，并使用新的函数指针覆盖原有符号的函数指针，实现重绑定。</strong></p>
<h2 id="fishhook-是如何根据字符串找到对应指针在符号表中的偏移值的"><a href="#fishhook-是如何根据字符串找到对应指针在符号表中的偏移值的" class="headerlink" title="fishhook 是如何根据字符串找到对应指针在符号表中的偏移值的"></a>fishhook 是如何根据字符串找到对应指针在符号表中的偏移值的</h2><p>直接上fishhook 的 README 中的流程图：</p>
<p><img src="/res/MachO/fishhook1.png" width="60%"></p>
<p>这张图初看很复杂，不过它演示的是寻找符号的过程，我们根据这张图来分析一下这个过程：</p>
<ol>
<li>从 __DATA 段中的 lazy 符号指针表中查找某个符号，获得这个符号的偏移量 1061，然后在每一个 section_64 中查找 reserved1，通过这两个值找到 Indirect Symbol Table 中符号对应的条目</li>
<li>在 Indirect Symbol Table 找到符号表指针以及对应的索引 16343 之后，就需要访问符号表</li>
<li>然后通过符号表中的偏移量，获取字符串表中的符号 <code>_close</code></li>
</ol>
<p>图示中，1061 是间接符号表的偏移量，*（偏移量+间接符号地址）=16343，即符号表偏移量。符号表中每一个结构都是一个 nlist 结构体，其中包含字符表偏移量。通过字符表偏移量最终确定函数指针。</p>
<p>fishhook 就是对间接符号表的偏移量动的手脚，提供一个假的 nlist 结构体，从而达到 hook 的目的。</p>
<p>上面的流程图其实已经显示的很清楚了，这里我们重新来走一遍，一步步找到其在 MachO 文件里对应指针的偏移值，大致步骤如下：</p>
<p><strong>1.在 String Table 中找到该字符串在 Symbols Table -&gt; Symbols 中的位置：</strong></p>
<p><img src="/res/MachO/fishhook2.png" alt></p>
<p>用 0x9832 - 0x9780 = 0xB2</p>
<p><strong>2.在 Symbols Table -&gt; Symbols 中找到Data = 0xB2 的符号，其对应的 offset 值 0x16F 就是该符号在 Dynamic Symbols Table -&gt; Indirect Symbols 表中的 Data 值</strong></p>
<p><img src="/res/MachO/fishhook3.png" alt></p>
<p><strong>3.在 Dynamic Symbols Table -&gt; Indirect Symbols 表中找到 Data 值为 0x16F 的符号，其位于该表中的位置（第一个）就是它在懒加载表中对应的位置。</strong></p>
<p><img src="/res/MachO/fishhook4.png" alt></p>
<p><strong>4.懒加载表中对应位置的 Offset 值就是该指针最终的偏移量：</strong></p>
<p><img src="/res/MachO/fishhook5.png" alt></p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>fishhook</tag>
      </tags>
  </entry>
  <entry>
    <title>fishhook源码学习</title>
    <url>/essay/LLDB/fishhook_code_analyze/</url>
    <content><![CDATA[<p>上一篇 <a href="/essay/LLDB/Mach-O_fishhook/">Mach-O应用 fishhook动态修改C函数</a> 了解了fishhook的原理，现在来看一下它的代码，看它是如何一步一步替换原有函数实现的。</p>
<a id="more"></a>
<p>我们再来看看rebind_symbols这个对外的接口，其中应用到的C函数作用如下：</p>
<ul>
<li><code>_dyld_image_count(void)</code> 当前dyld装载的image数量</li>
<li><code>_dyld_get_image_header(unit32_t image_index)</code> 返回image对应的Mach Header地址</li>
<li><code>_dyld_get_image_vmaddr_slide(unit32_t image_index)</code> 虚拟内存中的地址偏移量</li>
</ul>
<p>对实现的分析会 rebind_symbols 函数为入口，首先看一下函数的调用栈：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br><span class="line">└── <span class="keyword">extern</span> <span class="keyword">void</span> _dyld_register_func_for_add_image(<span class="keyword">void</span> (*func)(<span class="keyword">const</span> struct mach_header* mh, <span class="keyword">intptr_t</span> vmaddr_slide));</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span><br><span class="line">└── <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span></span></span><br><span class="line">	└── static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, intptr_t slide, nlist_t *symtab, char *strtab, uint32_t *indirect_symtab)</span><br></pre></td></tr></table></figure>
<p>其实函数调用栈非常简单，因为整个库中也没有几个函数，rebind_symbols 作为接口，其主要作用就是注册一个函数并在镜像加载时回调：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">		_dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">			_rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 rebind_symbols 最开始执行时，会先调用一个 prepend_rebindings 的函数，将整个 rebindings 数组添加到 _rebindings_head 这个私有数据结构的头部：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(struct rebindings_entry **rebindings_head,</span></span></span><br><span class="line"><span class="function"><span class="params">							  struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">							  <span class="keyword">size_t</span> nel)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">new_entry</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rebindings_entry</span>));</span></span><br><span class="line">	<span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	new_entry-&gt;rebindings = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line">	<span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">		<span class="built_in">free</span>(new_entry);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line">	new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">	new_entry-&gt;next = *rebindings_head;</span><br><span class="line">	*rebindings_head = new_entry;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说每次调用的 rebind_symbols 方法传入的 rebindings 数组以及数组的长度都会以 rebindings_entry 的形式添加到 _rebindings_head 这个私有链表的首部：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *_<span class="title">rebindings_head</span>;</span></span><br></pre></td></tr></table></figure>
<p>这样可以通过判断 _rebindings_head-&gt;next 的值来判断是否为第一次调用，然后使用 _dyld_register_func_for_add_image 将 _rebind_symbols_for_image 注册为回调或者为所有存在的镜像单独调用 _rebind_symbols_for_image：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">	rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_rebind_symbols_for_image 只是对另一个名字非常相似的函数 rebind_symbols_for_image 的封装，从这个函数开始，就到了重绑定符号的过程；不过由于这个方法的实现比较长，具体分析会分成三个部分并省略一些不影响理解的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">									 <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">									 <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">	<span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">		cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">		<span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">				linkedit_segment = cur_seg_cmd;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">			symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">			dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的代码主要功能是从镜像中查找 linkedit_segment symtab_command 和 dysymtab_command；在开始查找之前，要先跳过 mach_header_t 长度的位置，然后将当前指针强转成 segment_command_t，通过对比 cmd 的值，来找到需要的 segment_command_t。</p>
<p>在查找了几个关键的 segment 之后，我们可以根据几个 segment 获取对应表的内存地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">const</span> struct mach_header *header, <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">	<span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">	<span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 linkedit_segment 结构体中获得其虚拟地址以及文件偏移量，然后通过一下公式来计算当前 __LINKEDIT 段的位置：</p>
<p><code>slide + vmaffr - fileoff</code></p>
<p>类似地，在 symtab_command 中获取符号表偏移量和字符串表偏移量，从 dysymtab_command 中获取间接符号表（indirect symbol table）偏移量，就能够获得<em>符号表</em>、<em>字符串表</em>以及<em>间接符号表</em>的引用了。</p>
<ul>
<li>间接符号表中的元素都是 uint32_t *，指针的值是对应条目 n_list 在符号表中的位置</li>
<li><p>符号表中的元素都是 nlist_t 结构体，其中包含了当前符号在字符串表中的下标</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">    	<span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">	&#125; n_un;</span><br><span class="line">	<span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">	<span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">	<span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串表中的元素是 char 字符</p>
</li>
</ul>
<p>该函数的最后一部分就开启了遍历模式，查找整个镜像中的 SECTION_TYPE 为 S_LAZY_SYMBOL_POINTERS 或者 S_NON_LAZY_SYMBOL_POINTERS 的 section，然后调用下一个函数 perform_rebinding_with_section 来对 section 中的符号进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings, <span class="keyword">section_t</span> *section, <span class="keyword">intptr_t</span> slide, <span class="keyword">nlist_t</span> *symtab, <span class="keyword">char</span> *strtab, <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">	<span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">	<span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">		<span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">		<span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">		<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">			<span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">						indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">						*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">					&#125;</span><br><span class="line">					indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">					<span class="keyword">goto</span> symbol_loop;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	symbol_loop:;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的实现的核心内容就是将符号表中的 symbol_name 与 rebinding 中的名字 name 进行比较，如果出现了匹配，就会将原函数的实现传入 origian_open 函数指针的地址，并使用新的函数实现 new_open 代替原实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">	indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">	*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; <span class="comment">// 将原函数的实现传入 original_open 函数指针的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; // 使用新的函数实现 new_open 替换原实现<br>如果你理解了上面的实现代码，该函数的其它代码就很好理解了：</p>
<ol>
<li>通过 indirect_symtab + section-&gt;reserved1 获取 indirect_symbol_indices *，也就是符号表的数组</li>
<li>通过 (void **)((uintptr_t)slide + section-&gt;addr) 获取函数指针列表 indirect_symbol_bindings</li>
<li>遍历符号表数组 indirect_symbol_indices * 中的所有符号表中，获取其中的符号表索引 symtab_index</li>
<li>通过符号表索引 symtab_index 获取符号表中某一个 n_list 结构体，得到字符串表中的索引 symtab[symtab_index].n_un.n_strx</li>
<li>最后在字符串表中获得符号的名字 char *symbol_name</li>
</ol>
<p>到这里比较前的准备工作就完成了，剩下的代码会遍历整个 rebindings_entry 数组，在其中查找匹配的符号，完成函数实现的替换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line">	<span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">				indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">				*(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">			&#125;</span><br><span class="line">			indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">			<span class="keyword">goto</span> symbol_loop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之后对某一函数的调用（例如 open），当查找其函数实现时，都会查找到 new_open 的函数指针；在 new_open 调用 origianl_open 时，同样也会执行原有的函数实现，因为我们通过 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i] 将原函数实现绑定到了新的函数指针上。</p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>fishhook</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS编译过程</title>
    <url>/essay/LLDB/iOS_Compiler/</url>
    <content><![CDATA[<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><blockquote>
<p>把一种编程语言(原始语言)转换为另一种编程语言(目标语言)的程序叫做编译器</p>
</blockquote>
<p>大多数编译器由两部分组成：前端和后端。</p>
<ul>
<li>前端负责词法分析，语法分析，生成中间代码；</li>
<li>后端以中间代码作为输入，进行行架构无关的代码优化，接着针对不同架构生成不同的机器码。</li>
</ul>
<p>Objective C/C/C++使用的编译器前端是clang，swift是swift，后端都是LLVM。</p>
<h3 id="llvm介绍"><a href="#llvm介绍" class="headerlink" title="llvm介绍"></a>llvm介绍</h3><p>LLVM是什么，是low level virtual machine的简称，其实是一个编译器框架。LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。编译器前端主要进行语法分析，语义分析，生成中间代码。编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化，根据不同的系统架构生成不同的机器码。</p>
<p><img src="/res/LLVM/LLVMCompiler1.png" alt></p>
<p>现在，Xcode 的默认编译器是 clang。本文中我们提到的编译器都表示 clang。clang 的功能是首先对 Objective-C 代码做分析检查，然后将其转换为低级的类汇编代码：LLVM Intermediate Representation(LLVM 中间表达码)。接着 LLVM 会执行相关指令将 LLVM IR 编译成目标平台上的本地字节码，这个过程的完成方式可以是即时编译 (Just-in-time)，或在编译的时候完成。而Clang 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。Clang项目包括Clang前端和Clang静态分析器等。</p>
<p>下图是iOS编译过程：<br><img src="/res/LLVM/iOSCompiler.png" alt></p>
<a id="more"></a>
<h2 id="使用llvm命令"><a href="#使用llvm命令" class="headerlink" title="使用llvm命令"></a>使用llvm命令</h2><p><strong><em>一、使用xcode自带</em></strong></p>
<p>使用xcrun来调用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xcrun clang -v</span><br><span class="line"><span class="comment">#Apple LLVM version 10.0.0 (clang-1000.11.45.5)</span></span><br><span class="line"><span class="comment">#Target: x86_64-apple-darwin17.7.0</span></span><br><span class="line"><span class="comment">#Thread model: posix</span></span><br><span class="line"><span class="comment">#InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin</span></span><br></pre></td></tr></table></figure>
<p><strong><em>二、使用HomeBrew安装</em></strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.使用以下命令安装llvm</span></span><br><span class="line">brew install --with-toolchain llvm</span><br><span class="line"><span class="comment"># 若安装遇到问题 可以先升级brew试试</span></span><br><span class="line"><span class="comment">#   brew update 这会更新 Homebrew 自己</span></span><br><span class="line"><span class="comment">#   brew upgrade 升级所有可以升级的软件们</span></span><br></pre></td></tr></table></figure>
<p>安装后可以使用 <code>brew info llvm</code> 检查信息。brew安装llvm后，不会直接添加命令的快捷引用，需要自己手动来完成。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看llvm的安装路径</span></span><br><span class="line">brew --prefix llvm</span><br><span class="line"><span class="comment"># 添加引用示例：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/llvm/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<!-- https://embeddedartistry.com/blog/2017/2/20/installing-clangllvm-on-osx -->
<p>这样之后就可以直接调用自己安装的llvm了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">clang -v</span><br><span class="line"><span class="comment">#clang version 8.0.0 (tags/RELEASE_800/final)</span></span><br><span class="line"><span class="comment">#Target: x86_64-apple-darwin17.7.0</span></span><br><span class="line"><span class="comment">#Thread model: posix</span></span><br><span class="line"><span class="comment">#InstalledDir: /usr/local/opt/llvm/bin</span></span><br></pre></td></tr></table></figure>
<h2 id="编译器处理过程"><a href="#编译器处理过程" class="headerlink" title="编译器处理过程"></a>编译器处理过程</h2><p>在编译一个源文件时，编译器的处理过程分为几个阶段。要想查看编译 hello.m 源文件需要几个不同的阶段，上文中安装llvm后，我们可以让通过 clang 命令观察：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sunTongShengdeMacBook-Pro:asdasd suntongsheng$ clang -ccc-print-phases ViewController.m</span><br><span class="line">0: input, &quot;ViewController.m&quot;, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</span><br></pre></td></tr></table></figure>
<p>可以看到clang将其分为 input、preprocessor 、compiler、backend、assembler、linker、bind-arch几个阶段。</p>
<ul>
<li>预处理阶段：符号化、宏定义展开头文件展开</li>
<li>语法和语义分析阶段：将符号化后的内容转化为一棵解析树、解析树做语义分析 输出一棵抽象语法树</li>
<li>生成代码和优化阶段：将 AST 转换为更低级的中间码 (LLVM IR)、对生成的中间码做优化、生成特定目标代码、输出汇编代码</li>
<li>汇编器阶段：将汇编代码转换为目标对象文件。</li>
<li>链接器：将多个目标对象文件合并为一个可执行文件 (或者一个动态库)</li>
</ul>
<h3 id="preprocessor-预处理"><a href="#preprocessor-预处理" class="headerlink" title="preprocessor 预处理"></a>preprocessor 预处理</h3><p>每当编源译文件的时候，编译器首先做的是一些预处理工作。具体表现为import头文件替换、macro宏展开、其他预编译指令，`#这个符号是编译器预处理的标志。</p>
<p><strong><em>一. 对头文件的处理：</em></strong></p>
<p>例如，如果在源文件中出现下述代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也使用了类似的宏引入，则会按照同样的处理方式用各个宏对应的真正代码进行逐级替代。这也就是为什么人们主张头文件最好尽量少的去引入其他的类或库，因为引入的东西越多，编译器需要做的处理就越多</p>
<p><strong>示例</strong>：假设我们写了一个简单的 C 程序 hello.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello llvm\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后给上面的代码执行以下预处理命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  -E  Only run the preprocessor</span></span><br><span class="line">clang -E hello.c &gt;&gt; hello.o</span><br></pre></td></tr></table></figure>
<p>打开 hello.o ，发现有542行。但是如果在上述代码上加上 <code>#import &lt;Foundation/Foundation.h&gt;</code> ，hello.o 的行数暴增到9万多行。（当然对于这种情况引入了<a href="http://clang.llvm.org/docs/Modules.html" target="_blank" rel="noopener">模块 - modules</a>功能）</p>
<p>打开模块功能再试试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-fmodules 允许modules的语言特性</span></span><br><span class="line">clang  -fmodules -E  hello.c &gt;&gt; hello.1o</span><br><span class="line"></span><br><span class="line"><span class="comment">#hello.1o的内容：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 "hello.c"</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 1</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 3</span></span><br><span class="line"><span class="comment"># 361 "&lt;built-in&gt;" 3</span></span><br><span class="line"><span class="comment"># 1 "&lt;command line&gt;" 1</span></span><br><span class="line"><span class="comment"># 1 "&lt;built-in&gt;" 2</span></span><br><span class="line"><span class="comment"># 1 "hello.c" 2</span></span><br><span class="line"><span class="comment">#pragma clang module import Darwin.C.stdio /* clang -E: implicit import for #include &lt;stdio.h&gt; */</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello llvm\n"</span>);</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>二、对于宏的处理</em></strong></p>
<p>假设一段这样的代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"largest: %d\n"</span>, MAX(i++,<span class="number">100</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i: %d\n"</span>, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 <code>clang -E hello.c</code> 进行宏展开的预处理结果是如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"largest: %d\n"</span>, i++ &gt; <span class="number">100</span> ? i++ : <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i: %d\n"</span>, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>i++</code>被替换到了<code>a</code>中，而不是预想的 i++的值。</p>
<h3 id="compiler-词法分析解析标记"><a href="#compiler-词法分析解析标记" class="headerlink" title="compiler 词法分析解析标记"></a>compiler 词法分析解析标记</h3><h4 id="一、词法分析-Lexical-Analysis"><a href="#一、词法分析-Lexical-Analysis" class="headerlink" title="一、词法分析-Lexical Analysis"></a>一、词法分析-Lexical Analysis</h4><p>在compiler阶段，首先代码文本都会从 string 转化成特殊的标记流。将代码切成一个个 token，比如大小括号，等于号还有字符串等。是计算机科学中将字符序列转换为标记序列的过程。 例如，下面这段程序：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"hello, %@"</span>, <span class="string">@"world"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 clang 命令 clang -Xclang -dump-tokens hello.m 来将上面代码的标记流导出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#clang -Xclang -dump-tokens hello.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出：</span></span><br><span class="line">int <span class="string">'int'</span>	 [StartOfLine]	Loc=&lt;hello.c:1:1&gt;</span><br><span class="line">identifier <span class="string">'main'</span>	 [LeadingSpace]	Loc=&lt;hello.c:1:5&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;hello.c:1:9&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;hello.c:1:10&gt;</span><br><span class="line">l_brace <span class="string">'&#123;'</span>	 [LeadingSpace]	Loc=&lt;hello.c:1:12&gt;</span><br><span class="line">identifier <span class="string">'NSLog'</span>	 [StartOfLine] [LeadingSpace]	Loc=&lt;hello.c:2:3&gt;</span><br><span class="line">l_paren <span class="string">'('</span>		Loc=&lt;hello.c:2:8&gt;</span><br><span class="line">unknown <span class="string">'@'</span>		Loc=&lt;hello.c:2:9&gt;</span><br><span class="line">string_literal <span class="string">'"hello, %@"'</span>		Loc=&lt;hello.c:2:10&gt;</span><br><span class="line">comma <span class="string">','</span>		Loc=&lt;hello.c:2:21&gt;</span><br><span class="line">unknown <span class="string">'@'</span>	 [LeadingSpace]	Loc=&lt;hello.c:2:23&gt;</span><br><span class="line">string_literal <span class="string">'"world"'</span>		Loc=&lt;hello.c:2:24&gt;</span><br><span class="line">r_paren <span class="string">')'</span>		Loc=&lt;hello.c:2:31&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;hello.c:2:32&gt;</span><br><span class="line"><span class="built_in">return</span> <span class="string">'return'</span>	 [StartOfLine] [LeadingSpace]	Loc=&lt;hello.c:3:3&gt;</span><br><span class="line">numeric_constant <span class="string">'0'</span>	 [LeadingSpace]	Loc=&lt;hello.c:3:10&gt;</span><br><span class="line">semi <span class="string">';'</span>		Loc=&lt;hello.c:3:11&gt;</span><br><span class="line">r_brace <span class="string">'&#125;'</span>	 [StartOfLine]	Loc=&lt;hello.c:4:1&gt;</span><br><span class="line">eof <span class="string">''</span>		Loc=&lt;hello.c:4:2&gt;</span><br></pre></td></tr></table></figure>
<p>每一个标记都包含了对应的源码内容和其在源码中的位置,如果编译过程中遇到什么问题，clang 能够在源码中指出出错的具体位置。</p>
<h4 id="二、语法分析-Semantic-Analysis"><a href="#二、语法分析-Semantic-Analysis" class="headerlink" title="二、语法分析 - Semantic Analysis"></a>二、语法分析 - Semantic Analysis</h4><p>之后上面的标记流会解析生成<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">抽象语法树</a>，我们可以使用 <code>clang -Xclang -ast-dump -fsyntax-only hello.c</code> 来展现解析这个过程</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clang -Xclang -ast-dump -fsyntax-only hello.c </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出：</span></span><br><span class="line">hello.c:2:3: warning: implicit declaration of <span class="keyword">function</span> <span class="string">'NSLog'</span> is invalid <span class="keyword">in</span> C99 [-Wimplicit-function-declaration]</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">  ^</span><br><span class="line">hello.c:2:9: error: expected expression</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">        ^</span><br><span class="line">hello.c:2:23: error: expected expression</span><br><span class="line">  NSLog(@<span class="string">"hello, %@"</span>, @<span class="string">"world"</span>);</span><br><span class="line">                      ^</span><br><span class="line">TranslationUnitDecl 0x7fe1d2816c08 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</span><br><span class="line">|-TypedefDecl 0x7fe1d28174a0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t <span class="string">'__int128'</span></span><br><span class="line">| `-BuiltinType 0x7fe1d28171a0 <span class="string">'__int128'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817508 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t <span class="string">'unsigned __int128'</span></span><br><span class="line">| `-BuiltinType 0x7fe1d28171c0 <span class="string">'unsigned __int128'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d28177b8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString <span class="string">'struct __NSConstantString_tag'</span></span><br><span class="line">| `-RecordType 0x7fe1d28175d0 <span class="string">'struct __NSConstantString_tag'</span></span><br><span class="line">|   `-Record 0x7fe1d2817558 <span class="string">'__NSConstantString_tag'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817850 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list <span class="string">'char *'</span></span><br><span class="line">| `-PointerType 0x7fe1d2817810 <span class="string">'char *'</span></span><br><span class="line">|   `-BuiltinType 0x7fe1d2816ca0 <span class="string">'char'</span></span><br><span class="line">|-TypedefDecl 0x7fe1d2817af8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list <span class="string">'struct __va_list_tag [1]'</span></span><br><span class="line">| `-ConstantArrayType 0x7fe1d2817aa0 <span class="string">'struct __va_list_tag [1]'</span> 1 </span><br><span class="line">|   `-RecordType 0x7fe1d2817920 <span class="string">'struct __va_list_tag'</span></span><br><span class="line">|     `-Record 0x7fe1d28178a0 <span class="string">'__va_list_tag'</span></span><br><span class="line">`-FunctionDecl 0x7fe1d285d000 &lt;hello.c:1:1, line:4:1&gt; line:1:5 main <span class="string">'int ()'</span></span><br><span class="line">  `-CompoundStmt 0x7fe1d285d1f8 &lt;col:12, line:4:1&gt;</span><br><span class="line">    `-ReturnStmt 0x7fe1d285d1e8 &lt;line:3:3, col:10&gt;</span><br><span class="line">      `-IntegerLiteral 0x7fe1d285d1c8 &lt;col:10&gt; <span class="string">'int'</span> 0</span><br></pre></td></tr></table></figure>
<p>在抽象语法树中的每个节点都标注了其对应源码中的位置，同样的，如果产生了什么问题，clang 可以定位到问题所在处的源码位置。</p>
<h4 id="三、静态分析-Static-Analyzer"><a href="#三、静态分析-Static-Analyzer" class="headerlink" title="三、静态分析 - Static Analyzer"></a>三、静态分析 - Static Analyzer</h4><p>一旦编译器把源码生成了抽象语法树，编译器可以对这棵树做分析处理，以找出代码中的错误，比如类型检查：即检查程序中是否有类型错误。例如：如果代码中给某个对象发送了一个消息，编译器会检查这个对象是否实现了这个消息（函数、方法）。此外，clang 对整个程序还做了其它更高级的一些分析，以确保程序没有错误。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令行执行 通过clang -cc1 -analyzer-checker-help可以列出能调用的 checker，但这些checker并不是所有都是默认开启的</span></span><br><span class="line">clang -cc1 -analyzer-checker-help</span><br><span class="line">OVERVIEW: Clang Static Analyzer Checkers List</span><br><span class="line"></span><br><span class="line">USAGE: -analyzer-checker &lt;CHECKER or PACKAGE,...&gt;</span><br><span class="line"></span><br><span class="line">CHECKERS:</span><br><span class="line">  alpha.clone.CloneChecker        Reports similar pieces of code.</span><br><span class="line">  alpha.core.BoolAssignment       Warn about assigning non-&#123;0,1&#125; values to Boolean variables</span><br><span class="line">  alpha.core.CallAndMessageUnInitRefArg</span><br><span class="line">                                  Check <span class="keyword">for</span> logical errors <span class="keyword">for</span> <span class="keyword">function</span> calls and Objective-C message expressions (e.g., uninitialized arguments, null <span class="keyword">function</span> pointers, and pointer to undefined variables)</span><br><span class="line">  alpha.core.CastSize             Check when castin</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>使用<a href="http://clang-analyzer.llvm.org.cn/scan-build.html" target="_blank" rel="noopener">scan-build</a>可以从命令行运行分析器,类似如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scan-build xcodebuild -project asdasd.xcodeproj</span><br><span class="line">scan-build: Using <span class="string">'/usr/local/Cellar/llvm/8.0.0/bin/clang-8'</span> <span class="keyword">for</span> static analysis</span><br><span class="line">Build settings from <span class="built_in">command</span> line:</span><br><span class="line">    CLANG_ANALYZER_EXEC = /usr/<span class="built_in">local</span>/Cellar/llvm/8.0.0/bin/clang-8</span><br><span class="line">    CLANG_ANALYZER_OTHER_FLAGS = </span><br><span class="line">    CLANG_ANALYZER_OUTPUT = plist-html</span><br><span class="line">    CLANG_ANALYZER_OUTPUT_DIR = /var/folders/s6/5jq8fd4x12v9blzt68qbv18m0000gn/T/scan-build-2019-04-18-141047-45509-1</span><br><span class="line">    RUN_CLANG_STATIC_ANALYZER = YES</span><br><span class="line"></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">note: Constructing build description</span><br><span class="line">Build system information</span><br><span class="line">error: Signing <span class="keyword">for</span> <span class="string">"asdasd"</span> requires a development team. Select a development team <span class="keyword">in</span> the project editor. (<span class="keyword">in</span> target <span class="string">'asdasd'</span>)</span><br><span class="line"></span><br><span class="line">** BUILD FAILED **</span><br><span class="line"></span><br><span class="line">scan-build: Removing directory <span class="string">'/var/folders/s6/5jq8fd4x12v9blzt68qbv18m0000gn/T/scan-build-2019-04-18-141047-45509-1'</span> because it contains no reports.</span><br><span class="line">scan-build: No bugs found.</span><br></pre></td></tr></table></figure>
<p>关于静态分析更多可以查看 ：<a href="http://clang-analyzer.llvm.org.cn/" target="_blank" rel="noopener">Clang 静态分析器</a></p>
<!-- https://juejin.im/post/5a30ea0ff265da43094526f9 -->
<h3 id="生成代码和优化阶段"><a href="#生成代码和优化阶段" class="headerlink" title="生成代码和优化阶段"></a>生成代码和优化阶段</h3><p><strong><em>一、生成 LLVM 代码</em></strong></p>
<p>clang 完成代码的标记，解析和分析后，接着就会生成 LLVM 代码。下面继续看看hello.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把这段代码编译成 LLVM 字节码（绝大多数情况下是二进制码格式），我们可以执行下面的命令：</p>
<p><code>clang  -emit-llvm hello.c -c -o hello.bc</code></p>
<p>接着用另一个命令来查看刚刚生成的二进制文件：</p>
<p><code>llvm-dis &lt; hello.bc | less</code></p>
<p>部分输出如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; ModuleID = '&lt;stdin&gt;'</span><br><span class="line">source_filename = <span class="string">"hello.c"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:o-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"x86_64-apple-macosx10.13.0"</span></span><br><span class="line"></span><br><span class="line">@.str = <span class="keyword">private</span> unnamed_addr constant [<span class="number">13</span> x i8] c<span class="string">"hello world\0A\00"</span>, align <span class="number">1</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone ssp uwtable</span><br><span class="line">define i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = call i32 (i8*, ...) @<span class="built_in">printf</span>(i8* getelementptr inbounds ([<span class="number">13</span> x i8], [<span class="number">13</span> x i8]* @.str, i32 <span class="number">0</span>, i32 <span class="number">0</span>))</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...) #<span class="number">1</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong><em>二、优化 LLVM 代码</em></strong></p>
<p>LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，Pass就是LLVM系统转化和优化的工作的一个节点，每个节点做一些工作，这些工作加起来就构成了LLVM整个系统的优化和转化。官方有比较完整的 Pass 教程： <a href="https://releases.llvm.org/5.0.2/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">Writing an LLVM Pass — LLVM 5 documentation</a> 。如果开启了 bitcode 苹果会做进一步的优化</p>
<p><img src="/res/LLVM/xcode-optimize.png" alt></p>
<p><strong><em>三、输出汇编代码</em></strong></p>
<p>我们可以使用下面的命令让clang输出汇编代码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输入</span></span><br><span class="line"> clang -S -o - hello.c</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#输出</span></span><br><span class="line">	.section	__TEXT,__text,regular,pure_instructions <span class="comment"># .section 指令指定接下来会执行哪一个段</span></span><br><span class="line">	.macosx_version_min 10, 13</span><br><span class="line">	.globl	_main           <span class="comment"># .globl 指令说明 _main 是一个外部符号</span></span><br><span class="line">	.p2align	4, 0x90     <span class="comment"># .align 指令指出了后面代码的对齐方式 如果需要的话，用 0x90 补齐</span></span><br><span class="line">_main:                                  <span class="comment">## 接下来是 main 函数的头部：</span></span><br><span class="line">	.cfi_startproc          <span class="comment"># .cfi_startproc 指令通常用于函数的开始处</span></span><br><span class="line"><span class="comment">## %bb.0:</span></span><br><span class="line">	pushq	%rbp    <span class="comment"># rbp 寄存器 (基础指针寄存器 base pointer register)</span></span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset %rbp, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register %rbp</span><br><span class="line">	subq	<span class="variable">$16</span>, %rsp</span><br><span class="line">	movl	<span class="variable">$0</span>, -4(%rbp)</span><br><span class="line">	leaq	L_.str(%rip), %rdi</span><br><span class="line">	movb	<span class="variable">$0</span>, %al</span><br><span class="line">	callq	_printf <span class="comment">#调用了 printf</span></span><br><span class="line">	xorl	%ecx, %ecx</span><br><span class="line">	movl	%eax, -8(%rbp)          <span class="comment">## 4-byte Spill</span></span><br><span class="line">	movl	%ecx, %eax</span><br><span class="line">	addq	<span class="variable">$16</span>, %rsp</span><br><span class="line">	popq	%rbp <span class="comment"># 与pushq对应</span></span><br><span class="line">	retq</span><br><span class="line">	.cfi_endproc <span class="comment"># 与 .cfi_startproc 相匹配，以此标记出 main() 函数结束</span></span><br><span class="line">                                        <span class="comment">## -- End function</span></span><br><span class="line">	.section	__TEXT,__cstring,cstring_literals <span class="comment"># __TEXT __cstring 开启了一个新的段。</span></span><br><span class="line">L_.str:       <span class="comment">#L_.str 标记运行在实际的代码中获取到字符串的一个指针                          ## @.str</span></span><br><span class="line">	.asciz	<span class="string">"hello world\n"</span> <span class="comment">#.asciz 指令告诉编译器输出一个以 ‘\0’ (null) 结尾的字符串。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.subsections_via_symbolsv <span class="comment"># .subsections_via_symbols 指令是静态链接编辑器使用的。</span></span><br></pre></td></tr></table></figure>
<p>具体的代码解读，有兴趣的同学可以到<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="noopener">苹果的 OS X Assembler Reference </a> 了解详细。</p>
<!-- https://objccn.io/issue-6-3/ -->
<h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><p>汇编器将可读的汇编代码转换为机器代码。它会创建一个目标对象文件，一般简称为 对象文件。这些文件以 .o 结尾。如果用 Xcode 构建应用程序，可以在工程的 derived data 目录中，Objects-normal 文件夹下找到这些文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如 生成 main.o文件</span></span><br><span class="line">clang -fmodules -c main.c -o main.o</span><br></pre></td></tr></table></figure>
<h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><p>链接器解决了目标文件和库之间的链接。例如上面汇编代码中 <code>callq   _printf</code>， <code>printf()</code> 是 libc 库中的一个函数。无论怎样，最后的可执行文件需要能需要知道 printf() 在内存中的具体位置：例如，_printf 的地址符号是什么。链接器会读取所有的目标文件 (此处只有一个) 和库 (此处是 libc)，并解决所有未知符号 (此处是 _printf) 的问题。然后将它们编码进最后的可执行文件中 （可以在 libc 中找到符号 _printf），接着链接器会输出可以运行的执行文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#生成 hello.out 的 Mach-O 二进制文件</span></span><br><span class="line">clang hello.c -o hello.out</span><br></pre></td></tr></table></figure>
<p>关于<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html" target="_blank" rel="noopener">Mach-O文件格式</a>有兴趣的同学可以通过apple文档来了解。</p>
<p>这里说 hello.out 是可执行文件，可以通过<code>file</code>来判断:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">file hello.out</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">hello.out: Mach-O 64-bit executable x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行hello.out</span></span><br><span class="line">./hello.out</span><br><span class="line"><span class="comment">#输出 </span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="编译多个文件"><a href="#编译多个文件" class="headerlink" title="编译多个文件"></a>编译多个文件</h2><p>之前上面我们的实验都是使用单个hello.c文件。现在我们通过多个文件情况 了解下汇编器和链接器 ,如下三个文件：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File1.h:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File1.m:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"File1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Foo</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSFullUserName</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File2.m:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"File1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Foo *foo = [[Foo alloc] init];</span><br><span class="line">        [foo run];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有三个文件，需要我们编译多个文件。我们需要让clang对输入每个文件生成对应的目标文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clang  -c Only run preprocess, compile, and assemble steps</span></span><br><span class="line"></span><br><span class="line">clang -c File1.m <span class="comment">#生成 File1.o</span></span><br><span class="line">clang -c File2.m <span class="comment">#生成 File2.o</span></span><br></pre></td></tr></table></figure>
<p>这里我们加了<code>-c</code> 并没有编译头文件，现在我们来完成<code>链接器</code>这一步,将两个 .o 文件与Foundation库链接起来：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  -Wl,&lt;arg&gt;               Pass the comma separated arguments in &lt;arg&gt; to the linker</span></span><br><span class="line">clang File1.o File2.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</span><br><span class="line"><span class="comment"># 输出 a.out</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以运行 <code>a.out</code> 了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./a.out </span><br><span class="line">2019-04-16 20:49:35.070 a.out[71207:10299638] sunTongSheng</span><br></pre></td></tr></table></figure>
<h3 id="符号表和链接"><a href="#符号表和链接" class="headerlink" title="符号表和链接"></a>符号表和链接</h3><p>File1 和 File2 都使用了 Foundation framework。 File2.o 目标文件使用了它的 autorelease pool，并间接的使用了 libobjc.dylib 中的 Objective-C 运行时。它需要运行时函数来进行消息的调用。所有的这些关联的东西都被形象的称之为符号。</p>
<p>每个函数、全局变量和类等都是通过符号的形式来定义和使用的。当我们将目标文件链接为一个可执行文件时，链接器在目标文件和动态库之间对符号做了解析处理。</p>
<p>可执行文件和目标文件有一个符号表，这个符号表规定了它们的符号。如果我们用 nm 工具观察一下 File2.o 目标文件，可以看到如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#nm : llvm symbol table dumper</span></span><br><span class="line">nm -nm File2.o</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br><span class="line">                 (undefined) external _objc_alloc</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush</span><br><span class="line">                 (undefined) external _objc_msgSend</span><br><span class="line">0000000000000000 (__TEXT,__text) external _main</span><br></pre></td></tr></table></figure>
<p>上面就是那个目标文件的所有符号。_OBJC_CLASS_$_Foo 是 Foo Objective-C 类的符号。该符号是 undefined, external 。External 的意思是指对于这个目标文件该类并不是私有的，相反，non-external 的符号则表示对于目标文件是私有的。我们的 File2.o 目标文件引用了类 Foo，不过这并没有实现它。因此符号表中将其标示为 undefined。接着是 4 个 Objective-C 运行时函数。它们同样是 undefined的，需要链接器进行符号解析。</p>
<p>接下来是 _main 符号，它是表示 main() 函数，同样为 external，这是因为该函数需要被调用，所以应该为可见的。由于在 helloworld.o 文件中实现了 这个 main 函数。这个函数地址位于 0处，并且需要转入到 <strong>TEXT,</strong>text section。</p>
<p>接下来看下 <code>File1.o</code>,看看有什么输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nm -nm File1.o</span><br><span class="line">                 (undefined) external _NSFullUserName</span><br><span class="line">                 (undefined) external _NSLog</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_NSObject</span></span><br><span class="line">                 (undefined) external _OBJC_METACLASS_<span class="variable">$_NSObject</span></span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference</span><br><span class="line">                 (undefined) external __objc_empty_cache</span><br><span class="line">0000000000000000 (__TEXT,__text) non-external -[Foo run]</span><br><span class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_<span class="variable">$_Foo</span></span><br><span class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_<span class="variable">$_INSTANCE_METHODS_Foo</span></span><br><span class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_<span class="variable">$_Foo</span></span><br><span class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_<span class="variable">$_Foo</span></span><br><span class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br></pre></td></tr></table></figure>
<p>File1.o 同样有 undefined 的符号。首先是使用了符号 <code>NSFullUserName()</code>，<code>NSLog()</code>和 <code>NSObject</code>。接着显示了 <code>_OBJC_CLASS_$_Foo</code> 已经定义了，并且对于 File1.o 是一个外部符号 , <code>File1.o</code> 包含了这个类的实现。</p>
<p>最后先来同样看下 a.out 的输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nm -nm a.out </span><br><span class="line">                 (undefined) external _NSFullUserName (from Foundation)</span><br><span class="line">                 (undefined) external _NSLog (from Foundation)</span><br><span class="line">                 (undefined) external _OBJC_CLASS_<span class="variable">$_NSObject</span> (from CoreFoundation)</span><br><span class="line">                 (undefined) external _OBJC_METACLASS_<span class="variable">$_NSObject</span> (from CoreFoundation)</span><br><span class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</span><br><span class="line">                 (undefined) external __objc_empty_cache (from libobjc)</span><br><span class="line">                 (undefined) external _objc_alloc (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</span><br><span class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</span><br><span class="line">                 (undefined) external _objc_msgSend (from libobjc)</span><br><span class="line">                 (undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000e90 (__TEXT,__text) non-external -[Foo run]</span><br><span class="line">0000000100000ec0 (__TEXT,__text) external _main</span><br><span class="line">0000000100001138 (__DATA,__objc_data) external _OBJC_METACLASS_<span class="variable">$_Foo</span></span><br><span class="line">0000000100001160 (__DATA,__objc_data) external _OBJC_CLASS_<span class="variable">$_Foo</span></span><br></pre></td></tr></table></figure>
<p>通过<code>a.out</code>的符号表，我们可以观察链接器是如何解析所有符号表的。当我们将这两个目标文件和 Foundation framework (是一个动态库) 进行链接处理时，链接器会尝试解析所有的 undefined 符号。它可以解析 _OBJC_CLASS_$_Foo。另外，它将使用 Foundation framework。当链接器通过动态库 (此处是 Foundation framework) 解析成功一个符号时，它会在最终的链接图中记录这个符号是通过动态库进行解析的。链接器会记录输出文件是依赖于哪个动态链接库，并连同其路径一起进行记录。在我们的例子中，_NSFullUserName，_NSLog，_OBJC_CLASS_$_NSObject，_objc_autoreleasePoolPop 等符号都是遵循这个过程。</p>
<p>虽然所有的 Foundation 和 Objective-C 运行时符号依旧是 undefined，不过现在的符号表中已经多了如何解析它们的信息，例如在哪个动态库中可以找到对应的符号。</p>
<p>可执行文件同样知道去哪里找到所需库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">otool -L a.out </span><br><span class="line">a.out:</span><br><span class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1560.12.0)</span><br><span class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)</span><br><span class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1454.90.0)</span><br><span class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure>
<h3 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h3><p>在运行时，动态链接器dyld可以解析这些 <code>undefined</code> 符号，dyld将会确定好 <code>_NSFullUserName</code> 等符号，并指向它们在 <code>Foundation</code> 中的实现等。<br>上面提到文件符号表指向了需要的库，添加<code>DYLD_PRINT_LIBRARIES</code>环境变量可以打印出什么库被加载了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">export</span> DYLD_PRINT_LIBRARIES=; ./a.out )</span><br><span class="line">dyld: loaded: /Users/suntongsheng/Desktop/tmp/asdasd/Test/./a.out</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</span><br><span class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</span><br><span class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>比如可以针对 Foundation 运行 <code>nm</code>，并检查这些符号的定义情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nm -nm /System/Library/Frameworks/Foundation.framework/Foundation | grep NSFullUserName</span><br><span class="line">00000000000bb1be (__TEXT,__text) external _NSFullUserName</span><br></pre></td></tr></table></figure>
<p>上面将会显示出在加载 Foundation 时，同时会加载的 70 个动态库。这是由于 Foundation 依赖于另外一些动态库。运行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xcrun otool -L /System/Library/Frameworks/Foundation.framework/Foundation</span><br></pre></td></tr></table></figure>
<p>可以看到 Foundation 关联的库。</p>
<p><strong><em>动态链接器dyld 的共享缓存</em></strong></p>
<p>当你构建一个真正的程序时，将会链接各种各样的库。它们又会依赖其他一些 framework 和 动态库。需要加载的动态库会非常多。而对于相互依赖的符号就更多了。可能将会有上千个符号需要解析处理，这将花费很长的时间：一般是好几秒钟。</p>
<p>为了缩短这个处理过程所花费时间，在 OS X 和 iOS 上的动态链接器使用了共享缓存，共享缓存存于 /var/db/dyld/。对于每一种架构，操作系统都有一个单独的文件，文件中包含了绝大多数的动态库，这些库都已经链接为一个文件，并且已经处理好了它们之间的符号关系。当加载一个 Mach-O 文件 (一个可执行文件或者一个库) 时，动态链接器首先会检查 共享缓存 看看是否存在其中，如果存在，那么就直接从共享缓存中拿出来使用。每一个进程都把这个共享缓存映射到了自己的地址空间中。这个方法大大优化了 OS X 和 iOS 上程序的启动时间。</p>
<h2 id="最后总结一下就是以下编译过程："><a href="#最后总结一下就是以下编译过程：" class="headerlink" title="最后总结一下就是以下编译过程："></a>最后总结一下就是以下编译过程：</h2><p><img src="/res/LLVM/llvm1.png" alt></p>
<h2 id="Xcode-编译"><a href="#Xcode-编译" class="headerlink" title="Xcode 编译"></a>Xcode 编译</h2><p>以上说的是Clang如何编译C语言文件的过程，那么在Xcode里会经过哪些过程呢？</p>
<p>我们可以简单新建一个单页面工程，Build后在Report Navigation视图中查看详细日志：</p>
<p><img src="/res/LLVM/xcode.png" alt></p>
<p>详细的步骤如下：</p>
<ol>
<li>创建文件夹</li>
<li>把Entitlements.plist写入到DerivedData里，处理打包的时候需要的信息（比如application-identifier）。</li>
<li>创建一些辅助文件，比如各种.hmap (headermap是帮助编译器找到头文件的辅助文件：存储这头文件到其物理路径的映射关系)</li>
<li>编译.m文件，生成.o文件。</li>
<li>链接动态库，o文件，生成一个mach o格式的可执行文件。</li>
<li>编译assets，编译storyboard，链接storyboard</li>
<li>对App签名</li>
<li>生成 .app</li>
</ol>
<p>在 build 处理过程中，每个任务都会出现类似上面的这些 log 信息，我们就通过上面的 log 信息进一步了解详情。</p>
]]></content>
      <categories>
        <category>重学iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Method-Swizzling使用</title>
    <url>/essay/Runtime/Method-Swizzling/</url>
    <content><![CDATA[<blockquote>
<p>   在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外,还能使用Method Swizzling方法</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。</p>
<p>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<a id="more"></a>
<p><img src="/res/runtime/o_methodSwizzling1.png" alt></p>
<p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，</p>
<p>我们可以利用 class_replaceMethod 来修改类，</p>
<p>我们可以利用 method_setImplementation 来直接设置某个方法的IMP，</p>
<p>归根结底，都是偷换了selector的IMP，如下图所示：</p>
<p><img src="/res/runtime/o_methodSwizzling2.png" alt></p>
<h2 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h2><p>举个例子好了，我想钩一下NSArray的lastObject 方法，只需两个步骤。</p>
<p>第一步：给NSArray加一个我自己的lastObject<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+Swizzle.h"</span>  </span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Swizzle</span>)  </span></span><br><span class="line">- (<span class="keyword">id</span>)myLastObject  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">id</span> ret = [<span class="keyword">self</span> myLastObject];  </span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"**********  myLastObject *********** "</span>);  </span><br><span class="line">   <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>乍一看，这不递归了么？别忘记这是我们准备调换IMP的selector，[self myLastObject] 将会执行真的 [self lastObject] 。</p>
<p>第二步：调换IMP</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+Swizzle.h"</span>  </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">@autoreleasepool</span> &#123;  </span><br><span class="line">         </span><br><span class="line">       Method ori_Method =  class_getInstanceMethod([<span class="built_in">NSArray</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lastObject));  </span><br><span class="line">       Method my_Method = class_getInstanceMethod([<span class="built_in">NSArray</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(myLastObject));  </span><br><span class="line">       method_exchangeImplementations(ori_Method, my_Method);  </span><br><span class="line">         </span><br><span class="line">       <span class="built_in">NSArray</span> *array = @[<span class="string">@"0"</span>,<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>];  </span><br><span class="line">       <span class="built_in">NSString</span> *string = [array lastObject];  </span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@"TEST RESULT : %@"</span>,string);  </span><br><span class="line">         </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出Log：    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2013-07-18 16:26:12.585 Hook[1740:c07] **********  myLastObject ***********   </span><br><span class="line">2013-07-18 16:26:12.589 Hook[1740:c07] TEST RESULT : 3</span><br></pre></td></tr></table></figure>
<h3 id="实践2">实践2：拦截系统方法</h3>

<blockquote>
<p>需求：比如iOS6 升级 iOS7 后需要版本适配，根据不同系统使用不同样式图片（拟物化和扁平化），如何通过不去手动一个个修改每个UIImage的imageNamed：方法就可以实现为该方法中加入版本判断语句？</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>为UIImage建一个分类（UIImage+Category）</li>
<li><p>在分类中实现一个自定义方法，方法中写要在系统方法中加入的语句，比如版本判断</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+(<span class="built_in">UIImage</span> *)xh_imageNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">   <span class="keyword">double</span> version = [[<span class="built_in">UIDevice</span> currentDevice].systemVersion doubleValue];</span><br><span class="line">   <span class="keyword">if</span> (version &gt;= <span class="number">7.0</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果系统版本是7.0以上，使用另外一套文件名结尾是‘_os7’的扁平化图片</span></span><br><span class="line">       name = [name stringByAppendingString:<span class="string">@"_os7"</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> [<span class="built_in">UIImage</span> xh_imageNamed:name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分类中重写UIImage的load方法，实现方法的交换（只要能让其执行一次方法交换语句，load再合适不过了）</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)load &#123;</span><br><span class="line">  	<span class="comment">// 获取两个类的类方法</span></span><br><span class="line">  	Method m1 = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">  	Method m2 = class_getClassMethod([<span class="built_in">UIImage</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(xh_imageNamed:));</span><br><span class="line">  	<span class="comment">// 开始交换方法实现</span></span><br><span class="line">  	method_exchangeImplementations(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：自定义方法中最后一定要再调用一下系统的方法，让其有加载图片的功能，但是由于方法交换，系统的方法名已经变成了我们自定义的方法名（有点绕，就是用我们的名字能调用系统的方法，用系统的名字能调用我们的方法），这就实现了系统方法的拦截！</strong></p>
<p>利用以上思路，我们还可以给 NSObject 添加分类，统计创建了多少个对象，给控制器添加分类，统计有创建了多少个控制器</p>
]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>objc_msgSend相关结构体 消息发送原理</title>
    <url>/essay/Runtime/runtime-objc_msgSend/</url>
    <content><![CDATA[<blockquote>
<p>介绍  消息发送以及相关的结构体<br><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">apple open source</a></p>
</blockquote>
<h3 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a>objc_msgSend</h3><p>给对象发送消息写法：</p>
<pre><code>`id returnValue = [somneObject messageName:parameter];`
</code></pre><p>编译器会将上诉代码转换为：</p>
<pre><code>`id = returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);`
</code></pre><p>其中 someObject叫做“接受者”（receiver），messageName叫做“选择子”（selector），选择子和参数合称“消息”</p>
<p>objc_msgSend 的定义： 该函数有两个参数，一个 id 类型，一个 SEL 类型。</p>
<pre><code>`id objc_msgSend(id self, SEL op, ...)`;
</code></pre><a id="more"></a>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p> 其实它就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。定义在在 objc/objc.h 目录下：</p>
<pre><code>`typedef struct objc_selector *SEL;`    
</code></pre><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p> id 是一个结构体指针类型，它可以指向 Objective-C 中的任何对象,id 也被定义在 objc/objc.h 目录下：</p>
<pre><code>`typedef struct objc_object *id;`
</code></pre><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p> Class 也是一个结构体指针类型：</p>
<pre><code>`typedef struct objc_class *Class;`
</code></pre><p> objc_class 结构体是:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;<span class="comment">//每个Class都有一个isa指针</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;<span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;<span class="comment">//类名</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;<span class="comment">//类版本</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;<span class="comment">//!*!供运行期使用的一些位标识。如：CLS_CLASS (0x1L)表示该类为普通class; CLS_META(0x2L)表示该类为metaclass等(runtime.h中有详细列出)</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;<span class="comment">//实例大小</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;<span class="comment">//存储每个实例变量的内存地址</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;<span class="comment">//!*!根据info的信息确定是类还是实例，运行什么函数方法等</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;<span class="comment">//缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;<span class="comment">//协议</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    </span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h4 id="MetaClass"><a href="#MetaClass" class="headerlink" title="MetaClass"></a>MetaClass</h4><p>isa和super_class是找到实现函数的关键映射，决定找到存放在哪个类的方法实现。（isa用于自省确定所属类，super_class确定继承关系）。</p>
<p>实例对象的isa指针指向类，类的isa指针指向其元类（metaClass）。对象就是一个含isa指针的结构体。类存储实例对象的方法列表，元类存储类的方法列表，元类也是类对象</p>
<p>我们发现 Class 本身也有一个 isa 指针，指向的是它的 MetaClass。</p>
<ul>
<li>当我们对一个实例发送消息时（-开头的方法），会在该 instance 对应的类的 methodLists 里查找。</li>
<li>当我们对一个类发送消息时（+开头的方法），会在该类的 MetaClass 的 methodLists 里查找。</li>
<li>每个 Class 都有一个 isa 指针指向一个唯一的 Meta Class</li>
<li>每一个 Meta Class 的 isa 指针都指向最上层的 Meta Class，即 NSObject 的 MetaClass，而最上层的 MetaClass 的 isa 指针又指向自己</li>
</ul>
<p><img src="/res/runtime/metaClass.png" alt></p>
<h4 id="objc-method-list"><a href="#objc-method-list" class="headerlink" title="objc_method_list"></a>objc_method_list</h4><p>其中objc_method_list:用来存储当前类的方法链表，objc_method存储了类的某个方法的信息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list *obsolete 	OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">int</span> method_count 	OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space 	OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>] 	OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p>objc_cache:方法调用最先是在方法缓存里找的，方法调用是懒调用，第一次调用时加载后加到缓存池里。一个objc程序启动后，需要进行类的初始化、调用方法时的cache初始化，再发送消息的时候就直接走缓存（引申：+load方法和+initialize方法。load方法是首次加载类时调用，绝对只调用一次；initialize方法是首次给类发消息时调用，通常只调用一次，但如果它的子类初始化时未定义initialize方法，则会再调用一次它的initialize方法）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache &#123;</span><br><span class="line">    <span class="comment">// 缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际缓存bucket的总数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="comment">// 指向Method数据结构指针的数组</span></span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>Method类型是一个objc_method结构体指针，而结构体objc_method有三个成员：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">   	SEL method_name;        <span class="comment">// 方法名称</span></span><br><span class="line">    	<span class="keyword">char</span> *method_typesE;    <span class="comment">// 参数和返回类型的描述字串</span></span><br><span class="line">   		IMP method_imp;         <span class="comment">// 方法的具体的实现的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Method相关方法"><a href="#Method相关方法" class="headerlink" title="Method相关方法"></a>Method相关方法</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class="line">method_invoke</span><br><span class="line"><span class="comment">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class="line">method_invoke_stret</span><br><span class="line"><span class="comment">// 获取函数名</span></span><br><span class="line">method_getName</span><br><span class="line"><span class="comment">// 获取函数实现IMP</span></span><br><span class="line">method_getImplementation</span><br><span class="line"><span class="comment">// 获取函数type encoding</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"><span class="comment">// 复制返回值类型</span></span><br><span class="line">method_copyReturnType</span><br><span class="line"><span class="comment">// 复制参数类型</span></span><br><span class="line">method_copyArgumentType</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">method_getReturnType</span><br><span class="line"><span class="comment">// 获取参数个数</span></span><br><span class="line">method_getNumberOfArguments</span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line">method_getArgumentType</span><br><span class="line"><span class="comment">// 获取函数描述</span></span><br><span class="line">method_getDescription</span><br><span class="line"><span class="comment">// 设置函数实现IMP</span></span><br><span class="line">method_setImplementation</span><br><span class="line"><span class="comment">// 交换函数的实现IMP</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure>
<h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h3><p>objc_property_t代表属性，而它又是一个结构体指针：</p>
<pre><code>`// An opaque type that represents an Objective-C declared property.
typedef struct objc_property *objc_property_t;`
</code></pre><p>objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Defines a property attribute</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;           <span class="comment">/**&lt; The name of the attribute */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;          <span class="comment">/**&lt; The value of the attribute (usually empty) */</span></span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>其中，value通常是空的，但是对于类型是有值的。    </p>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>成员变量通过Ivar表示，它是objc_ivar结构体指针：</p>
<pre><code>`// An opaque type that represents an instance variable.
typedef struct objc_ivar *Ivar;`
</code></pre><p>而objc_ivar结构的定义为：    </p>
<pre><code><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">	<span class="comment">// 成员变量名</span></span><br><span class="line">	<span class="keyword">char</span> *ivar_name                 OBJC2_UNAVAILABLE;  </span><br><span class="line">	<span class="comment">// 成员变量encode类型</span></span><br><span class="line">	<span class="keyword">char</span> *ivar_type                 OBJC2_UNAVAILABLE;  </span><br><span class="line">	<span class="comment">// 基地址偏移字节</span></span><br><span class="line">	<span class="keyword">int</span> ivar_offset                 OBJC2_UNAVAILABLE;  </span><br><span class="line">	<span class="meta">#ifdef __LP64__</span></span><br><span class="line">	<span class="keyword">int</span> space                       OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="消息发送过程"><a href="#消息发送过程" class="headerlink" title="消息发送过程"></a>消息发送过程</h2><p>当我们调用一个方法时，其运行过程大致如下：</p>
<ol>
<li>Runtime 系统会把方法调用转化为消息发送，即 objc_msgSend，并且把方法的调用者，和方法选择器，当做参数传递过去</li>
<li>方法的调用者会通过 isa 指针来找到其所属的类，然后在 cache 或者 methodLists 中查找该方法，找得到就跳到对应的方法去执行.（同时将匹配结果缓存在“快速映射表” （fast map）中。）<ul>
<li>methodLists 指向该类的实例方法列表，实例方法即-方法，那么类方法（+方法）存储在哪儿呢？类方法被存储在元类中，Class 通过 isa 指针即可找到其所属的元类.</li>
</ul>
</li>
<li>如果在类中没有找到该方法，则通过 super_class 往上一级超类查找（如果一直找到 NSObject 都没有找到该方法的话，这种情况，开始<a href="#动态方法解析">动态方法解析</a> <ul>
<li><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt><ul>
<li>NSObject 的超类为 nil，也就是它没有超类。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>如果某个对象调用了不存在的方法时会怎么样，一般情况下程序会crash</p>
<p>在程序crash之前，Runtime 会给我们动态方法解析的机会，消息发送的步骤大致如下：</p>
<ol>
<li>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数了.</li>
<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉.</li>
<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行.<br>如果 cache 找不到就找一下方法分发表.</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止.</li>
</ol>
<p>如果还找不到就要开始进入<a href="#消息转发">消息转发</a></p>
<h3 id="消息转发机制">消息转发机制</h3>

<ol>
<li>进入 resolveInstanceMethod: 方法，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过 class_addMethod 函数动态地添加方法，消息得到处理，此流程完毕.</li>
<li>resolveInstanceMethod: 方法返回 NO 时，就会进入 forwardingTargetForSelector: 方法，这是 Runtime 给我们的第二次机会，用于指定哪个对象响应这个 selector。返回nil，进入下一步，返回某个对象，则会调用该对象的方法.</li>
<li>若 forwardingTargetForSelector: 返回的是nil，则我们首先要通过 methodSignatureForSelector: 来指定方法签名，返回nil，表示不处理，若返回方法签名，则会进入下一步.</li>
<li>当第 methodSignatureForSelector: 方法返回方法签名后，就会调用 forwardInvocation: 方法，我们可以通过 anInvocation 对象做很多处理，比如修改实现方法，修改响应对象等.<ul>
<li>如果到最后，消息还是没有得到响应，程序就会crash</li>
<li><img src="/res/runtime/o_消息转发流程图.png" alt></li>
</ul>
</li>
</ol>
<!--## 动态加载

### +(void)load; +(void)initialize；有什么用处？

在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。 
共同点：两个方法都只会被调用一次。

>调用时间

* initialize()方法的调用是在一个类或者其子类的在发送第一个消息之前，
* +(void)load 这个方法调用较早，当类加载的时候该方法就会被调用。
* 父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。 

-->
<!-- 
* [runtime属性与成员变量](http://www.henishuo.com/runtime-property-ivar/)  
* [http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/#forwarding-%E4%B8%AD%E8%B7%AF%E6%BC%AB%E6%BC%AB%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/#forwarding-%E4%B8%AD%E8%B7%AF%E6%BC%AB%E6%BC%AB%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91) -->]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Category结构与原理</title>
    <url>/essay/Runtime/runtime-%E5%88%86%E7%B1%BBCategory%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>分类的实现原理，编译时的表现，运行时的加载原理<br>参考文档: <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4-723</a></p>
</blockquote>
<p>category的主要作用是为已经存在的类添加方法。可以把类的实现分开在几个不同的文件里面。</p>
<h3 id="Category-结构体"><a href="#Category-结构体" class="headerlink" title="Category 结构体"></a>Category 结构体</h3><p>Category用Category_t结构体定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//类的名字</span></span><br><span class="line">    classref_t cls;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods;<span class="comment">//实例方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods;<span class="comment">//类方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols;<span class="comment">//所有协议的列表</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties;<span class="comment">//添加的所有属性</span></span><br><span class="line">&#125; category_t;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>
<h3 id="Category-与-Extension"><a href="#Category-与-Extension" class="headerlink" title="Category 与 Extension"></a>Category 与 Extension</h3><p><strong>extension</strong>看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。</p>
<p>但是<strong>category</strong>则完全不一样，它是在运行期决议的。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
<h3 id="Category编译时"><a href="#Category编译时" class="headerlink" title="Category编译时"></a>Category编译时</h3><h4 id="写个简单的Category："><a href="#写个简单的Category：" class="headerlink" title="写个简单的Category："></a>写个简单的Category：</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OneClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)oneMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OneClass</span>(<span class="title">OneCategory</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *oneCategoryProp;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)oneCategoryMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"OneClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneClass</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)oneMethod&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@" oneMethod "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OneClass</span>(<span class="title">OneCategory</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)oneCategoryMethod&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@" oneCategoryMethod "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="然后使用Clang命令编译下，命令如下："><a href="#然后使用Clang命令编译下，命令如下：" class="headerlink" title="然后使用Clang命令编译下，命令如下："></a>然后使用Clang命令编译下，命令如下：</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc OneClass.m</span><br></pre></td></tr></table></figure>
<p>然后得到一个3m多的OneClass.app文件……</p>
<h4 id="在OneClass-app中找到相关的代码片段："><a href="#在OneClass-app中找到相关的代码片段：" class="headerlink" title="在OneClass.app中找到相关的代码片段："></a>在OneClass.app中找到相关的代码片段：</h4><blockquote>
<p>生成了实例方法列表:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_OneClass_$_OneCategory __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">"oneCategoryMethod"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_OneClass_OneCategory_oneCategoryMethod&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成了属性列表：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_OneClass_$_OneCategory __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;<span class="string">"oneCategoryProp"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成了category本身 ，并用前面的实例方法列表和属性方法列表初始化</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_OneClass_</span>$_<span class="title">OneCategory</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="string">"OneClass"</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_OneClass,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_OneClass_$_OneCategory,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_OneClass_$_OneCategory,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组），用于运行期category的加载。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>")))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_OneClass_$_OneCategory,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Category运行期加载"><a href="#Category运行期加载" class="headerlink" title="Category运行期加载"></a>Category运行期加载</h3><h4 id="objc-init-和-map-images"><a href="#objc-init-和-map-images" class="headerlink" title="objc_init 和 map_images"></a>objc_init 和 map_images</h4><p>在OC运行时入口方法<code>_objc_init</code>中（（在objc-os.mm文件中））：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">……</span><br><span class="line">	<span class="comment">//category被附加到类上面是在map_images的时候发生的</span></span><br><span class="line">	_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体点大概是这么个流程:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_objc_init  -&gt; map_images -&gt; map_images_nolock -&gt; _read_images</span><br></pre></td></tr></table></figure>
<h4 id="read-images"><a href="#read-images" class="headerlink" title="read_images"></a>read_images</h4><p><code>_objc_init</code>里面的调用的map_images最终会调用<strong>objc-runtime-new.mm</strong>里面的<code>_read_images</code>方法，而在<code>_read_images</code>方法的结尾，有以下的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">//catlist就是上节中讲到的编译器为我们准备的category_t数组</span></span><br><span class="line">    <span class="keyword">category_t</span> **catlist = </span><br><span class="line">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            catlist[i] = nil;</span><br><span class="line">            。。。</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this category. </span></span><br><span class="line">        <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">        <span class="comment">// the class is realized.</span></span><br><span class="line">        <span class="comment">// 把category的实例方法、协议以及属性添加到类上</span></span><br><span class="line">        <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">            ||  cat-&gt;instanceProperties) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            。。。</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把category的类方法和协议添加到类的metaclass上</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            &#125;</span><br><span class="line">            。。。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到remethodizeClass处理添加事宜方法</p>
<h4 id="remethodizeClass-amp-amp-attachCategories"><a href="#remethodizeClass-amp-amp-attachCategories" class="headerlink" title="remethodizeClass &amp;&amp; attachCategories"></a>remethodizeClass &amp;&amp; attachCategories</h4><p>既然remethodizeClass才是真正去处理添加事宜方法那么现在看一下remethodizeClass：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    。。。</span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">    	。。。       </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmm 好像remethodizeClass也没干什么事，都交给了<code>attachCategories</code>方法了嘛，接下来看下attachCategories：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    bool isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    // fixme rearrange to remove these intermediate allocations</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    property_list_t **proplists = (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    protocol_list_t **protolists = (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int propcount = 0;</span><br><span class="line">    int protocount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    bool fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        auto&amp; entry = cats-&gt;list[i];</span><br><span class="line"></span><br><span class="line">        method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        property_list_t *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protocol_list_t *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 data() 中 method_lists（或 method_list）、properties 和 protocols 的值。</p>
<ul>
<li>category的方法没有替换掉原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休。</li>
<li><strong>怎么调用到原来类中被category覆盖掉的方法</strong>？对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</li>
</ul>
<hr>
<ul>
<li>参考资料<ul>
<li><a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Apple Open Source : objc4-646.tar.gz</a></li>
<li><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">https://tech.meituan.com/DiveIntoCategory.html</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/" target="_blank" rel="noopener">http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime 实践</title>
    <url>/essay/Runtime/runtime%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>介绍</p>
<ul>
<li>dynamicWebkit替换、</li>
<li>动态添加方法 + 动态交换方法 -&gt; UIButton防止多次点击、</li>
<li>遍历变量 -&gt; 隐藏键盘、</li>
<li>遍历属性 -&gt; 获取属性名</li>
<li>遍历属性 -&gt; 判断所有变量是否已经实例化</li>
</ul>
<a id="more"></a>
<h3 id="dynamicWebkit"><a href="#dynamicWebkit" class="headerlink" title="dynamicWebkit"></a>dynamicWebkit</h3><blockquote>
<p>Apple 从 iOS8 开始，推出了更新、优化更好的WKWebkit。这个库是UIWebView的继承者，在相同的浏览页面下，WKWebKit提供的WKWebView的内存占用率甚至可以只有UIWebView的1/10。可惜的是，我们很多时候为了保证用户的覆盖率，target iOS Version都是 iOS7。这时候我们就需要使用UIWebView来达到显示的目的。<br>那么问题来了，如何实现根据iOS版本来达到动态加载的目的呢？</p>
</blockquote>
<p>参考 <a href="http://www.jianshu.com/p/3f71fb190fbe" target="_blank" rel="noopener">http://www.jianshu.com/p/3f71fb190fbe</a></p>
<p>感觉这更多是偏向于URL route的感觉，类似的还有：<br><a href="http://www.jianshu.com/p/8b3a9155468d" target="_blank" rel="noopener">http://www.jianshu.com/p/8b3a9155468d</a></p>
<h3 id="动态添加方法-动态交换方法-gt-UIButton防止多次点击"><a href="#动态添加方法-动态交换方法-gt-UIButton防止多次点击" class="headerlink" title="动态添加方法 + 动态交换方法 -&gt; UIButton防止多次点击"></a>动态添加方法 + 动态交换方法 -&gt; UIButton防止多次点击</h3><blockquote>
<p>步骤：</p>
</blockquote>
<ul>
<li>新建UIButton分类，在load方法中 使用自定义方法替换掉原先的 <code>- (void)sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event</code>方法</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    SEL originSEL = <span class="keyword">@selector</span>(sendAction:to:forEvent:);</span><br><span class="line">    SEL mySEL = <span class="keyword">@selector</span>(my_sendAction:to:forEvent:);</span><br><span class="line">    </span><br><span class="line">    Method originM = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], originSEL);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeEncodinds = method_getTypeEncoding(originM);</span><br><span class="line">    </span><br><span class="line">    Method newM = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], mySEL);</span><br><span class="line">    IMP newIMP = method_getImplementation(newM);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], mySEL, newIMP, typeEncodinds)) &#123;</span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], originSEL, newIMP, typeEncodinds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originM, newM);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现自定义方法，在某个时间间隔之内，不响应点击</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)my_sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保险起见，判断下Class类型</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 按钮点击间隔事件</span></span><br><span class="line">        <span class="keyword">self</span>.clickDurationTime = <span class="keyword">self</span>.clickDurationTime == <span class="number">0</span> ? defaultDuration : <span class="keyword">self</span>.clickDurationTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 是否忽略按钮点击事件</span></span><br><span class="line">        <span class="keyword">if</span> (_isIgnoreEvent) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@" 忽略按钮事件 "</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">self</span>.clickDurationTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"//2.2 不忽略按钮事件"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 后续在间隔时间内直接忽略按钮事件</span></span><br><span class="line">            _isIgnoreEvent = <span class="literal">YES</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 间隔事件后，执行按钮事件</span></span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="keyword">self</span>.clickDurationTime * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                resetState();</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送按钮点击消息</span></span><br><span class="line">            [<span class="keyword">self</span> my_sendAction:action to:target forEvent:event];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> my_sendAction:action to:target forEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历变量-gt-隐藏键盘"><a href="#遍历变量-gt-隐藏键盘" class="headerlink" title="遍历变量 -&gt; 隐藏键盘"></a>遍历变量 -&gt; 隐藏键盘</h3><blockquote>
<p>在viewcontroller中有些操作需要隐藏原先的键盘</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  找到 obj 实例中的 textfield 和 textView，并取消键盘</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param obj （not nil）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="keyword">void</span>)resignTFandTV:(<span class="keyword">id</span>)obj&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *vars = class_copyIvarList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar var = vars[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">id</span> value = [obj valueForKey:key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">UITextField</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">UITextView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">if</span>([value canResignFirstResponder])</span><br><span class="line">                [value resignFirstResponder];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历属性-gt-获取属性名"><a href="#遍历属性-gt-获取属性名" class="headerlink" title="遍历属性 -&gt; 获取属性名"></a>遍历属性 -&gt; 获取属性名</h3><blockquote>
<p>一些简单的model 或者自定义 view ，可以获取属性名来实例化对应的属性</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  找到类定义 中的 属性名（如 _msString） 数组</span></span><br><span class="line"><span class="comment">    （如 用来生成类型的成员变量）</span></span><br><span class="line"><span class="comment"> *  @param obj    类的实例</span></span><br><span class="line"><span class="comment"> *  @param aClass 需要获取的特定的类型的属性名 （若为空 则 寻找所有的属性名）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return       属性名返回顺序和obj中定义的顺序一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span>*&gt;*)getIvarNamesFrom:(<span class="keyword">id</span>)obj specialCls:(Class)aClass&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span>*&gt;* arr = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *properties = class_copyPropertyList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        objc_property_t property = properties[i];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span>* name = [<span class="keyword">self</span> getProertyIvarName:property];</span><br><span class="line">        <span class="built_in">NSString</span>* type = [<span class="keyword">self</span> getProertyTypeName:property];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(aClass)&#123;</span><br><span class="line">            <span class="keyword">if</span>(type)&#123;</span><br><span class="line">                Class someClass = <span class="built_in">NSClassFromString</span>(type);</span><br><span class="line">                <span class="keyword">if</span>(someClass &amp;&amp; someClass == aClass )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(name) [arr addObject:name];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//若没有特定aclass 则取所有类型的值</span></span><br><span class="line">            <span class="keyword">if</span>(name) [arr addObject:name];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    free(properties);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 用法：</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> -(void)setupLabels&#123;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> NSMutableArray&lt;NSString*&gt;* labelNames = [LQUtils getIvarNamesFrom:self specialCls:[UILabel class]];</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> for(int i = 0 ; i &lt; labelNames.count; i++)&#123;</span></span><br><span class="line"><span class="comment"> UILabel* tf = [UILabel new];</span></span><br><span class="line"><span class="comment"> tf.font = [UIFont systemFontOfSize:14];</span></span><br><span class="line"><span class="comment"> tf.textColor = [UIColor lightGrayColor];</span></span><br><span class="line"><span class="comment"> tf.textAlignment = NSTextAlignmentLeft;</span></span><br><span class="line"><span class="comment"> [self.contentView addSubview:tf];</span></span><br><span class="line"><span class="comment"> [self setValue:tf forKeyPath:labelNames[i]];</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  找到 objc_property_t 结构中保存的 属性名 ； 如 _myString</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param property</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="built_in">NSString</span>*)getProertyIvarName:(objc_property_t)property&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    objc_property_attribute_t *attrbutes = property_copyAttributeList(property, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; ++j) &#123;</span><br><span class="line">        objc_property_attribute_t attribute = attrbutes[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = attribute.name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *value = attribute.value;</span><br><span class="line">        <span class="built_in">NSString</span> *utfName = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">        <span class="built_in">NSString</span> *utfValue = [<span class="built_in">NSString</span> stringWithUTF8String:value];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>([utfName isEqualToString:<span class="string">@"V"</span>])&#123;</span><br><span class="line">            </span><br><span class="line">            utfValue = [utfValue stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</span><br><span class="line">            utfValue = [utfValue stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line">            <span class="keyword">return</span> utfValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(attrbutes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  找到 objc_property_t 结构中保存的 属性类型名 ； 如 NSString</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param property</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="built_in">NSString</span>*)getProertyTypeName:(objc_property_t)property&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    objc_property_attribute_t *attrbutes = property_copyAttributeList(property, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; ++j) &#123;</span><br><span class="line">        objc_property_attribute_t attribute = attrbutes[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = attribute.name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *value = attribute.value;</span><br><span class="line">        <span class="built_in">NSString</span> *utfName = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">        <span class="built_in">NSString</span> *utfValue = [<span class="built_in">NSString</span> stringWithUTF8String:value];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>([utfName isEqualToString:<span class="string">@"T"</span>])&#123;</span><br><span class="line">            </span><br><span class="line">            utfValue = [utfValue stringByReplacingOccurrencesOfString:<span class="string">@"\""</span> withString:<span class="string">@""</span>];</span><br><span class="line">            utfValue = [utfValue stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line">            <span class="keyword">return</span> utfValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(attrbutes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历属性-gt-判断所有变量是否已经实例化"><a href="#遍历属性-gt-判断所有变量是否已经实例化" class="headerlink" title="遍历属性 -&gt; 判断所有变量是否已经实例化"></a>遍历属性 -&gt; 判断所有变量是否已经实例化</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  查看类的实例中 某些特定类型的 属性是否实例化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param obj</span></span><br><span class="line"><span class="comment"> *  @param aClass</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="built_in">BOOL</span>)isIvarsVaildOf:(<span class="keyword">id</span>)obj specialCls:(Class)aClass&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span>*&gt;* ivarNames = [<span class="keyword">self</span> getIvarNamesFrom:<span class="keyword">self</span> specialCls:aClass];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ivarNames.count; i++)&#123;</span><br><span class="line">        <span class="built_in">NSString</span>* key = ivarNames[i];</span><br><span class="line">        <span class="keyword">id</span> value = [obj valueForKey:key];</span><br><span class="line">        <span class="keyword">if</span>(!value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  查看类的实例中所有属性是否实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+(<span class="built_in">BOOL</span>)isIvarAllVaildOf:(<span class="keyword">id</span>)obj&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isIvarsVaildOf:obj specialCls:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime 对象关联原理</title>
    <url>/essay/Runtime/runtime-%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94/</url>
    <content><![CDATA[<blockquote>
<p>介绍 对象关联，以及如何为Category添加weak属性<br><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">apple open source</a></p>
</blockquote>
<h2 id="对象关联原理"><a href="#对象关联原理" class="headerlink" title="对象关联原理"></a>对象关联原理</h2><p>创建一个类的分类<code>Category</code>，并添加一个属性<code>CategoryProperty</code>，分类中的@CategoryProperty并没有帮我们生成实例变量以及存取方法，要求我们手动实现，这时候就需要用到对象关联。</p>
<p>在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。</p>
<p>关联对象又是如何实现并且管理的呢：<br><a id="more"></a></p>
<ul>
<li>关联对象其实就是 ObjcAssociation 对象</li>
<li>关联对象由 AssociationsManager 管理并在  AssociationsHashMap 存储</li>
<li>对象的指针以及其对应 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中<br>ObjectAssociationMap 则是用于存储关联对象的数据结构</li>
<li>每一个对象都有一个标记位 has_assoc 指示对象是否含有关联对象</li>
</ul>
<p>对象关联会用到以下三个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以键值对形式添加关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy);</span><br><span class="line"><span class="comment">//根据 key 获取关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">移除所有关联对象</span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object);</span><br></pre></td></tr></table></figure>
<p><em>objc_removeAssociatedObjects 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象。</em></p>
<h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>objc_setAssociatedObject 方法，这个方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>_object_set_associative_reference</code>方法实际完成了设置关联对象的任务：</p>
<p>该方法的执行是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">	 <span class="comment">//1.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	  <span class="comment">//3.</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">		  <span class="keyword">if</span>(new_value)&#123;</span><br><span class="line">		  	AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">		  	<span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">        	 	 <span class="comment">//6.</span></span><br><span class="line">           	 ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">           	 ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">           	 <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">           	     old_association = j-&gt;second;</span><br><span class="line">           	     j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">           	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             	   (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">           	 &#125;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	  	<span class="comment">//5.</span></span><br><span class="line">            	ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">            	associations[disguised_object] = refs;</span><br><span class="line">            	(*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">           	 <span class="comment">//它会将 isa 结构体中的标记位 has_assoc 标记为 true</span></span><br><span class="line">            	object-&gt;setHasAssociatedObjects();</span><br><span class="line">        		&#125;</span><br><span class="line">		  &#125;</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">else</span>&#123;</span><br><span class="line">        	AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        	<span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">           	 ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">           	 ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">           	 <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">           	     old_association = j-&gt;second;</span><br><span class="line">           	     <span class="comment">//调用 erase 方法，擦除 ObjectAssociationMap 中 key 对应的节点。</span></span><br><span class="line">          	      refs-&gt;erase(j);</span><br><span class="line">          	  &#125;</span><br><span class="line">       	 &#125;</span><br><span class="line">   		 &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中设置关联对象的逻辑：</p>
<ol>
<li>使用 old_association(0, nil) 创建一个临时的 ObjcAssociation 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</li>
<li>调用 acquireValue 对 new_value 进行 retain 或者 copy</li>
<li>初始化一个 AssociationsManager，并获取唯一的保存关联对象的哈希表 AssociationsHashMap</li>
<li>先使用 DISGUISE(object) 作为 key 寻找对应的 ObjectAssociationMap</li>
<li>如果没有找到，初始化一个 ObjectAssociationMap，再实例化 ObjcAssociation 对象添加到 Map 中，并调用 setHasAssociatedObjects 方法，表明当前对象含有关联对象</li>
<li>如果找到了对应的 ObjectAssociationMap，就要看 key 是否存在了，由此来决定是更新原有的关联对象，还是增加一个</li>
<li>最后，如果原来的关联对象有值的话，会调用 ReleaseValue() 释放关联对象的值</li>
</ol>
<p><img src="/res/runtime/objc_setAssociatedObject.png" alt></p>
<h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>objc_getAssociatedObject方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_object_get_associative_reference</code>方法实现了相应的任务：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中寻找关联对象的逻辑：</p>
<ol>
<li>获取静态变量 AssociationsHashMap</li>
<li>以 DISGUISE(object) 为 key 查找 AssociationsHashMap</li>
<li>以 void *key 为 key 查找 ObjcAssociation</li>
<li>根据 policy 调用相应的方法</li>
<li>返回关联对象 ObjcAssociation 的值</li>
</ol>
<h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><p><code>objc_removeAssociatedObjects</code>  的调用：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了加速移除对象的关联对象的速度，我们会通过标记位 has_assoc 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 _object_remove_assocations 方法移除对象上所有的关联对象,方法会将对象包含的所有关联对象加入到一个 vector 中，然后对所有的 ObjcAssociation 对象调用 ReleaseValue() 方法，释放不再被需要的值:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(<span class="keyword">id</span> object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h3><p>AssociationsManager 在源代码中的定义是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsManager &#123;</span><br><span class="line">    <span class="keyword">static</span> spinlock_t _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">spinlock_t AssociationsManager::_lock;</span><br><span class="line">AssociationsHashMap *AssociationsManager::_map = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。</p>
<p>它维护了 spinlock_t 和 <strong>AssociationsHashMap</strong> 的单例，初始化它的时候会调用 lock.lock() 方法，在析构时会调用 lock.unlock()，而 associations 方法用于取得一个全局的 AssociationsHashMap 单例。<br>也就是说 AssociationsManager 通过持有一个自旋锁 spinlock_t 保证对 AssociationsHashMap 的操作是线程安全的，即每次只会有一个线程对 AssociationsHashMap 进行操作。</p>
<h3 id="AssociationsHashMap-ObjectAssociationMap"><a href="#AssociationsHashMap-ObjectAssociationMap" class="headerlink" title="AssociationsHashMap ObjectAssociationMap"></a>AssociationsHashMap ObjectAssociationMap</h3><p>AssociationsHashMap 用与保存从对象的 disguised_ptr_t 到 <strong>ObjectAssociationMap</strong> 的映射：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">void</span> *operator new(size_t n) &#123; <span class="keyword">return</span> ::malloc(n); &#125;</span><br><span class="line">    <span class="keyword">void</span> operator delete(<span class="keyword">void</span> *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ObjectAssociationMap 则保存了从 key 到关联对象 ObjcAssociation 的映射，这个数据结构保存了当前对象对应的所有关联对象:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjectAssociationMap : public std::map&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">   <span class="keyword">void</span> *operator new(size_t n) &#123; <span class="keyword">return</span> ::malloc(n); &#125;</span><br><span class="line">   <span class="keyword">void</span> operator delete(<span class="keyword">void</span> *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="ObjcAssociation"><a href="#ObjcAssociation" class="headerlink" title="ObjcAssociation"></a>ObjcAssociation</h3><p>ObjcAssociation 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。ObjcAssociation 包含了 policy 以及 value：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    <span class="keyword">id</span> _value;</span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, <span class="keyword">id</span> value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(<span class="number">0</span>), _value(<span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="keyword">id</span> value() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> hasValue() &#123; <span class="keyword">return</span> _value != <span class="literal">nil</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="为category添加weak属性"><a href="#为category添加weak属性" class="headerlink" title="为category添加weak属性"></a>为category添加weak属性</h2><p><code>objc_AssociationPolicy</code>并没有提供一个类似OBJC_ASSOCIATION_WEAK_NONATOMIC的的东西，那么就需要自己在需要的时候手动将属性设置为nil。</p>
<p>要实现 weak ，说白了就是要做到两点：1、引用计数器不变；2、对象销毁后自动设置为 nil。而在 runtime 所提供的枚举中，OBJC_ASSOCIATION_ASSIGN 就已经做到了第一点，我们只需要实现第二点即可。第二点是要在对象销毁后，将 weak 引用设置为 nil ，所以我们要捕获这个对象销毁的时机，或者接收这个对象销毁的事件。在 ARC 中，对象销毁时机其实就是 dealloc 方法调用的时机，我们可以在这个方法里将这个 weak 引用设置为 nil</p>
<p>以下为解决思路：</p>
<p><img src="/res/runtime/category-weak.png" alt></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^DeallocBlock)();</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OriginalObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) DeallocBlock block;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(DeallocBlock)block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OriginalObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(DeallocBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.block = block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在被销毁后 告诉属性应该设置为nil</span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.block ? <span class="keyword">self</span>.block() : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Category里:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject+property.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">property</span>)</span></span><br><span class="line"><span class="comment">// 我们的weak指针  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> objc_weak_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject+property.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">property</span>)</span></span><br><span class="line">- (<span class="keyword">id</span>)objc_weak_id </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObjc_weak_id:(<span class="keyword">id</span>)objc_weak_id </span><br><span class="line">&#123;</span><br><span class="line">    OriginalObject *ob = [[OriginalObject alloc] initWithBlock:^&#123;</span><br><span class="line">      <span class="comment">// 该将属性设置为nil了</span></span><br><span class="line">      objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(objc_weak_id), <span class="literal">nil</span>, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    &#125;];</span><br><span class="line">    objc_setAssociatedObject(objc_weak_id, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(ob.block), ob, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(objc_weak_id), objc_weak_id, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <!-- [https://draveness.me/ao](https://draveness.me/ao) -->]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-SDWebImageDecoder</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-SDWebImageDecoder/</url>
    <content><![CDATA[<p>由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，</p>
<p>所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。</p>
<p>为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。</p>
<p>这种做法是典型的空间换时间的做法。</p>
<p>首先NSURLCache是缓存原始数据(raw data)到磁盘或内存，因此每次使用的时候需要将原始数据转换成具体的对象，如UIImage等，这会导致额外的数据解析以及内存占用等，而SDWebImage则是缓存UIImage对象在内存，缓存在NSCache中，同时直接保存压缩过的图片到磁盘中；还有一个问题是当你第一次在UIImageView中使用image对象的时候，图片的解码是在主线程中运行的！而SDWebImage会强制将解码操作放到子线程中。</p>
<p>以上记录下来备忘 还不是很理解怎么回事</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>Runtime 使用</title>
    <url>/essay/Runtime/runtime%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>主要包含 字典与模型互转 、对象关联、遍历变量、遍历方法、遍历协议</p>
<a id="more"></a>
<h2 id="字典与模型互转">字典与模型互转</h2>

<p>字典转模型的时候：</p>
<ol>
<li>根据字典的 key 生成 setter 方法.</li>
<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</li>
</ol>
<p>模型转字典的时候：</p>
<ol>
<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性.</li>
<li>调用 property_getName 获取属性名称.</li>
<li>根据属性名称生成 getter 方法.</li>
<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）. </li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSObject+KeyValues.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">KeyValues</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字典转模型</span></span><br><span class="line">+(<span class="keyword">id</span>)objectWithKeyValues:(<span class="built_in">NSDictionary</span> *)aDictionary&#123;</span><br><span class="line">   <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> aDictionary.allKeys) &#123;</span><br><span class="line">       <span class="keyword">id</span> value = aDictionary[key];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*判断当前属性是不是Model*/</span></span><br><span class="line">       objc_property_t property = class_getProperty(<span class="keyword">self</span>, key.UTF8String);</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">       objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</span><br><span class="line">       objc_property_attribute_t attribute = attributeList[<span class="number">0</span>];</span><br><span class="line">       <span class="built_in">NSString</span> *typeString = [<span class="built_in">NSString</span> stringWithUTF8String:attribute.value];</span><br><span class="line">       <span class="keyword">if</span> ([typeString isEqualToString:<span class="string">@"@\"TestModel\""</span>]) &#123;</span><br><span class="line">           value = [<span class="keyword">self</span> objectWithKeyValues:value];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**********************/</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//生成setter方法，并用objc_msgSend调用</span></span><br><span class="line">       <span class="built_in">NSString</span> *methodName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>,[key substringToIndex:<span class="number">1</span>].uppercaseString,[key substringFromIndex:<span class="number">1</span>]];</span><br><span class="line">       SEL <span class="keyword">setter</span> = sel_registerName(methodName.UTF8String);</span><br><span class="line">       <span class="keyword">if</span> ([objc respondsToSelector:<span class="keyword">setter</span>]) &#123;</span><br><span class="line">           ((<span class="keyword">void</span> (*) (<span class="keyword">id</span>,SEL,<span class="keyword">id</span>)) objc_msgSend) (objc,<span class="keyword">setter</span>,value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模型转字典</span></span><br><span class="line">-(<span class="built_in">NSDictionary</span> *)keyValuesWithObject&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       objc_property_t property = propertyList[i];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//生成getter方法，并用objc_msgSend调用</span></span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">       SEL <span class="keyword">getter</span> = sel_registerName(propertyName);</span><br><span class="line">       <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>]) &#123;</span><br><span class="line">           <span class="keyword">id</span> value = ((<span class="keyword">id</span> (*) (<span class="keyword">id</span>,SEL)) objc_msgSend) (<span class="keyword">self</span>,<span class="keyword">getter</span>);</span><br><span class="line">           </span><br><span class="line">           <span class="comment">/*判断当前属性是不是Model*/</span></span><br><span class="line">           <span class="keyword">if</span> ([value isKindOfClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] &amp;&amp; value) &#123;</span><br><span class="line">               value = [value keyValuesWithObject];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/**********************/</span></span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (value) &#123;</span><br><span class="line">               <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:propertyName];</span><br><span class="line">               [dict setObject:value forKey:key];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> dict;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="对象关联">对象关联</h2>

<blockquote>
<p>对已经存在的类在 Category 中添加自定义的属性：</p>
</blockquote>
<ul>
<li>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，</li>
<li>要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可</li>
<li>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.</li>
</ul>
<blockquote>
<p>示例：</p>
</blockquote>
<p>为类别添加chineseName属性<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XiaoMing+MutipleName.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XiaoMing</span> (<span class="title">MutipleName</span>)</span></span><br><span class="line"><span class="keyword">char</span> cName;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setChineseName:(<span class="built_in">NSString</span> *) chineseName&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;cName, chineseName, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)chineseName&#123;</span><br><span class="line"><span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;cName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>举个栗子，假如我们要给 UIButton 添加一个监听单击事件的 block 属性，新建 UIButton 的 Category，其.m文件如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"UIButton+ClickBlock.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">void</span> *associatedKey = <span class="string">"associatedKey"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">ClickBlock</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Category中的属性，只会生成setter和getter方法，不会生成成员变量</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setClick:(clickBlock)click&#123;</span><br><span class="line">   objc_setAssociatedObject(<span class="keyword">self</span>, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">   [<span class="keyword">self</span> removeTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">   <span class="keyword">if</span> (click) &#123;</span><br><span class="line">       [<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(clickBlock)click&#123;</span><br><span class="line">   <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, associatedKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)buttonClick&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.click) &#123;</span><br><span class="line">       <span class="keyword">self</span>.click();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在代码中，就可以使用 UIButton 的属性来监听单击事件了：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">button.frame = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:button];</span><br><span class="line">button.click = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"buttonClicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历变量">遍历变量</h2>

<ol>
<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>
<li>使用 ivar_getName 方法获取成员变量的名称.</li>
<li>通过 KVC 来读取 Model 的属性值</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   Ivar *vars = class_copyIvarList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       Ivar var = vars[i];</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *type = ivar_getTypeEncoding(ivar);</span><br><span class="line">       <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></span><br><span class="line">       <span class="comment">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></span><br><span class="line">       <span class="comment">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></span><br><span class="line">       <span class="keyword">id</span> value = [obj valueForKey:key];</span><br><span class="line">       <span class="comment">//对value做相应操作</span></span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动归档">自动归档</h3>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"TestModel.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestModel</span></span></span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       Ivar var = vars[i];</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">       <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 注意kvc的特性是，如果能找到key这个属性的setter方法，则调用setter方法</span></span><br><span class="line">       <span class="comment">// 如果找不到setter方法，则查找成员变量key或者成员变量_key，并且为其赋值</span></span><br><span class="line">       <span class="comment">// 所以这里不需要再另外处理成员变量名称的“_”前缀</span></span><br><span class="line">       <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">       [aCoder encodeObject:value forKey:key];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">       Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">           Ivar var = vars[i];</span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">           <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">           <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">           [<span class="keyword">self</span> setValue:value forKey:key];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="修改变量值">修改变量值</h3>

<ol>
<li>使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.</li>
<li>使用 ivar_getName 方法获取成员变量的名称.</li>
<li>通过 KVC 来读取 Model 的属性值</li>
<li>修改对应的字段值 object_setIvar(id obj, Ivar ivar, id value) </li>
</ol>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   Ivar *vars = class_copyIvarList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       Ivar var = vars[i];</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">       <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> ([name isEqualToString:<span class="string">@"_shuxingming"</span>]) &#123;</span><br><span class="line">       object_setIvar(<span class="keyword">self</span>, var, <span class="string">@"新的值"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历属性">遍历属性</h2>


<ol>
<li>通过class_copyPropertyList函数来获取属性列表，其中属性列表是使用@property声明的列表，对于直接使用声明为成员变量的，都不会出现在属性列表中，这也是正常的。</li>
<li>我们通过runtime提供的property_getName函数来获取属性名称。</li>
<li>若有获取属性的详细描述，可通过runtime提供的property_getAttributes函数来获取。</li>
<li>若有获取属性中的objc_property_attribute_t列表，可以通过property_copyAttributeList函数来获取。</li>
<li>若有获取单独的objc_property_attribute_t的name或者value，直接使用点语法即可，它是一个结构体。</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">	objc_property_t property = properties[i];</span><br><span class="line">	<span class="comment">//获取属性名称</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name = property_getName(property);</span><br><span class="line">	<span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *propertyAttributes = property_getAttributes(property);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%s  %s"</span>, propertyName, propertyAttributes);</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	objc_property_attribute_t *attrbutes = property_copyAttributeList(property, &amp;count);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; ++j) &#123;</span><br><span class="line">	objc_property_attribute_t attribute = attrbutes[j];</span><br><span class="line">     </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name = attribute.name;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *value = attribute.value;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"name: %s   value: %s"</span>, name, value);</span><br><span class="line">   		&#125;</span><br><span class="line">   </span><br><span class="line">   	free(attrbutes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历方法">遍历方法</h2>

<ol>
<li>使用 class_copyMethodList 方法获取当前 Model 的所有成员变量.</li>
<li>使用 method_getName 方法获取成员变量的名称.</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   Method *methods = class_copyMethodList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       Method method = methods[i];</span><br><span class="line"><span class="comment">//获取方法</span></span><br><span class="line">SEL methodSEL = method_getName(method);</span><br><span class="line">       	<span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(methodSEL);</span><br><span class="line">       	<span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"><span class="comment">//获取方法的参数个数</span></span><br><span class="line"><span class="keyword">int</span> arguments = method_getNumberOfArguments(method);</span><br><span class="line"><span class="comment">// 获取方法的参数类型</span></span><br><span class="line"><span class="keyword">char</span> argName[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arguments; ++j) &#123;</span><br><span class="line">	method_getArgumentType(method, j, argName, <span class="number">512</span>);</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"第%u个参数类型为：%s"</span>, j, argName);</span><br><span class="line">	memset(argName, <span class="string">'\0'</span>, strlen(argName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> returnType[<span class="number">512</span>] = &#123;&#125;;</span><br><span class="line">   	method_getReturnType(method, returnType, <span class="number">512</span>);</span><br><span class="line">   	<span class="built_in">NSLog</span>(<span class="string">@"返回值类型：%s"</span>, returnType);</span><br><span class="line">   </span><br><span class="line">   	<span class="comment">// type encoding</span></span><br><span class="line">   	<span class="built_in">NSLog</span>(<span class="string">@"TypeEncoding: %s"</span>, method_getTypeEncoding(method));</span><br><span class="line">   	</span><br><span class="line">   &#125;</span><br><span class="line">   free(methods);</span><br></pre></td></tr></table></figure>
<h3 id="动态交换方法"><a href="#动态交换方法" class="headerlink" title="动态交换方法"></a>动态交换方法</h3><ol>
<li><code>Method class_getInstanceMethod(Class cls, SEL name)</code> 找到方法实例</li>
<li><code>void method_exchangeImplementations(Method m1, Method m2)</code> 交换方法</li>
</ol>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)answer&#123;</span><br><span class="line">Method m1 = class_getInstanceMethod([<span class="keyword">self</span>.xiaoMing <span class="keyword">class</span>], <span class="keyword">@selector</span>(firstSay));</span><br><span class="line">Method m2 = class_getInstanceMethod([<span class="keyword">self</span>.xiaoMing <span class="keyword">class</span>], <span class="keyword">@selector</span>(secondSay));</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(m1, m2);</span><br><span class="line"><span class="built_in">NSString</span> *secondName = [<span class="keyword">self</span>.xiaoMing firstSay];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.nameTf.text = secondName;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"XiaoMing:My name is %@"</span>,secondName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Method-Swizzling-原理"><a href="#Method-Swizzling-原理" class="headerlink" title="Method Swizzling 原理"></a>Method Swizzling 原理</h3><p>归根结底，都是偷换了selector的IMP</p>
<ul>
<li>method_exchangeImplementations 来交换2个方法中的IMP，</li>
<li>利用 class_replaceMethod 来修改类，</li>
<li>利用 method_setImplementation 来直接设置某个方法的IMP</li>
</ul>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><ol>
<li><code>void class_addMethods(Class, struct objc_method_list *)</code>添加多个方法</li>
<li><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code>添加方法<ul>
<li>(IMP)guessAnswer 意思是guessAnswer的地址指针;</li>
<li>“v@:” 意思是，v代表无返回值void，如果是i则代表int；@代表 id sel; : 代表 SEL _cmd;“v@:@@” 意思是，两个参数的没有返回值。</li>
</ul>
</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<p>假设XiaoMing的中没有guess这个方法，后来被Runtime添加一个名字叫guess的方法，最终再调用guess方法做出相应。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)answer&#123;</span><br><span class="line">class_addMethod([<span class="keyword">self</span>.xiaoMing <span class="keyword">class</span>], <span class="keyword">@selector</span>(guess), (IMP)guessAnswer, <span class="string">"v@:"</span>);</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.xiaoMing respondsToSelector:<span class="keyword">@selector</span>(guess)]) &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.xiaoMing performSelector:<span class="keyword">@selector</span>(guess)];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Sorry,I don't know"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.cityTf.text = <span class="string">@"GuangTong"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> guessAnswer(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"He is from GuangTong"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<pre><code>`[self.xiaoMing performSelector:@selector(guess)];`
</code></pre><h2 id="遍历协议"><a href="#遍历协议" class="headerlink" title="遍历协议"></a>遍历协议</h2><ol>
<li>使用 class_copyProtocolList 方法获取当前 Model 的所有成员变量.</li>
<li>使用 protocol_getName 方法获取成员变量的名称.</li>
</ol>
<blockquote>
<p>示例：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">   _<span class="keyword">unsafe_unretained</span> Protocol **protocols = class_copyProtocolList([obj <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">       Protocol *protocol = protocols[i];</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> *name = protocol_getName(protocol);</span><br><span class="line">       <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<!-- *    [Runtime全方位装逼指南](http://www.jianshu.com/p/efeb33712445)
*    [谈Runtime机制和使用的整体化梳理](http://www.jianshu.com/p/8916ad5662a2)
* [runtime属性与成员变量](http://www.henishuo.com/runtime-property-ivar/) -->]]></content>
      <categories>
        <category>重学iOS</category>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-叁</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-%E5%8F%81/</url>
    <content><![CDATA[<p>在<a href="../SDWebImage375源码-贰/">SDWebImage3.7.5源码阅读二</a>中看完后，已经知道SDWebImageCombinedOperation类的在cacheOperation搜索完缓存之后：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//一大串 options的操作 暂时不管它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//终于见到了下载操作！</span></span><br><span class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>其中<code>self.imageDownloader</code>也是SDWebImageManager init的时候生成的，是<code>SDWebImageDownloader</code>对象，跳转到<code>downloadImageWithURL</code>中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line"></span><br><span class="line">__block SDWebImageDownloaderOperation *operation;</span><br><span class="line">   __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">   </span><br><span class="line">[<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成对应的URL</span></span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//下载进度 下载完成 取消等操作</span></span><br><span class="line">operation = [[wself.operationClass alloc] initWithRequest ...</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//开始下载</span></span><br><span class="line">[wself.downloadQueue addOperation:operation];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查看<code>SDWebImageDownloaderOperation</code> 可以看到下载实现是靠 <code>NSURLConnection</code>完成的，下载进度什么的当然就是<code>NSURLConnectionDataDelegate</code>里完成的。</p>
<p>图片下载完后有个decode操作：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">image = [<span class="built_in">UIImage</span> decodedImageWithImage:image];</span><br></pre></td></tr></table></figure>
<p>到这里整理一下主要的流程：</p>
<p><img src="/res/SDWebImage/sdwebimg.png" alt></p>
<ol>
<li>入口 setImageWithURL:placeholderImage:options: 会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</li>
<li>进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:key done:.</li>
<li>先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存 SDWebImageQueryCompletedBlock 块返回图片 到前端展示图片。</li>
<li>如果内存缓存中没有，GCD 异步开始从硬盘查找图片是否已经缓存。</li>
<li>根据 URLKey 在硬盘缓存目录下尝试读取图片文件。 完成后在SDWebImageQueryCompletedBlock回调</li>
<li>如果上一操作从硬盘读取到了图片，图片可能先缩放再转码，将图片添加到内存缓存中</li>
<li>如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，<br>共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</li>
<li>图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<ul>
<li>connection:didReceiveData: 中利用 SDWebImageQueryCompletedBlock 做了按图片下载进度加载效果。</li>
<li>connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</li>
</ul>
</li>
<li>下载完成后有缓存，交给 SDWebImageDecoder 做图片解码操作。</li>
</ol>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-壹</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-%E5%A3%B9/</url>
    <content><![CDATA[<h3 id="0-图片的异步下载"><a href="#0-图片的异步下载" class="headerlink" title="0. 图片的异步下载"></a>0. 图片的异步下载</h3><p>比如在tableview中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">   </span><br><span class="line">   static NSString* cellID  = @&quot;cellID&quot;;</span><br><span class="line">   </span><br><span class="line">   UITableViewCell* cell = [tableView dequeueReusableCellWithIdentifier:cellID];</span><br><span class="line">   if (cell == nil) &#123;</span><br><span class="line">       cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellID];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;] placeholderImage:[UIImage imageNamed:@&quot;1.jpg&quot;]];</span><br><span class="line">   cell.textLabel.text = @&quot; text &quot;;</span><br><span class="line">   </span><br><span class="line">   return cell;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>他这里相关的代码就是调用了<code>UIImageView+WebCache</code>这个分类中的 <code>sd_setImageWithURL:placeholderImage:</code>方法</p>
<h2 id="1-开始看代码"><a href="#1-开始看代码" class="headerlink" title="1. 开始看代码"></a>1. 开始看代码</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder &#123;</span><br><span class="line">   [<span class="keyword">self</span> sd_setImageWithURL:url placeholderImage:placeholder options:<span class="number">0</span> progress:<span class="literal">nil</span> completed:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现原先方法调用了另一个参数更多的方法 <code>sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil</code></p>
<p>其中url是图片的url地址，placeholderImag是占位图，options是某个选项？，progress是进度completed肯定就是完成后的操作块</p>
<blockquote>
<p>问题1 ： 其中options:0 这个options值是具体是什么</p>
</blockquote>
<h3 id="1-1-SDWebImageOptions具体内容"><a href="#1-1-SDWebImageOptions具体内容" class="headerlink" title="1.1 SDWebImageOptions具体内容"></a>1.1 <code>SDWebImageOptions</code>具体内容</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</span><br><span class="line">   <span class="comment">//默认情况下 url下载失败，url会被移入黑名单</span></span><br><span class="line">   <span class="comment">//这个flag将url从黑名单中移除</span></span><br><span class="line">   <span class="comment">//简单来说就是失败后重新下载</span></span><br><span class="line">   SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认图片下载在UI交互的时候开始</span></span><br><span class="line">    <span class="comment">//延迟下载</span></span><br><span class="line">   SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//只进行内存缓存</span></span><br><span class="line">   SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认图片只会在完全下载完显示</span></span><br><span class="line">    <span class="comment">//这个flag可以使图片渐进式下载，图片也会逐步显示</span></span><br><span class="line">   SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//刷新缓存</span></span><br><span class="line">   SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//后台下载</span></span><br><span class="line">   SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">   SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许使用无效的SSL证书</span></span><br><span class="line">   SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment">//有限加载</span></span><br><span class="line">   SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//延迟占位图</span></span><br><span class="line">   SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">   SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//图片下载后 手动加载图片</span></span><br><span class="line">   SDWebImageAvoidAutoSetImage = <span class="number">1</span> &lt;&lt; <span class="number">11</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里options使用0，表示不使用任何选项 </p>
<h2 id="2-sd-setImageWithURL具体实现："><a href="#2-sd-setImageWithURL具体实现：" class="headerlink" title="2. sd_setImageWithURL具体实现："></a>2. <code>sd_setImageWithURL</code>具体实现：</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//看名字猜测是取消当前图片加载（任务） </span></span><br><span class="line">   [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用placeholder图片先占位</span></span><br><span class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">       dispatch_main_async_safe(^&#123;</span><br><span class="line">           <span class="keyword">self</span>.image = placeholder;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//这里就应该是主要的方法 下载图片了</span></span><br><span class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            ...</span><br><span class="line">                   wself.image = image;</span><br><span class="line">                   ...</span><br><span class="line">       &#125;];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//看名字猜测将这个图片下载任务以UIImageViewImageLoad作为关键字储存起来</span></span><br><span class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">       </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-先看-self-sd-cancelCurrentImageLoad-，"><a href="#2-1-先看-self-sd-cancelCurrentImageLoad-，" class="headerlink" title="2.1 先看[self sd_cancelCurrentImageLoad]，"></a>2.1 先看<code>[self sd_cancelCurrentImageLoad]</code>，</h3><p>它是调用了以下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	- (<span class="keyword">void</span>)sd_cancelCurrentImageLoad &#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">`sd_cancelImageLoadOperationWithKey`这个方法在 `<span class="built_in">UIView</span>+WebCacheOperation`这个分类中：</span><br><span class="line">	</span><br><span class="line">	- (<span class="keyword">void</span>)sd_cancelImageLoadOperationWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">// Cancel in progress downloader from queue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//会将operation 都储存在operationDictionary？</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出key对应的operation(s) ，并执行cancel操作，然后将operation(s)从operationDictionary中删除</span></span><br><span class="line">    <span class="keyword">id</span> operations = [operationDictionary objectForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (operations) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([operations isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation <span class="keyword">in</span> operations) &#123;</span><br><span class="line">                <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([operations conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)])</span>&#123;</span><br><span class="line">            [(<span class="keyword">id</span>&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>也就是将key为UIImageViewImageLoad的操作都执行cancel操作，最后将key对应的对象全部从operationDictionary中删除</p>
<blockquote>
<p>看到这里有几个问题</p>
</blockquote>
<blockquote>
<p>UIImageViewImageLoad对应的操作是图片正在下载中，还是下载完呢？应该是下载完的操作，因为要是下载中操作都被取消并从operationDictionary中移除，图片也下不成功了。但是要是对应下载完，operation已经被移除，它是依据什么做到同一url不重复下载？？url（或者ur对应的特征码）不储存在operation（但是SDWebImageOperation只是一个协议 只声明了cancel操作）中吗？还有operationDictionary的内部储存数据的结构是什么？怎么一个key又可能是数组有可能是单个对象，这样做不是麻烦一点吗？全改成一个key对应一个operation数组不是更方便？所以问题就这几个：</p>
</blockquote>
<ul>
<li><p>问题2:UIImageViewImageLoad对应的是什么操作</p>
</li>
<li><p>问题3:operation的实现（SDWebImageOperation中的cancel方法实现 和 内部的属性等）</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImageOperation</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>问题4：不重复下载相同url 是根据operation做的，还是根据其他对象实现的</p>
</li>
<li><p>问题5：operationDictionary的内部储存数据（能存什么key，key对应的对象是数组还是其他）</p>
<ul>
<li>目前知道有个key 为UIImageViewImageLoad ，看代码猜测当Operation数量为多个时，key对应的是<code>NSArray&lt;SDWebImageOperation*&gt;</code> 对象，当数量为单个时key对应的是 <code>SDWebImageOperation*</code>对象（或者是考虑到兼容问题？）</li>
</ul>
</li>
</ul>
<p>感觉这几个问题都可以在下载的具体步骤中解决掉。。</p>
<h3 id="2-2-接下来看-dispatch-main-async-safe"><a href="#2-2-接下来看-dispatch-main-async-safe" class="headerlink" title="2.2 接下来看 dispatch_main_async_safe"></a>2.2 接下来看 <code>dispatch_main_async_safe</code></h3><p>它的实现就是一个宏：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></span><br><span class="line">   <span class="keyword">if</span> ([<span class="built_in">NSThread</span> isMainThread]) &#123;\</span><br><span class="line">       block();\</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个我有个蠢问题，为什么要这么做？？就算是已经在主线程 但是再执行dispatch_async(dispatch_get_main_queue(), block)也不会错吧？？虽然是会感觉多此一举，但是这样做其他的影响呢，会影响性能吗。。    </p>
</blockquote>
<h3 id="2-3-self-showActivityIndicatorView"><a href="#2-3-self-showActivityIndicatorView" class="headerlink" title="2.3 [self showActivityIndicatorView]"></a>2.3 <code>[self showActivityIndicatorView]</code></h3><p>我加上 [cell.imageView setShowActivityIndicatorView:true];也没有看到等待指示器。。是网速太快了还是需要其他设置。。不管了</p>
<h3 id="2-4-self-sd-setImageLoadOperation-operation-forKey-quot-UIImageViewImageLoad-quot"><a href="#2-4-self-sd-setImageLoadOperation-operation-forKey-quot-UIImageViewImageLoad-quot" class="headerlink" title="2.4 [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];"></a>2.4 <code>[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</code></h3><p>看下它的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageLoadOperation:(<span class="keyword">id</span>)operation forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">   <span class="built_in">NSMutableDictionary</span> *operationDictionary = [<span class="keyword">self</span> operationDictionary];</span><br><span class="line">   [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将Operation以key为 UIImageViewImageLoad 存入operationDictionary，而这时Operation对应的下载肯定是异步的，所以UIImageViewImageLoad对应的是图片正在下载中的操作。</p>
<ul>
<li>回答问题2：UIImageViewImageLoad对应的是图片正在下载中的操作。</li>
<li>回答问题5（部分）：operationDictionary中以 key-operation 方式储存（key-nsarray方式暂时没看到）</li>
</ul>
<p>若是当第一个图片没下载完，第二图片下载任务进来不就取消之前所有的UIImageViewImageLoad的operation了？？那之前的图片怎么下载完？难道cancel之后会自动resume吗？</p>
<ul>
<li>问题6：UIImageViewImageLoad的operation执行 cancel后，在哪里会继续下载？</li>
</ul>
<h2 id="3-接下来就是内容最多的下载功能了"><a href="#3-接下来就是内容最多的下载功能了" class="headerlink" title="3 接下来就是内容最多的下载功能了"></a>3 接下来就是内容最多的下载功能了</h2><p><code>[SDWebImageManager.sharedManager downloadImageWithURL: l options:  progress:  completed:</code></p>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-缓存机制</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>存 取 删 路径</p>
</blockquote>
<h2 id="1-1-存"><a href="#1-1-存" class="headerlink" title="1.1 存"></a>1.1 存</h2><p>是在storeImage这个方法里：</p>
<p>将图片储存到内存和硬盘上</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk &#123;</span><br><span class="line">   <span class="keyword">if</span> (!image || !key) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// if memory cache is enabled</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">       <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</span><br><span class="line">       [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">       <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">           <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line">           <span class="comment">// 如果image存在，但是需要重新计算(recalculate)或者data为空</span></span><br><span class="line">           <span class="comment">// 那就要根据image重新生成新的data</span></span><br><span class="line">           <span class="comment">// 不过要是连image也为空的话，那就别存了</span></span><br><span class="line">           <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="meta">#if TARGET_OS_IPHONE</span></span><br><span class="line">               <span class="comment">// 我们需要判断image是PNG还是JPEG</span></span><br><span class="line">               <span class="comment">// PNG的图片很容易检测出来，因为它们有一个特定的标示 (http://www.w3.org/TR/PNG-Structure.html)</span></span><br><span class="line">               <span class="comment">// PNG图片的前8个字节不许符合下面这些值(十进制表示)</span></span><br><span class="line">               <span class="comment">// 137 80 78 71 13 10 26 10</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 如果imageData为空l (举个例子，比如image在下载后需要transform，那么就imageData就会为空)</span></span><br><span class="line">               <span class="comment">// 并且image有一个alpha通道, 我们将该image看做PNG以避免透明度(alpha)的丢失（因为JPEG没有透明色）</span></span><br><span class="line">               <span class="keyword">int</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(image.CGImage);<span class="comment">// 获取image中的透明信息</span></span><br><span class="line">               <span class="comment">// 该image中确实有透明信息，就认为image为PNG</span></span><br><span class="line">               <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                                 alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                                 alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">               <span class="built_in">BOOL</span> imageIsPng = hasAlpha;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 但是如果我们已经有了imageData，我们就可以直接根据data中前几个字节判断是不是PNG</span></span><br><span class="line">               <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                   <span class="comment">// ImageDataHasPNGPreffix就是为了判断imageData前8个字节是不是符合PNG标志</span></span><br><span class="line">                   imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果image是PNG格式，就是用UIImagePNGRepresentation将其转化为NSData，否则按照JPEG格式转化，并且压缩质量为1，即无压缩</span></span><br><span class="line">               <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">                   data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">               &#125;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">               <span class="comment">// 当然，如果不是在iPhone平台上，就使用下面这个方法。不过不在我们研究范围之内</span></span><br><span class="line">               data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image.representations usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取到需要存储的data后，下面就要用fileManager进行存储了</span></span><br><span class="line">           <span class="keyword">if</span> (data) &#123;</span><br><span class="line">               <span class="comment">// 首先判断disk cache的文件路径是否存在，不存在的话就创建一个</span></span><br><span class="line">               <span class="comment">// disk cache的文件路径是存储在_diskCachePath中的</span></span><br><span class="line">               <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">                   [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据image的key(一般情况下理解为image的url)组合成最终的文件路径</span></span><br><span class="line">               <span class="comment">// 上面那个生成的文件路径只是一个文件目录，就跟/cache/images/img1.png和cache/images/的区别一样</span></span><br><span class="line">               <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</span><br><span class="line">               <span class="comment">// 这个url可不是网络端的url，而是file在系统路径下的url</span></span><br><span class="line">               <span class="comment">// 比如/foo/bar/baz --------&gt; file:///foo/bar/baz</span></span><br><span class="line">               <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据存储的路径(cachePathForKey)和存储的数据(data)将其存放到iOS的文件系统</span></span><br><span class="line">               [_fileManager createFileAtPath:cachePathForKey contents:data attributes:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">               <span class="comment">// disable iCloud backup</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDisableiCloud) &#123;</span><br><span class="line">                   [fileURL setResourceValue:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-取"><a href="#1-2-取" class="headerlink" title="1.2 取"></a>1.2 取</h3><p> 内存缓存使用NSCache的objectForKey取数据：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	- (<span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    	<span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</span><br><span class="line">	&#125;</span><br><span class="line">磁盘取数据 不断用 dataWithContentsOfFile来试数据是否在key对应的路径中</span><br><span class="line"></span><br><span class="line">	- (<span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check the in-memory cache...</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second check the disk cache...</span></span><br><span class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diskImage;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-删"><a href="#1-3-删" class="headerlink" title="1.3 删"></a>1.3 删</h3><ol>
<li>removeImageForKeyfromDisk:withCompletion: // 异步地将image从缓存(内存缓存以及可选的磁盘缓存)中移除</li>
<li>clearMemory // 清楚内存缓存上的所有image</li>
<li>clearDisk // 清除磁盘缓存上的所有image</li>
<li>cleanDisk // 清除磁盘缓存上过期的image</li>
</ol>
<p>看其中最长的一个：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 实现了一个简单的缓存清除策略：清除修改时间最早的file</span></span><br><span class="line">- (<span class="keyword">void</span>)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">   <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">       <span class="comment">// 这两个变量主要是为了下面生成NSDirectoryEnumerator准备的</span></span><br><span class="line">       <span class="comment">// 一个是记录遍历的文件目录，一个是记录遍历需要预先获取文件的哪些属性</span></span><br><span class="line">       <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</span><br><span class="line">       <span class="built_in">NSArray</span> *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 递归地遍历diskCachePath这个文件夹中的所有目录，此处不是直接使用diskCachePath，而是使用其生成的NSURL</span></span><br><span class="line">       <span class="comment">// 此处使用includingPropertiesForKeys:resourceKeys，这样每个file的resourceKeys对应的属性也会在遍历时预先获取到</span></span><br><span class="line">       <span class="comment">// NSDirectoryEnumerationSkipsHiddenFiles表示不遍历隐藏文件</span></span><br><span class="line">       <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                  includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                     options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></span><br><span class="line">                                                                errorHandler:<span class="literal">NULL</span>];</span><br><span class="line">       <span class="comment">// 获取文件的过期时间，SDWebImage中默认是一个星期</span></span><br><span class="line">       <span class="comment">// 不过这里虽然称*expirationDate为过期时间，但是实质上并不是这样。</span></span><br><span class="line">       <span class="comment">// 其实是这样的，比如在2015/12/12/00:00:00最后一次修改文件，对应的过期时间应该是</span></span><br><span class="line">       <span class="comment">// 2015/12/19/00:00:00，不过现在时间是2015/12/27/00:00:00，我先将当前时间减去1个星期，得到</span></span><br><span class="line">       <span class="comment">// 2015/12/20/00:00:00，这个时间才是我们函数中的expirationDate。</span></span><br><span class="line">       <span class="comment">// 用这个expirationDate和最后一次修改时间modificationDate比较看谁更晚就行。</span></span><br><span class="line">       <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.maxCacheAge];</span><br><span class="line">       <span class="comment">// 用来存储对应文件的一些属性，比如文件所需磁盘空间</span></span><br><span class="line">       <span class="built_in">NSMutableDictionary</span> *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">       <span class="comment">// 记录当前已经使用的磁盘缓存大小</span></span><br><span class="line">       <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 在缓存的目录开始遍历文件.  此次遍历有两个目的:</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">//  1. 移除过期的文件</span></span><br><span class="line">       <span class="comment">//  2. 同时存储每个文件的属性（比如该file是否是文件夹、该file所需磁盘大小，修改时间）</span></span><br><span class="line">       <span class="built_in">NSMutableArray</span> *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</span><br><span class="line">           <span class="built_in">NSDictionary</span> *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 当前扫描的是目录，就跳过</span></span><br><span class="line">           <span class="keyword">if</span> ([resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 移除过期文件</span></span><br><span class="line">           <span class="comment">// 这里判断过期的方式：对比文件的最后一次修改日期和expirationDate谁更晚，如果expirationDate更晚，就认为该文件已经过期，具体解释见上面</span></span><br><span class="line">           <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</span><br><span class="line">           <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">               [urlsToDelete addObject:fileURL];</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 计算当前已经使用的cache大小，</span></span><br><span class="line">           <span class="comment">// 并将对应file的属性存到cacheFiles中</span></span><br><span class="line">           <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">           currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">           [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</span><br><span class="line">           <span class="comment">// 根据需要移除文件的url来移除对应file</span></span><br><span class="line">           [_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果我们当前cache的大小已经超过了允许配置的缓存大小，那就删除已经缓存的文件。</span></span><br><span class="line">       <span class="comment">// 删除策略就是，首先删除修改时间更早的缓存文件</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">self</span>.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.maxCacheSize) &#123;</span><br><span class="line">           <span class="comment">// 直接将当前cache大小降到允许最大的cache大小的一般</span></span><br><span class="line">           <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.maxCacheSize / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 根据文件修改时间来给所有缓存文件排序，按照修改时间越早越在前的规则排序</span></span><br><span class="line">           <span class="built_in">NSArray</span> *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></span><br><span class="line">                                                           usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">                                                               <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</span><br><span class="line">                                                           &#125;];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 每次删除file后，就计算此时的cache的大小</span></span><br><span class="line">           <span class="comment">// 如果此时的cache大小已经降到期望的大小了，就停止删除文件了</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</span><br><span class="line">               <span class="keyword">if</span> ([_fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">                   <span class="comment">// 获取该文件对应的属性</span></span><br><span class="line">                   <span class="built_in">NSDictionary</span> *resourceValues = cacheFiles[fileURL];</span><br><span class="line">       <span class="comment">// 根据resourceValues获取该文件所需磁盘空间大小</span></span><br><span class="line">                   <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</span><br><span class="line">       <span class="comment">// 计算当前cache大小</span></span><br><span class="line">                   currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果有completionBlock，就在主线程中调用</span></span><br><span class="line">       <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               completionBlock();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-图片储存路径"><a href="#1-4-图片储存路径" class="headerlink" title="1.4 图片储存路径"></a>1.4 图片储存路径</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 简单封装了cachePathForKey:inPath</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   	<span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cachePathForKey:inPath</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cachePathForKey:(<span class="built_in">NSString</span> *)key inPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">   <span class="comment">// 根据传入的key创建最终要存储时的文件名</span></span><br><span class="line">   <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</span><br><span class="line">   <span class="comment">// 将存储的文件路径和文件名绑定在一起，作为最终的存储路径</span></span><br><span class="line">   <span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cachedFileNameForKey:</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *str = [key UTF8String];</span><br><span class="line">   <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       str = <span class="string">""</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用了MD5进行加密处理</span></span><br><span class="line">   <span class="comment">// 开辟一个16字节（128位：md5加密出来就是128bit）的空间</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">   <span class="comment">// 官方封装好的加密方法</span></span><br><span class="line">   <span class="comment">// 把str字符串转换成了32位的16进制数列（这个过程不可逆转） 存储到了r这个空间中</span></span><br><span class="line">   CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">   <span class="comment">// 最终生成的文件名就是 "md5码"+".文件类型"</span></span><br><span class="line">   <span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</span><br><span class="line">                         r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</span><br><span class="line">                         r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], [[key pathExtension] isEqualToString:<span class="string">@""</span>] ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, [key pathExtension]]];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> filename;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-贰</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-%E8%B4%B0/</url>
    <content><![CDATA[<h3 id="3-downloadImageWithURL下载方法的具体实现"><a href="#3-downloadImageWithURL下载方法的具体实现" class="headerlink" title="3. downloadImageWithURL下载方法的具体实现"></a>3. downloadImageWithURL下载方法的具体实现</h3><p>方法在SDWebImageManager.m中</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url 	</span><br><span class="line">	options:(SDWebImageOptions)options </span><br><span class="line">	progress:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">	completed:(SDWebImageCompletionWithFinishedBlock)completedBlock</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数：    </p>
</blockquote>
<ul>
<li>url</li>
<li>options<ul>
<li>之前已经介绍了 SDWebImageOptions</li>
</ul>
</li>
<li><p>progressBlock</p>
<ul>
<li>SDWebImageDownloaderProgressBlock 定义在 SDWebImageDownloader.h 中具体实现为：   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从名字可以看出来第一个参数是已经接受了数据的大小</span></span><br><span class="line"><span class="comment">//另一个参数表示总数据的大小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageDownloaderProgressBlock)(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>completedBlock</p>
<ul>
<li>图片下载完要做的块 具体实现为：                   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">		</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SDWebImageCompletionWithFinishedBlock)(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>然后一看这个方法实现……麻蛋 好长！    </p>
<a id="more"></a>
<h3 id="3-1-一些判断"><a href="#3-1-一些判断" class="headerlink" title="3.1 一些判断"></a>3.1 一些判断</h3><p>这个没什么好说的</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">    url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</span><br><span class="line">    url = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-SDWebImageCombinedOperation"><a href="#3-2-SDWebImageCombinedOperation" class="headerlink" title="3.2 SDWebImageCombinedOperation"></a>3.2 <code>SDWebImageCombinedOperation</code></h3><p>下来看到了一个类 SDWebImageCombinedOperation</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">__block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">   __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</span><br></pre></td></tr></table></figure>
<p>它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//头</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) SDWebImageNoParamsBlock cancelBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperation</span> *cacheOperation;</span><br><span class="line"><span class="keyword">@end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageCombinedOperation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCancelBlock:(SDWebImageNoParamsBlock)cancelBlock &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">       <span class="keyword">if</span> (cancelBlock) &#123;</span><br><span class="line">           cancelBlock();</span><br><span class="line">       &#125;</span><br><span class="line">       _cancelBlock = <span class="literal">nil</span>; </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       _cancelBlock = [cancelBlock <span class="keyword">copy</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cacheOperation 对应的到底是 下载操作还是 缓存相关的操作。。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel &#123;</span><br><span class="line">   <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</span><br><span class="line">       [<span class="keyword">self</span>.cacheOperation cancel];</span><br><span class="line">       <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.cancelBlock) &#123;</span><br><span class="line">       <span class="keyword">self</span>.cancelBlock();</span><br><span class="line"></span><br><span class="line">       _cancelBlock = <span class="literal">nil</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>它实现了    SDWebImageOperation好歹是回答了之前的问题3</p>
<ul>
<li>回答问题3（部分）：SDWebImageOperation的实现之一是SDWebImageCombinedOperation</li>
</ul>
<p>但是这个cacheOperation 命名令我很困惑。。因为到现在还不知道下载操作会放在那里。。</p>
<ul>
<li>问题7 ： SDWebImageCombinedOperation的cacheOperation执行什么操作</li>
</ul>
<p>然后它的属性cancelBlock是 长这样的 <code>typedef void(^SDWebImageNoParamsBlock)();</code>好像没什么用的样子。。</p>
<h3 id="3-3-isFailedUrl"><a href="#3-3-isFailedUrl" class="headerlink" title="3.3 isFailedUrl"></a>3.3 <code>isFailedUrl</code></h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//判断是否是已经下载失败的url</span></span><br><span class="line"><span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">   <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">       isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//当url是失败过的url并且options不是SDWebImageRetryFailed 时直接报错    </span></span><br><span class="line">   <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">       dispatch_main_sync_safe(^&#123;</span><br><span class="line">           <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">           completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">return</span> operation;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里 终于解决了之前的第四个问题，failedURLs就储存了失效的url，也就是依据这个做出不重复下载的功能</p>
<ul>
<li>回答问题4： 不重复下载相同url 是根据SDWebImageManager.failedURLs来实现的</li>
</ul>
<p>看到这里 还没有看见下载的功能。。判断了这么多条件 真是值得学习啊。。</p>
<h3 id="3-4-储存operation，生成cacheOperation实例"><a href="#3-4-储存operation，生成cacheOperation实例" class="headerlink" title="3.4 储存operation，生成cacheOperation实例"></a>3.4 储存operation，生成cacheOperation实例</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将之前生成的 SDWebImageCombinedOperation *operation</span></span><br><span class="line"><span class="comment">//存入 runningOperations</span></span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">	[<span class="keyword">self</span>.runningOperations addObject:operation];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>之前不是猜测 SDWebImageCombinedOperation中的 cacheOperation是缓存还是下载的操作吗，到这里就可以猜出来，应该是缓存和下载操作都有，因为要是只是缓存操作的话，这个操作不会进行很久，一般也不需要储存起来管理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//应该是生成图片缓存路径对应的key</span></span><br><span class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br></pre></td></tr></table></figure>
<p>来看看它的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.cacheKeyFilter) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">self</span>.cacheKeyFilter(url);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> [url absoluteString];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中    cacheKeyFilter是过滤url用的，它是个SDWebImageCacheKeyFilterBlock块，作者注解中写的很清楚了，它可以用来删除url中动态生成的部分，比如一些“？”之后的参数什么的，但是我没用到，这里就不讨论如何自定义这个SDWebImageCacheKeyFilterBlock块了。</p>
<p>接下来看吧：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//一大串 块内容，</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> operation;</span><br></pre></td></tr></table></figure>
<p>这里终于要开始实现cacheoperation了。。</p>
<p>其中self.imageCache 是在init方法中生成的 就是生成一个SDImageCache的单例：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (SDImageCache *)createCache &#123;</span><br><span class="line">   	<span class="keyword">return</span> [SDImageCache sharedImageCache];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看<code>queryDiskCacheForKey:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在内存中查看是否存在</span></span><br><span class="line">   <span class="comment">//其实就是在NSCache类的一个memCache对象中查找</span></span><br><span class="line">   <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">   <span class="keyword">if</span> (image) &#123;</span><br><span class="line">       doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">   <span class="comment">//ioQueue就是SDImageCache初始化时生成一个GCD并行队列</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</span><br><span class="line">       <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//在本地中查看图片是否存在</span></span><br><span class="line">       <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">           <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">           <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.shouldCacheImagesInMemory) &#123;</span><br><span class="line">               <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</span><br><span class="line">               [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我这流程中 图片是第一次下载的，所以就按着 内存和本地中都找不到流程走。</p>
<p>看到这里，有点奇怪为什么这里要加autorealeasepool，看了下资料，说是可以优化内存。</p>
<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">autorealeasepool机制参考链接</a></p>
<p><a href="http://tutuge.me/2015/03/17/what-is-autoreleasepool/" target="_blank" rel="noopener">autorealeasepool机制参考链接2</a></p>
<h3 id="3-5-关于SDWebImageManager的单例（流程之外）"><a href="#3-5-关于SDWebImageManager的单例（流程之外）" class="headerlink" title="3.5 关于SDWebImageManager的单例（流程之外）"></a>3.5 关于SDWebImageManager的单例（流程之外）</h3><p>一开始看见它的单例是这么写，这不一看就知道不是严格的单例吗</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)sharedManager &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">id</span> instance;</span><br><span class="line">   <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">       instance = [<span class="keyword">self</span> new];</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">   <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我还以为是用了什么高级的Runtime使创建出来的对象严格保持单例，结果实验了一下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> SDWebImageManager* m1 = [SDWebImageManager sharedManager];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@" m1 :%@  "</span>,m1);</span><br><span class="line"></span><br><span class="line">SDWebImageManager* m2 = [[SDWebImageManager alloc]init];</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@" m2 :%@  "</span>,m2);</span><br></pre></td></tr></table></figure>
<p>打印出来：</p>
<pre><code class="objc">sdwebImageTest[<span class="number">4350</span>:<span class="number">1125408</span>]  m1 :&lt;SDWebImageManager: <span class="number">0x17550510</span>&gt;  
 sdwebImageTest[<span class="number">4350</span>:<span class="number">1125408</span>]  m2 :&lt;SDWebImageManager: <span class="number">0x175537e0</span>&gt;
</code></pre>
<p>摔！这不就是《只要你确保只调用sharedManager就确保单例》的做法吗。。作者开心就好。。反正里面的单例模式大家都只调用默认的sharedManager方法就不会错。。</p>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage375源码-简介</title>
    <url>/essay/SDWebImage/SDWebImage375%E6%BA%90%E7%A0%81-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="SDWebImage-3-7-5简介"><a href="#SDWebImage-3-7-5简介" class="headerlink" title="SDWebImage 3.7.5简介"></a>SDWebImage 3.7.5简介</h2><p>github地址： <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">https://github.com/rs/SDWebImage</a></p>
<blockquote>
<p>功能</p>
</blockquote>
<ul>
<li>异步图片下载</li>
<li>异步图片缓存</li>
<li>GIF支持</li>
<li>WebP图片格式支持</li>
<li>后台图片解析</li>
<li>相同URL不会被多次下载</li>
<li>无效URL不会多次尝试链接</li>
</ul>
<a id="more"></a> 
<h2 id="TableView加载图片使用UIImageView-WebCache分类"><a href="#TableView加载图片使用UIImageView-WebCache分类" class="headerlink" title="TableView加载图片使用UIImageView+WebCache分类"></a>TableView加载图片使用UIImageView+WebCache分类</h2><ol>
<li>添加UIImageView+WebCache.h头文件</li>
<li>在tableView的数据源方法tableView:cellForRowAtIndexPath: 中调用sd_setImageWithURL:placeholderImage:方法</li>
</ol>
<p>示例：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line">   <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">       cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></span><br><span class="line">                                      reuseIdentifier:MyIdentifier] autorelease];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></span><br><span class="line">   [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"My Text"</span>;</span><br><span class="line">   <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Blocks"><a href="#使用Blocks" class="headerlink" title="使用Blocks"></a>使用Blocks</h2><p>使用block，你将能够得到图片的下载进度并获知图片是否下载成功或者失败：</p>
<blockquote>
<p>注意：如果图像请求在完成前被取消了，那么成功和失败的block块将都不会被调用。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Here we use the new provided sd_setImageWithURL: method to load the web image</span></span><br><span class="line">[cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                     placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]</span><br><span class="line">                            completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">                               ... completion code here ...</span><br><span class="line">                            &#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用SDWebImageManager"><a href="#使用SDWebImageManager" class="headerlink" title="使用SDWebImageManager"></a>使用SDWebImageManager</h2><blockquote>
<p>UIImageView+WebCache分类背后调用的是SDWebImageManager类的方法，负责图像的异步下载和缓存处理。你可以直接使用这个类来下载图片和进行缓存处理。</p>
</blockquote>
<p>这有一个如何使用SDWebImageManager的简单示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SDWebImageManager *manager = [SDWebImageManager sharedManager];</span><br><span class="line">[manager downloadImageWithURL:imageURL</span><br><span class="line">                     options:<span class="number">0</span></span><br><span class="line">                    progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</span><br><span class="line">                        <span class="comment">// progression tracking code</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                            <span class="comment">// do something with image</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="单独异步下载图片"><a href="#单独异步下载图片" class="headerlink" title="单独异步下载图片"></a>单独异步下载图片</h2><p>它也可以独立使用异步图片下载：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">[downloader downloadImageWithURL:imageURL</span><br><span class="line">                        options:<span class="number">0</span></span><br><span class="line">                       progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</span><br><span class="line">                           <span class="comment">// progression tracking code</span></span><br><span class="line">                       &#125;</span><br><span class="line">                      completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (image &amp;&amp; finished) &#123;</span><br><span class="line">                               <span class="comment">// do something with image</span></span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="单独异步缓存图片"><a href="#单独异步缓存图片" class="headerlink" title="单独异步缓存图片"></a>单独异步缓存图片</h2><p>也可以单独使用基于图像的高速异步缓存处理。SDImagecache提供内存高速缓存和可选的磁盘高速缓存。磁盘高速缓存写入操作是异步的，所以不需要在用户界面添加不必要的延迟。</p>
<p>为了方便，SDImageCache类提供了一个单一的实例，但如果你想自定义缓存空间，那么可以创建自己的实例。</p>
<p>您可以使用queryDiskCacheForKey：done：方法查找缓存。如果该方法返回nil，则说明当前image没有缓存。你需要负责下载和进行缓存处理。图像缓存的key通常为该图像的URL。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:<span class="string">@"myNamespace"</span>];</span><br><span class="line">[imageCache queryDiskCacheForKey:myCacheKey done:^(<span class="built_in">UIImage</span> *image) &#123;</span><br><span class="line">   <span class="comment">// image is not nil if image was found</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果对应图片的内存缓存不存在，那么SDImageCache将查找磁盘缓存。可以通过调用imageFromMemoryCacheForKey：方法来阻止。</p>
<p>你可以调用storeImage:forKey: method:方法保存图片到缓存。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，图像将被进行内存缓存和磁盘缓存（异步）。如果你只想要内存缓存，那么可以使用storeImage:forKey:toDisk:方法，第三个参数传NO即可。</p>
<h2 id="使用缓存key筛选器"><a href="#使用缓存key筛选器" class="headerlink" title="使用缓存key筛选器"></a>使用缓存key筛选器</h2><p>有时，你可能会因为URL的一部分是动态的而不希望使用URL作为图像缓存的key。 SDWebImageManager提供了一种方式来设置，输入URL输出对应的字符串。<br>下面的示例在应用程序的委托中设置一个过滤器，在使用它的缓存键之前将从URL中删除任何查询字符串</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">   SDWebImageManager.sharedManager.cacheKeyFilter = ^(<span class="built_in">NSURL</span> *url) &#123;</span><br><span class="line">       url = [[<span class="built_in">NSURL</span> alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">       <span class="keyword">return</span> [url absoluteString];</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Your app init code...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用动态图像大小的UITableViewCell"><a href="#使用动态图像大小的UITableViewCell" class="headerlink" title="使用动态图像大小的UITableViewCell"></a>使用动态图像大小的UITableViewCell</h2><p>UITableViewCell通过第一个单元格设置的图像决定图像的尺寸。如果你加载的网络图片和占位符图像尺寸不一致，那么您可能会遇到奇怪的变形比例问题。下面的文章给出了解决此问题的方法：</p>
<p><a href="http://www.wrichards.com/blog/2011/11/sdwebimage-fixed-width-cell-images/" target="_blank" rel="noopener">sdwebimage-fixed-width-cell-images</a></p>
<h2 id="处理图像刷新"><a href="#处理图像刷新" class="headerlink" title="处理图像刷新"></a>处理图像刷新</h2><p>SDWebimage默认情况下做了很好的缓存处理。它忽略通过HTTP服务器返回的所有类型的缓存控制头，并且没有时间限制地缓存返回的图像<br>它意味着你的url指向的图片是一成不变的。更好的做法是如果url指向的图片发生了改变，那么图片也应该变化。<br>在这种情况下，你可以使用SDWebImageRefreshCached标志。这将略微降低性能，但会尊重HTTP缓存控制头：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://graph.facebook.com/olivier.poitrey/picture"</span>]</span><br><span class="line">                placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"avatar-placeholder.png"</span>]</span><br><span class="line">                         options:SDWebImageRefreshCached];</span><br></pre></td></tr></table></figure>
<h2 id="添加进度指示器"><a href="#添加进度指示器" class="headerlink" title="添加进度指示器"></a>添加进度指示器</h2><p>参考：<a href="https://github.com/JJSaccolo/UIActivityIndicator-for-SDWebImage" target="_blank" rel="noopener">UIActivityIndicator-for-SDWebImage</a></p>
]]></content>
      <categories>
        <category>essay</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel入门教程</title>
    <url>/quick-start/Babel%E6%95%99%E7%A8%8B/Babel%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>大家都知道js十分依赖浏览器（或Node环境），不同浏览器对js的支持不尽相同。现如今ECMAScrip标准的更新已经到了一年一次的节奏，<br>Babel 就是为了解决这个问题 ，它可以将使用新标准的JavaScript代码转换为浏览器支持可以运行的JavsScript(ES5)代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如babel将这段代码</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> n ** <span class="number">2</span>);</span><br><span class="line"><span class="comment">//转换为：</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="在webpack中配置Babel"><a href="#在webpack中配置Babel" class="headerlink" title="在webpack中配置Babel"></a>在webpack中配置Babel</h2><blockquote>
<p>假设在react项目配置webpack:</p>
</blockquote>
<p><strong>一、安装npm包：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015 babel-preset-react webpack-preset-babel-stage-0</span><br></pre></td></tr></table></figure>
<p><strong>二、在webpack配置文件中添加规则：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">"babel-loader"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>三、 在项目根目录创建名为<code>.babelrc</code>的文件，这是Babel的配置文件 </strong></p>
<p>在配置文件中安装插件（plugins）或预设（presets，也就是一组插件）来指示 Babel 去做什么事情。在下面配置中：</p>
<p><em>babel-preset-es2015</em> 打包了 es6 的特性；<br><em>babel-preset-stage-0</em> 打包处于 strawman 阶段的语法；<br><em>babel-preset-react</em> 打包react全家桶语法；</p>
<p>Babel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。例如： Promise、Set、Map 等新增对象，Object.assign、Object.entries等静态方法，<em>babel-plugin-transform-runtime</em>为了达成使用这些新API。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.babelrc内容</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"stage-0"</span>, <span class="string">"react"</span>],</span><br><span class="line">	<span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Babel模块"><a href="#Babel模块" class="headerlink" title="Babel模块"></a>Babel模块</h2><a id="more"></a>
<p>Babel6.0后将功能划分成了不同的模块，在 <a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">Babel packages</a> 仓库看到babel现在有哪些模块：</p>
<p><img src="/res/Babel/babel_1.png" alt></p>
<h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><blockquote>
<p>参考 <a href="https://babeljs.io/docs/en/next/babel-core" target="_blank" rel="noopener">babel-core doc</a></p>
</blockquote>
<p>babel-core是作为babel的核心存在，babel的核心api都在这个模块里面。babel-core把 js 代码分析成 ast ，方便各个插件分析语法进行相应的处理。有些新语法在低版本 js 中是不存在的，如箭头函数，rest 参数，函数默认值等，这种语言层面的不兼容只能通过将代码转为 ast，分析其语法后再转为低版本 js。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// npm install babel-core</span></span><br><span class="line"><span class="comment">// var babel = require("babel-core");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//babel.transform(code: string, options?: Object, callback: Function)</span></span><br><span class="line"><span class="comment">//字符串形式的 JavaScript 代码可以直接使用 babel.transform 来编译</span></span><br><span class="line">babel.transform(<span class="string">"code();"</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result.code;</span><br><span class="line">  result.map;</span><br><span class="line">  result.ast;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意 ：可以在options中指定 preset 和 plugin</span></span><br><span class="line"><span class="comment">//      写法为： babel.transform(</span></span><br><span class="line"><span class="comment">//                  "code();", </span></span><br><span class="line"><span class="comment">//                  &#123;presets: ["react"],&#125;, </span></span><br><span class="line"><span class="comment">//                  function(err, result)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//babel.transformFile(filename: string, options?: Object, callback: Function)</span></span><br><span class="line"><span class="comment">//编译文件</span></span><br><span class="line">babel.transformFile(<span class="string">"filename.js"</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//babel.transformFromAst(ast: Object, code?: string, options?: Object, callback: Function): FileNode | null</span></span><br><span class="line"><span class="comment">//将ast进行转译</span></span><br><span class="line"><span class="keyword">const</span> &#123; code, map, ast &#125; = babel.transformFromAst(ast, code, options);</span><br></pre></td></tr></table></figure>
<p>其中 <a href="https://babeljs.io/docs/en/next/options" target="_blank" rel="noopener">options</a> 可以配置多项内容，包括Plugin和Preset配置，SourceMap配置等</p>
<h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h3><blockquote>
<p>参考 <a href="https://babeljs.io/docs/en/next/babel-cli" target="_blank" rel="noopener">babel-cli doc</a></p>
</blockquote>
<p>Babel 的 CLI 是一种在命令行下使用 Babel 编译文件的简单方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本使用 （输出到控制台）</span></span><br><span class="line">npx babel script.js</span><br><span class="line"><span class="comment">//指定输出文件</span></span><br><span class="line">npx babel script.js --out-file script-compiled.js</span><br></pre></td></tr></table></figure>
<p>假设script.js长如下这样，直接在命令行执行 babel script.js，发现输出的代码好像没有转译……</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//script.js</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">n</span> =&gt;</span> n ** <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a,,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Guy Fieri"</span>;</span><br><span class="line"><span class="keyword">var</span> place = <span class="string">"Flavortown"</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, ready for <span class="subst">$&#123;place&#125;</span>?`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yourTurn = <span class="string">"Type some code in here!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    shorthand,</span><br><span class="line">    method() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"😀"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和前面一样需要 配置 presets 和 plugins 信息。</p>
<p>这时候有两种方式一种是和上文一样使用 .babelrc 配置文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 转换 ES2015+ 的 env preset</span></span><br><span class="line">npm install babel-preset-env --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建一个 .babelrc 文件并启用一些插件</span></span><br><span class="line"><span class="comment">//.babelrc 文件信息：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候可以使用了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx babel script.js</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 可以看到箭头函数等一些新语法已经被转义了。</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(n, <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ref = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    a = _ref[<span class="number">0</span>],</span><br><span class="line">    b = _ref[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Guy Fieri"</span>;</span><br><span class="line"><span class="keyword">var</span> place = <span class="string">"Flavortown"</span>;</span><br><span class="line"><span class="string">"Hello "</span> + name + <span class="string">", ready for "</span> + place + <span class="string">"?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yourTurn = <span class="string">"Type some code in here!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  shorthand: shorthand,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"😀"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方式是直接在命令中指定presets</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 转换 ES2015+ 的 env preset</span></span><br><span class="line">npm install babel-preset-env --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定present </span></span><br><span class="line"><span class="comment">//输出也和上文一样</span></span><br><span class="line">npx babel script.js --presets=env</span><br></pre></td></tr></table></figure>
<h3 id="babel-runtime-babel-plugin-transform-runtime"><a href="#babel-runtime-babel-plugin-transform-runtime" class="headerlink" title="babel-runtime / babel-plugin-transform-runtime"></a>babel-runtime / babel-plugin-transform-runtime</h3><p>Babel 几乎可以编译所有时新的 JavaScript 语法，但对于 APIs 来说却并非如此。例如： Promise、Set、Map 等新增对象，Object.assign、Object.entries等静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下列含有箭头函数的需要编译的代码：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在上文中转义为：</span></span><br><span class="line"><span class="comment">//然而这段代码在浏览器中可能抛出 Uncaught TypeError: Array.from is not a function</span></span><br><span class="line"><span class="comment">//它依然无法随处可用因为不是所有的 JavaScript 环境都支持 Array.from</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现新的API的基础上有两种方式： <em>babel-polyfill</em>和 <strong>babel-runtime + babel-plugin-transform-runtime</strong>。</p>
<p>这两者虽然都是模拟 es6 环境新增API，但实现方法完全不同。</p>
<ul>
<li><p>babel-polyfill 的做法是将全局对象通通污染一遍，比如想在 node 0.10 上用 Promise，调用 babel-polyfill 就会往 global 对象挂上 Promise 对象。</p>
</li>
<li><p>babel-runtime 的做法是自己手动引入 helper 函数， const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise。为了解决手动引入Helper函数的麻烦，babel 又开发了 babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。这样就避免了重复打包代码和手动引入模块的痛苦。</p>
</li>
</ul>
<h3 id="babel-standalone-在浏览器环境-web工程中运行babel"><a href="#babel-standalone-在浏览器环境-web工程中运行babel" class="headerlink" title="@babel/standalone 在浏览器环境/web工程中运行babel"></a>@babel/standalone 在浏览器环境/web工程中运行babel</h3><p>由于 Babel 本身的设计是基于 node.js 环境下运行使用的， 上面的例子都是在 Node.js环境中跑的，但是你头铁 一定要在浏览器环境中跑babel怎么办？</p>
<p>答案就是使用 <code>@babel/standalone</code></p>
<p>参考 <a href="https://github.com/babel/babel/issues/5268" target="_blank" rel="noopener">https://github.com/babel/babel/issues/5268</a> <a href="https://babeljs.io/docs/en/next/babel-standalone.html" target="_blank" rel="noopener">https://babeljs.io/docs/en/next/babel-standalone.html</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//npm i @babel/standalone @babel/core @babel/preset-react @babel/preset-env @babel/plugin-transform-runtime</span></span><br><span class="line"><span class="comment">//为什么写成这种require样式呢……@babel/standalone集成了很多插件 但是好像兼容性不好……</span></span><br><span class="line"><span class="keyword">const</span> babelCore = <span class="built_in">require</span>(<span class="string">'@babel/standalone'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123;code&#125; = babelCore.transform(</span><br><span class="line">    <span class="string">'(&#123;item&#125;) =&gt; &lt;Text&gt;&#123;item.key&#125;&lt;/Text&gt;'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'presets'</span>: [<span class="built_in">require</span>(<span class="string">'@babel/preset-react'</span>),<span class="built_in">require</span>(<span class="string">'@babel/preset-env'</span>)],</span><br><span class="line">        <span class="string">'plugins'</span>: [<span class="built_in">require</span>(<span class="string">'@babel/plugin-transform-runtime'</span>)]</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'code:'</span>,code);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//npm i @babel/standalone </span></span><br><span class="line"><span class="keyword">const</span> babelCore = <span class="built_in">require</span>(<span class="string">'@babel/standalone'</span>);</span><br><span class="line"><span class="keyword">let</span> &#123;code&#125; = babelCore.transform(</span><br><span class="line">    <span class="string">'(&#123;item&#125;) =&gt; &lt;Text&gt;&#123;item.key&#125;&lt;/Text&gt;'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'presets'</span>: [<span class="string">'react'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'code:'</span>,code);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>quick-start</category>
        <category>Babel教程</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron入门教程</title>
    <url>/quick-start/Electron%E6%95%99%E7%A8%8B/Electron%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://electronjs.org/docs/tutorial/about" target="_blank" rel="noopener">Electron</a>是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将 <strong>Chromium</strong> 和 <strong>Node.js</strong>合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。</p>
<p>相信大部分前端同学都听说或者了解过<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">NodeJs</a> 它是一个基于<a href="https://v8.dev/" target="_blank" rel="noopener">Chrome V8 引擎</a>的JavaScript运行时， 而 <a href="https://www.chromium.org/" target="_blank" rel="noopener">Chromium</a> 是Google为发展自家浏览器Chrome而开启的开源浏览器项目，可以看成是是Chrome的先行版。大家较为熟悉的VS Code 和 Atom就是使用Electron来完成的。</p>
<p>从开发的角度来看, Electron application 本质上是一个 Node. js 应用程序。可以让前端开发者让你使用纯 JavaScript 调用丰富的原生操作系统APIs来创造桌面应用~</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><blockquote>
<p>确认你的网络可以访问github , 若访问受限参考 <a href="https://electronjs.org/docs/tutorial/installation" target="_blank" rel="noopener">安装指南</a> 来了解如何用代理、镜像和自定义缓存</p>
</blockquote>
<p>你肯定已经已经安装好git和node了，那么只要：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官网已经有 electron-quick-start 仓库克隆下来</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> electron-quick-start</span><br><span class="line"><span class="comment"># 安装依赖包并运行</span></span><br><span class="line">npm install &amp;&amp; npm start</span><br></pre></td></tr></table></figure>
<p>然后你的第一个桌面应用就开启了！</p>
<p><img src="/res/Electron/Electron_1.png" alt></p>
<p>若你跟着一起实践到这里，肯定会发现界面有些许不同？我这里多了个调试界面，那么来看下代码看看。在Electron中main.js是入口文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; app, BrowserWindow &#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keep a global reference of the window object, if you don't, the window will</span></span><br><span class="line"><span class="comment">// be closed automatically when the JavaScript object is garbage collected.</span></span><br><span class="line"><span class="keyword">let</span> win</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建浏览器窗口。</span></span><br><span class="line">  win = <span class="keyword">new</span> BrowserWindow(&#123; <span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后加载应用的 index.html。对应的index.html 就是初始界面。</span></span><br><span class="line">  win.loadFile(<span class="string">'index.html'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开开发者工具</span></span><br><span class="line">  win.webContents.openDevTools()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关于win 窗口的生命周期我们之后再研究……</span></span><br><span class="line">  <span class="comment">// 当 window 被关闭，这个事件会被触发。</span></span><br><span class="line">  win.on(<span class="string">'closed'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消引用 window 对象，如果你的应用支持多窗口的话，</span></span><br><span class="line">    <span class="comment">// 通常会把多个 window 对象存放在一个数组里面，</span></span><br><span class="line">    <span class="comment">// 与此同时，你应该删除相应的元素。</span></span><br><span class="line">    win = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关于 app 主进程的生命周期我们之后再研究……</span></span><br><span class="line"><span class="comment">// Electron 会在初始化后并准备</span></span><br><span class="line"><span class="comment">// 创建浏览器窗口时，调用这个函数。</span></span><br><span class="line"><span class="comment">// 部分 API 在 ready 事件触发后才能使用。</span></span><br><span class="line">app.on(<span class="string">'ready'</span>, createWindow)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当全部窗口关闭时退出。</span></span><br><span class="line">app.on(<span class="string">'window-all-closed'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在 macOS 上，除非用户用 Cmd + Q 确定地退出，</span></span><br><span class="line">  <span class="comment">// 否则绝大部分应用及其菜单栏会保持激活。</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">'darwin'</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">'activate'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 在macOS上，当单击dock图标并且没有其他窗口打开时，</span></span><br><span class="line">  <span class="comment">// 通常在应用程序中重新创建一个窗口。</span></span><br><span class="line">  <span class="keyword">if</span> (win === <span class="literal">null</span>) &#123;</span><br><span class="line">    createWindow()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这个文件中，你可以续写应用剩下主进程代码。</span></span><br><span class="line"><span class="comment">// 也可以拆分成几个文件，然后用 require 导入。</span></span><br></pre></td></tr></table></figure>
<h2 id="与现有React工程结合"><a href="#与现有React工程结合" class="headerlink" title="与现有React工程结合"></a>与现有React工程结合</h2><p>迫于不会Vue ，在这里介绍下React工程如何和Electron结合起来。<br><a id="more"></a><br>偷懒就直接使用 create-react-app 来创建react工程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#若已安装 请忽略</span></span><br><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app react-electron</span><br><span class="line"><span class="built_in">cd</span> react-electron</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h3 id="添加-Electron-配置并启动"><a href="#添加-Electron-配置并启动" class="headerlink" title="添加 Electron 配置并启动"></a>添加 Electron 配置并启动</h3><p><strong>一、</strong> 安装 Electron包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 react-electron 目录下安装 Electron 包</span></span><br><span class="line">npm install -save electron</span><br></pre></td></tr></table></figure>
<p><strong>二、</strong> 添加main.js</p>
<p>在 react-electron 目录下添加main.js ,直接使用上面 main.js的内容 ，然后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//win.loadFile('index.html') 这一行替换为：</span></span><br><span class="line">win.loadFile(<span class="string">'http://localhost:3000/'</span>)</span><br></pre></td></tr></table></figure>
<p>这样就将入口界面指定到react的初始界面了。</p>
<p><strong>三、</strong> 启动Electron！</p>
<p>修改 package.json ,添加 main homepage字段，并添加electron-start命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="string">"main"</span>: <span class="string">"main.js"</span>,</span><br><span class="line">  <span class="string">"homepage"</span>:<span class="string">"."</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"react-scriptsbuild"</span>,</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"react-scripts test --env=jsdom"</span>,</span><br><span class="line">    <span class="string">"eject"</span>: <span class="string">"react-scripts  eject"</span>,</span><br><span class="line">    <span class="string">"electron"</span>: <span class="string">"electron ."</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 Electron：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动react项目</span></span><br><span class="line">npm start</span><br><span class="line"><span class="comment"># 启动electron</span></span><br><span class="line">npm run electron</span><br></pre></td></tr></table></figure>
<p><img src="/res/Electron/Electron_2.png" alt></p>
<p>看到一篇 <a href="https://flaviocopes.com/react-electron/" target="_blank" rel="noopener">文章 CREATE AN APP WITH ELECTRON AND REACT</a> 写create-react-app和Electron结合的不错,大家也可以参考这个。</p>
<p><strong>四、在react中使用electron</strong></p>
<p>直接在react中使用import electron会产生问题 <a href="https://github.com/electron/electron/issues/7300#issuecomment-285885725" target="_blank" rel="noopener">issues/7300</a>，可以写成这种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const electron = window.require(&apos;electron&apos;);</span><br><span class="line">const fs = electron.remote.require(&apos;fs&apos;);</span><br><span class="line">const ipcRenderer  = electron.ipcRenderer;</span><br></pre></td></tr></table></figure>
<h2 id="主进程和渲染进程"><a href="#主进程和渲染进程" class="headerlink" title="主进程和渲染进程"></a>主进程和渲染进程</h2><p>Electron 与web应用的区别不是很大，在原web应用的基础上添加主线程交互代码后，甚至可以将一个线上web应用迅速的包装成为一个客户端应用! Electron并且内集成了 Nodejs，Nodejs 在主进程和渲染进程中都可以使用，这为我们提供了npm成千上万的模块。</p>
<p>所以个人感觉应用Electron的重要在于理解主进程和渲染进程，和进程间的交互。其他API可以自己花点时间阅读文档。</p>
<p>运行Electron入口文件的进程（也就是上文运行main.js的进程）被称为主进程，它控制着整个 App 的生命周期，从打开到关闭。 它也管理着系统原生元素比如菜单，菜单栏，Dock 栏，托盘等。 主进程负责创建 APP 的每个渲染进程。而且整个 Node API 都集成在里面；</p>
<p>而在主进程创建的一个个web页面（对应上文中的win窗口）也都运行着自己的进程，即渲染进程，渲染进程各自独立，各自拥有自己的生命周期。与主进程不同的是，它能够同时存在多个而且运行在不一样的进程。而且它们也能够被隐藏。在通常的浏览器内，网页通常运行在一个沙盒的环境挡住并且不能够使用原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些低级别的交互。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>Electron提供了几种通信方式：</p>
<h4 id="一-使用ipc-renderer-和-ipc-main"><a href="#一-使用ipc-renderer-和-ipc-main" class="headerlink" title="一 使用ipc-renderer 和 ipc-main :"></a>一 使用<a href="https://electronjs.org/docs/api/ipc-renderer" target="_blank" rel="noopener">ipc-renderer</a> 和 <a href="https://electronjs.org/docs/api/ipc-main" target="_blank" rel="noopener">ipc-main</a> :</h4><p>ipc-renderer 和 ipc-main 异步交互：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在渲染进程中：</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="comment">//发送asynchronous-message事件到主进程</span></span><br><span class="line">ipcRenderer.send(<span class="string">'asynchronous-message'</span>, <span class="string">'ping'</span>)</span><br><span class="line"><span class="comment">//接收主进程的asynchronous-reply通知</span></span><br><span class="line">ipcRenderer.on(<span class="string">'asynchronous-reply'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'asynchronous-reply : args:'</span>,arg)</span><br><span class="line">  <span class="keyword">const</span> message = <span class="string">`Asynchronous message reply: <span class="subst">$&#123;arg&#125;</span>`</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'async-reply'</span>).innerHTML = message</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在主进程中：</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"><span class="comment">//接收渲染进程的asynchronous-message通知</span></span><br><span class="line">ipcMain.on(<span class="string">'asynchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  <span class="comment">//发送asynchronous-reply事件到渲染进程</span></span><br><span class="line">  event.sender.send(<span class="string">'asynchronous-reply'</span>, &#123;<span class="string">'ping'</span>:<span class="string">'pong'</span>,<span class="string">'num'</span>:<span class="string">'1'</span>&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>ipc-renderer 和 ipc-main 同步交互：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在渲染进程中：</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syncMsgBtn = <span class="built_in">document</span>.getElementById(<span class="string">'sync-msg'</span>)</span><br><span class="line"></span><br><span class="line">syncMsgBtn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reply = ipcRenderer.sendSync(<span class="string">'synchronous-message'</span>, <span class="string">'ping'</span>)</span><br><span class="line">  <span class="keyword">const</span> message = <span class="string">`Synchronous message reply: <span class="subst">$&#123;reply&#125;</span>`</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'sync-reply'</span>).innerHTML = message</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在主进程中：</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcMain&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>)</span><br><span class="line"></span><br><span class="line">ipcMain.on(<span class="string">'synchronous-message'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">  event.returnValue = <span class="string">'pong'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="二-在渲染进程使用remote模块"><a href="#二-在渲染进程使用remote模块" class="headerlink" title="二 在渲染进程使用remote模块"></a>二 在渲染进程使用remote模块</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在渲染进程打开提示对话框</span></span><br><span class="line"><span class="keyword">const</span> &#123;dialog&#125; = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote</span><br><span class="line">dialog.showMessageBox(options, (index) =&gt; &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="三-在主进程向渲染进程webContents发送消息"><a href="#三-在主进程向渲染进程webContents发送消息" class="headerlink" title="三 在主进程向渲染进程webContents发送消息"></a>三 在主进程向渲染进程webContents发送消息</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">win.webContents.send(<span class="string">'ping'</span>, <span class="string">'whoooooooh!'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="四-渲染进程之间的通信"><a href="#四-渲染进程之间的通信" class="headerlink" title="四 渲染进程之间的通信"></a>四 渲染进程之间的通信</h4><p>在两个网页（渲染进程）间共享数据最简单的方法是使用浏览器中已经实现的 HTML5 API。 其中比较好的方案是用 Storage API， localStorage，sessionStorage 或者 IndexedDB。</p>
<p>你还可以用 Electron 内的 IPC 机制实现。将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 remote 模块来访问它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主进程中</span></span><br><span class="line">global.sharedObject = &#123;</span><br><span class="line">  someProperty: <span class="string">'default value'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在第一个页面中</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'electron'</span>).remote.getGlobal(<span class="string">'sharedObject'</span>).someProperty = <span class="string">'new value'</span></span><br><span class="line"><span class="comment">// 在第二个页面中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>(<span class="string">'electron'</span>).remote.getGlobal(<span class="string">'sharedObject'</span>).someProperty)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>Electron教程</category>
      </categories>
      <tags>
        <tag>跨平台开发</tag>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫教程-使用Scrapy(2)</title>
    <url>/quick-start/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8Scrapy(2)/</url>
    <content><![CDATA[<blockquote>
<p>本文主要讲使用IP代理防止爬虫被禁</p>
<p>在 <a href="../Python爬虫教程-使用Scrapy/">python爬虫</a>中爬取到大约184条数据后，zhipin网站就会采取链接重定向方式 阻止爬取。如果在代码中取消登录操作 ， 直接爬取到大约92条数据，你的 IP 就会被封啦~ </p>
</blockquote>
<p><img src="/res/Python/zhipin_403.png" alt></p>
<p>为了防止这个悲剧发生 根据Scarpy <a href="https://doc.scrapy.org/en/latest/topics/practices.html?highlight=banned#avoiding-getting-banned" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/practices.html?highlight=banned#avoiding-getting-banned</a> 有以下几个建议：</p>
<a id="more"></a>
<ul>
<li>动态设置user agent</li>
<li>禁用cookies （<strong>COOKIES_ENABLED</strong>）</li>
<li>设置延迟下载 （<strong>DOWNLOAD_DELAY</strong>）</li>
<li>使用Google cache (<em>国内不好用</em>)</li>
<li>使用IP地址池（Tor project、VPN和代理IP）</li>
<li>使用Crawlera （<em>收费</em>）</li>
</ul>
<p>在setting.py中设置完 COOKIES_ENABLED 和 DOWNLOAD_DELAY 下面就来看如何使用 User Agent 和 IP代理</p>
<h2 id="设置-UA池和-IP池"><a href="#设置-UA池和-IP池" class="headerlink" title="设置 UA池和 IP池"></a>设置 UA池和 IP池</h2><p>scarpy设置代理IP 和 User Agent的切换都是用 下载中间件 DOWNLOADER_MIDDLEWARES 完成。</p>
<h3 id="动态切换-User-Agent"><a href="#动态切换-User-Agent" class="headerlink" title="动态切换 User Agent"></a>动态切换 User Agent</h3><p>在工程中 middleware.py(没有这个文件就创建一个，若是有这个文件 里面有内置的中间件也不用理会它) 中添加：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">agents = [</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/4.0.249.0 Safari/532.5"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/532.9 (KHTML, like Gecko) Chrome/5.0.310.0 Safari/532.9"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.514.0 Safari/534.7"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/9.0.601.0 Safari/534.14"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.14 (KHTML, like Gecko) Chrome/10.0.601.0 Safari/534.14"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.20 (KHTML, like Gecko) Chrome/11.0.672.2 Safari/534.20"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.27 (KHTML, like Gecko) Chrome/12.0.712.0 Safari/534.27"</span>,</span><br><span class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1"</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAgentMiddleware</span><span class="params">(object)</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        agent = random.choice(agents)</span><br><span class="line">        request.headers[<span class="string">"User-Agent"</span>] = agent</span><br></pre></td></tr></table></figure>
<p>然后在setting.py中 添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   &apos;jobSpider.middlewares.UserAgentMiddleware&apos;: 401,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IP代理"><a href="#IP代理" class="headerlink" title="IP代理"></a>IP代理</h3><p>简单来，比如本地127.0.0.1开启了一个8888端口的代理，同样可以通过中间件配置让爬虫通过这个代理来对目标网站进行爬取。<br>同样在middleware.py中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ProxyMiddleware(object):</span><br><span class="line"></span><br><span class="line">    def process_request(self, request, spider): </span><br><span class="line">        # 此处填写你自己的代理</span><br><span class="line">        # 如果是买的代理的话可以去用API获取代理列表然后随机选择一个</span><br><span class="line">        proxy = &quot;http://127.0.0.1: 8888&quot;</span><br><span class="line">        request.meta[&quot;proxy&quot;] = proxy</span><br></pre></td></tr></table></figure>
<p>然后和 user agent中一样 在setting.py 的DOWNLOADER_MIDDLEWARES中添加ProxyMiddleware就可以了。</p>
<p>但是当然用第三方的ip代理 才能达到防止爬虫被banned的目的啦~</p>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>Python爬虫教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫教程-使用Scrapy</title>
    <url>/quick-start/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8Scrapy/</url>
    <content><![CDATA[<blockquote>
<p>scrapy基础实例，爬取zhipin网站信息</p>
<p>scarpy的新建 + scarpy模拟登录 + 在pipeline中存取信息到sqlite3 +xpath解析页面</p>
</blockquote>
<ul>
<li>文档<ul>
<li><a href="https://docs.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">Scrapy Documentation</a></li>
<li><a href="http://scrapy-chs.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Scrapy 0.25 中文翻译</a></li>
</ul>
</li>
<li>环境 python3.5.2 + scrapy1.3</li>
</ul>
<h2 id="scrapy新建工程"><a href="#scrapy新建工程" class="headerlink" title="scrapy新建工程"></a>scrapy新建工程</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scrapy startproject projectName</span><br></pre></td></tr></table></figure>
<p>具体可以查看 <a href="../Python爬虫教程-入门/">python3爬虫学习</a></p>
<p>发现 <strong>parse</strong> 或者 <strong>start_requests</strong>是爬虫的入口</p>
<h2 id="解析html"><a href="#解析html" class="headerlink" title="解析html"></a>解析html</h2><a id="more"></a>
<p>scrapy支持xpath 和 css 两种选择器。这里使用xpath。</p>
<p>比如 <a href="https://www.zhipin.com/job_detail/?query=iOS&amp;scity=101210100&amp;source=2" target="_blank" rel="noopener">这个页面</a> 我们要获取页面上帖子的链接：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">       print(<span class="string">"\n 开始 解析版面上的具体招聘帖子的链接\n"</span>)</span><br><span class="line"></span><br><span class="line">       selector = scrapy.Selector(response)</span><br><span class="line">       job_list = selector.xpath(<span class="string">"//div[@class='job-list']/ul[1]/li/a"</span>)</span><br><span class="line">       <span class="keyword">for</span> job_list_content <span class="keyword">in</span> job_list:</span><br><span class="line">           url = self.host + job_list_content.xpath(<span class="string">"@href"</span>).extract_first()</span><br><span class="line">           print(<span class="string">"\n帖子 链接是:  "</span>+url+<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure>
<p>这样就或获取到帖子的链接</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>如何解析帖子链接的内容，并且递归到下一页呢？这里需要使用yield：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_page)</span><br></pre></td></tr></table></figure></p>
<p>scrapy会自行调度，并访问该url然后把内容拿回来</p>
<p>具体代码：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestZhiPinSpider2</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">"TestZhiPinSpider2"</span></span><br><span class="line">    host = <span class="string">"https://www.zhipin.com"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这个例子中只指定了一个页面作为爬取的起始url</span></span><br><span class="line">    <span class="comment"># 当然从数据库或者文件或者什么其他地方读取起始url也是可以的</span></span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">"https://www.zhipin.com/job_detail/?query=iOS&amp;scity=101210100"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 爬虫的入口，可以在此进行一些初始化工作，比如从某个文件或者数据库读入起始url</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">" 开始解析url ----------------------------------------------------------------------------------------"</span>)</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls:</span><br><span class="line">            <span class="comment"># 此处将起始url加入scrapy的待爬取队列，并指定解析函数</span></span><br><span class="line">            <span class="comment"># scrapy会自行调度，并访问该url然后把内容拿回来</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_page)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 版面解析函数，解析一个版面上的帖子的标题和地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        print(<span class="string">"解析  parse_page ----------------------------------------------------------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line">        job_list = selector.xpath(<span class="string">"//div[@class='job-list']/ul[1]/li/a"</span>)</span><br><span class="line">        <span class="keyword">for</span> job_list_content <span class="keyword">in</span> job_list:</span><br><span class="line">            url = self.host + job_list_content.xpath(<span class="string">"@href"</span>).extract_first()</span><br><span class="line">            print(<span class="string">"帖子 链接是:  "</span>+url)</span><br><span class="line">            <span class="comment"># 此处，将解析出的帖子地址加入待爬取队列，并指定解析函数</span></span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url, callback=self.parse_job_detail)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在此处解析翻页信息，从而实现爬取版区的多个页面</span></span><br><span class="line">        next_page_url = selector.xpath(<span class="string">"//a[@ka='page-next']"</span>).xpath(<span class="string">"@href"</span>).extract_first()</span><br><span class="line">        next_page_class = selector.xpath(<span class="string">"//a[@ka='page-next']"</span>).xpath(<span class="string">"@class"</span>).extract_first()</span><br><span class="line">        <span class="keyword">if</span> next_page_class == <span class="string">"next"</span>:</span><br><span class="line">             next_page_full_url = self.host + next_page_url</span><br><span class="line">             <span class="keyword">yield</span> scrapy.Request(url=next_page_full_url, callback=self.parse_page)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             print(<span class="string">"没有下一页了----------------------------------------------------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#具体的招聘信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_job_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line"></span><br><span class="line">        job_url = response.request.url</span><br><span class="line">        print(<span class="string">" 解析 具体的招聘信息  --------url:"</span>+job_url)</span><br></pre></td></tr></table></figure></p>
<p>这个爬虫会将zhipin网站iOS招聘的信息都爬取一遍</p>
<h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><p>可以看到新建工程后会生成一个pipelines.py的文件，可以在这里处理抓取的内容，存入数据库什么的。</p>
<h3 id="1-在items-py中定义抓取的内容"><a href="#1-在items-py中定义抓取的内容" class="headerlink" title="1.在items.py中定义抓取的内容"></a>1.在items.py中定义抓取的内容</h3><p>这里简单写一个</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJobDetailItem</span><span class="params">(Item)</span>:</span></span><br><span class="line">    url = Field()</span><br></pre></td></tr></table></figure>
<h3 id="2-在pipelines中处理"><a href="#2-在pipelines中处理" class="headerlink" title="2.在pipelines中处理"></a>2.在pipelines中处理</h3><p>在pipelines.py中新建Sqlite3Pipeline方法，原来可能有个FilePipeline不理它。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> JobDetailItem</span><br><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> TestJobDetailItem</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sqlite3Pipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, sqlite_file, sqlite_base_file, sqlite_ZhiPin_table, sqlite_Test_ZhiPin_table)</span>:</span></span><br><span class="line">        self.sqlite_file = sqlite_file</span><br><span class="line">        self.sqlite_base_file = sqlite_base_file</span><br><span class="line">        self.sqlite_ZhiPin_table = sqlite_ZhiPin_table</span><br><span class="line">        self.sqlite_Test_ZhiPin_table = sqlite_Test_ZhiPin_table</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            sqlite_file = crawler.settings.get(<span class="string">'SQLITE_FILE_PATH'</span>), <span class="comment"># 从 settings.py 提取</span></span><br><span class="line">            sqlite_base_file=crawler.settings.get(<span class="string">'SQLITE_BASE_FILE_PATH'</span>),</span><br><span class="line">            sqlite_ZhiPin_table = crawler.settings.get(<span class="string">'SQLITE_ZHI_PIN_ITEM_TABLE'</span>),</span><br><span class="line">            sqlite_Test_ZhiPin_table=crawler.settings.get(<span class="string">'SQLITE_TEST_ZHI_PIN_ITEM_TABLE'</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        print(<span class="string">"\n 连接数据库 \n"</span>)</span><br><span class="line">        self.create_sql_db()</span><br><span class="line">        self.conn = sqlite3.connect(self.sqlite_file)</span><br><span class="line">        self.cur = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        print(<span class="string">"\n  关闭数据库 \n"</span>)</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        print(<span class="string">"\n Sqlite3Pipeline process_item\n"</span>)</span><br><span class="line">        <span class="keyword">if</span> isinstance(item, TestJobDetailItem):</span><br><span class="line">            print(<span class="string">" sqlite3 处理 TestJobDetailItem "</span>)</span><br><span class="line"></span><br><span class="line">            orderedDict = OrderedDict(sorted(item.items(), key=<span class="keyword">lambda</span> t: t[<span class="number">0</span>]))</span><br><span class="line">            keys = list(orderedDict.keys())</span><br><span class="line">            values = list(orderedDict.values())</span><br><span class="line">            insert_sql = <span class="string">"insert into &#123;0&#125;(&#123;1&#125;) values (&#123;2&#125;)"</span>.format(self.sqlite_ZhiPin_table,</span><br><span class="line">                                                                <span class="string">', '</span>.join(keys),</span><br><span class="line">                                                                <span class="string">', '</span>.join([<span class="string">'?'</span>] * len(keys)))</span><br><span class="line"></span><br><span class="line">            self.cur.execute(insert_sql, values)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">" item 类型不对 sqlite3不处理"</span>)</span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_sql_db</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#复制原始数据库，（也可以直接新建一个，只不过懒得写SQL……</span></span><br><span class="line">        sql_db_path = os.path.abspath(self.sqlite_file)</span><br><span class="line">        sql_base_db_path = os.path.abspath(self.sqlite_base_file)</span><br><span class="line">        print(<span class="string">"\n create_sql_db  \n  "</span>, sql_db_path, sql_base_db_path)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(sql_db_path):</span><br><span class="line">            shutil.copyfile(sql_base_db_path, sql_db_path)</span><br></pre></td></tr></table></figure>
<p>这里例子详细写了将抓取数据写入数据库，这里用的是sqlite3。可以换成文件csv，mysql什么的。</p>
<h3 id="3-在Setting中配置一下"><a href="#3-在Setting中配置一下" class="headerlink" title="3.在Setting中配置一下"></a>3.在Setting中配置一下</h3><p>找到settings.py 写入：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库信息</span></span><br><span class="line">SQLITE_FILE_PATH = <span class="string">'/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_use.sqlite'</span></span><br><span class="line">SQLITE_BASE_FILE_PATH = <span class="string">'/Users/sts/Desktop/github/pythonWorkSapce/jobSpider/jobSpider/sqlite/Item_base.sqlite'</span></span><br><span class="line">SQLITE_ZHI_PIN_ITEM_TABLE = <span class="string">'ZhiPinJobDetail'</span></span><br><span class="line">SQLITE_TEST_ZHI_PIN_ITEM_TABLE = <span class="string">'TestZhiPin'</span></span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置pipeline</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   <span class="string">'jobSpider.pipelines.Sqlite3Pipeline'</span>: <span class="number">400</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以配置多个pipeline，后面的数字表示优先级。scrapy会根据优先级，把item依次交给各个pipeline来处理。</p>
<h3 id="4-在爬虫中调用这个pipeline"><a href="#4-在爬虫中调用这个pipeline" class="headerlink" title="4.在爬虫中调用这个pipeline"></a>4.在爬虫中调用这个pipeline</h3><p>在上面递归例子中，加入 yield item</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> jobSpider.items <span class="keyword">import</span> JobDetailItem</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">#具体的招聘信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_job_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        selector = scrapy.Selector(response)</span><br><span class="line"></span><br><span class="line">        job_url = response.request.url</span><br><span class="line">        print(<span class="string">" 解析 具体的招聘信息  --------url:"</span>+job_url)  </span><br><span class="line">        item = TestJobDetailItem()      </span><br><span class="line">        item[<span class="string">"url"</span>] = job_url</span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p>scrapy会把这个item交给我们刚刚写的FilePipeline来处理.</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><blockquote>
<p>很多爬虫信息都要登录后才能抓取，这里也将登录模拟一遍，还是用 zhipin 网站。<br>使用zhipin网站的账号密码登陆模式</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 测试登录</span></span><br><span class="line">   login_url = <span class="string">"https://www.zhipin.com/user/login.html?ka=header-login"</span></span><br><span class="line">   login_post_url = <span class="string">"https://www.zhipin.com/login/account.json"</span></span><br><span class="line">   host = <span class="string">"https://www.zhipin.com"</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">       <span class="keyword">yield</span> scrapy.Request(url=self.login_url,</span><br><span class="line">                            meta=&#123;<span class="string">'cookiejar'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                            callback=self.request_captcha)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#获取验证码 这里简单使用手动输验证码</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">request_captcha</span><span class="params">(self, response)</span>:</span></span><br><span class="line">       selector = scrapy.Selector(response)</span><br><span class="line">       captcha_url = selector.xpath(<span class="string">"//img[@class='verifyimg']"</span>).xpath(<span class="string">"./@src"</span>).extract_first()</span><br><span class="line">       randomKey = selector.xpath(<span class="string">"//input[@class='randomkey']"</span>).xpath(<span class="string">"./@value"</span>).extract_first()</span><br><span class="line"></span><br><span class="line">       full_captcha_url = self.host + captcha_url</span><br><span class="line">       fileName = self.captcha_file_path()</span><br><span class="line">       urlretrieve(full_captcha_url, fileName)</span><br><span class="line"></span><br><span class="line">       open_image_command = <span class="string">"open "</span>+fileName</span><br><span class="line">       os.system(open_image_command)</span><br><span class="line"></span><br><span class="line">       captcha_str = input(<span class="string">"请输入验证码:"</span>)</span><br><span class="line">       <span class="keyword">return</span> scrapy.FormRequest.from_response(</span><br><span class="line">           response,</span><br><span class="line">           formdata=&#123;<span class="string">"regionCode"</span>: <span class="string">"+86"</span>,</span><br><span class="line">                     <span class="string">"account"</span>: <span class="string">"手机号"</span>,</span><br><span class="line">                     <span class="string">"password"</span>: <span class="string">"密码"</span>,</span><br><span class="line">                     <span class="string">"captcha"</span>: captcha_str,</span><br><span class="line">                     <span class="string">"randomKey"</span>: randomKey&#125;,</span><br><span class="line">           meta=&#123;<span class="string">'cookiejar'</span>: response.meta[<span class="string">'cookiejar'</span>]&#125;,</span><br><span class="line">           callback=self.after_login</span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="comment"># self.open_host_page 就是开始爬的方法</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">after_login</span><span class="params">(self, response)</span>:</span></span><br><span class="line">       print(<span class="string">"after_login"</span>)</span><br><span class="line">       <span class="keyword">yield</span> scrapy.Request(url=self.host,</span><br><span class="line">                            meta=&#123;<span class="string">'cookiejar'</span>: response.meta[<span class="string">'cookiejar'</span>]&#125;,</span><br><span class="line">                            callback=self.open_host_page)</span><br><span class="line">                            </span><br><span class="line">   <span class="comment">#验证码图片保存路径</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">captcha_file_path</span><span class="params">(self)</span>:</span></span><br><span class="line">       captcha_file_name = <span class="string">"./image/captcha.jpg"</span></span><br><span class="line">       directory = os.path.dirname(captcha_file_name)</span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">           os.makedirs(directory)</span><br><span class="line">       <span class="keyword">return</span> captcha_file_name</span><br></pre></td></tr></table></figure>
<h2 id="setting的一些配置"><a href="#setting的一些配置" class="headerlink" title="setting的一些配置"></a>setting的一些配置</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 间隔时间，单位秒。指明scrapy每两个请求之间的间隔。</span></span><br><span class="line">DOWNLOAD_DELAY = <span class="number">5</span></span><br><span class="line"><span class="comment"># 对一个网站的最大并发数</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN = <span class="number">16</span></span><br><span class="line"><span class="comment"># 对一个IP的最大并发数</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_IP = <span class="number">16</span></span><br><span class="line"><span class="comment"># 请求头</span></span><br><span class="line">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class="line">    <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8,en;q=0.6'</span>,</span><br><span class="line">    <span class="string">'Accept-Encoding'</span>:<span class="string">'gzip, deflate, sdch, br'</span>,</span><br><span class="line">    <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>就可以爬取到所需要的招聘信息了：<br><img src="/res/Python/python爬虫.png" alt></p>
<p>具体代码查看： <a href="https://github.com/sunyanyan/jobSpider" target="_blank" rel="noopener">https://github.com/sunyanyan/jobSpider</a></p>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>Python爬虫教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫教程-入门</title>
    <url>/quick-start/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B/Python%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li>使用的IDE ： <a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">pycharm ce 社区版</a></li>
<li>python lib文档 : <a href="https://docs.python.org/3.5/library/index.html" target="_blank" rel="noopener">The Python Standard Library</a></li>
</ul>
<blockquote>
<p>python3 爬虫</p>
</blockquote>
<h1 id="创建爬虫"><a href="#创建爬虫" class="headerlink" title="创建爬虫"></a>创建爬虫</h1><h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><blockquote>
<p>网络连接</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line">html = urlopen(<span class="string">"http://pythonscraping.com/pages/page1.html"</span>) print(html.read())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>BeautifulSoup</p>
</blockquote>
<p>中文文档 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/</a></p>
<a id="more"></a>
<ol>
<li>安装pip<ul>
<li>根据 <a href="https://pip.pypa.io/en/latest/installing/" target="_blank" rel="noopener">https://pip.pypa.io/en/latest/installing/</a> 安装pip</li>
</ul>
</li>
<li><p>安装beautifulsoup</p>
 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$pip3 install beautifulsoup4</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/page1.html"</span>)</span><br><span class="line">bsObj = BeautifulSoup(html.read())</span><br><span class="line">print(bsObj.h1)</span><br></pre></td></tr></table></figure>
<ul>
<li>这样使用会警告 <code>BeautifulSoup([your markup], &quot;html.parser&quot;)</code>这样正确的使用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>处理Http异常</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/page1.html"</span>)</span><br><span class="line"><span class="keyword">except</span> HTTPError <span class="keyword">as</span> e: </span><br><span class="line">	print(e)</span><br><span class="line">	<span class="comment"># 返回空值，中断程序，或者执行另一个方案 </span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment"># 程序继续。注意:如果你已经在上面异常捕捉那一段代码里返回或中断(break)， </span></span><br><span class="line">	<span class="comment"># 那么就不需要使用else语句了，这段代码也不会执行</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>处理beautifulSoup异常</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	badContent = bsObj.nonExistingTag.anotherTag</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e: </span><br><span class="line">	print(<span class="string">"Tag was not found"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">if</span> badContent == <span class="keyword">None</span>:</span><br><span class="line">		<span class="keyword">print</span> (<span class="string">"Tag was not found"</span>) </span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(badContent)</span><br></pre></td></tr></table></figure>
<h2 id="复杂HTML解析"><a href="#复杂HTML解析" class="headerlink" title="复杂HTML解析"></a>复杂HTML解析</h2><blockquote>
<p>使用beautifulSoup抓取特定css属性</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/warandpeace.html"</span>)</span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line">nameList = bsObj.findAll(<span class="string">"span"</span>, &#123;<span class="string">"class"</span>:<span class="string">"green"</span>&#125;) </span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> nameList:</span><br><span class="line">    print(name.get_text())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用beautifulSoup处理html标签树</p>
</blockquote>
<ol>
<li><p>获取子标签 <code>children()</code></p>
 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/page3.html"</span>)</span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> bsObj.find(<span class="string">"table"</span>,&#123;<span class="string">"id"</span>:<span class="string">"giftList"</span>&#125;).children:</span><br><span class="line">	print(child)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取自身之后的兄弟标签 <code>next_siblings()</code></p>
<ul>
<li><p>获取除了自身以外的兄弟标签，同时只能获取自身之后的兄弟标签。</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/page3.html"</span>) </span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> bsObj.find(<span class="string">"table"</span>,&#123;<span class="string">"id"</span>:<span class="string">"giftList"</span>&#125;).tr.next_siblings: </span><br><span class="line">	print(sibling)</span><br></pre></td></tr></table></figure>
</li>
<li><p>除此之外还有 获取自身之前的兄弟标签 <code>previous_siblings()</code>、获取自身之前的单个兄弟标签 <code>previous_sibling()</code>、获取自身之后的单个兄弟标签 <code>next_sibling()</code>。</p>
</li>
</ul>
</li>
<li><p>获取父标签</p>
<ul>
<li>parent 和 parents</li>
</ul>
</li>
</ol>
<blockquote>
<p>正则表达式 与 BeautifulSoup</p>
</blockquote>
<p>查找图片相对路径为以 ../img/gifts/img 开头，以 .jpg 结尾的图片</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com/pages/page3.html"</span>)</span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line">images = bsObj.findAll(<span class="string">"img"</span>,&#123;<span class="string">"src"</span>:re.compile(<span class="string">"\.\.\/img\/gifts/img.*\.jpg"</span>)&#125;) <span class="keyword">for</span> image <span class="keyword">in</span> images:</span><br><span class="line">print(image[<span class="string">"src"</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取属性</p>
</blockquote>
<p>经常不需要查找标签的内容， 而是需要查找标签属性<br><code>myTag.attrs</code>可以获取一个标签对象的全部属性。比如获取src属性：<code>myImgTag.attrs[&quot;src&quot;]</code></p>
<h1 id="开始采集"><a href="#开始采集" class="headerlink" title="开始采集"></a>开始采集</h1><h2 id="遍历单个域名"><a href="#遍历单个域名" class="headerlink" title="遍历单个域名"></a>遍历单个域名</h2><blockquote>
<p>找到URL链接，获取网页内容，从中找出另一个链接，然后再获取这个网页的内容，不断循环这一过程。</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">random.seed(datetime.datetime.now())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLinks</span><span class="params">(articleUrl)</span>:</span></span><br><span class="line">    html = urlopen(<span class="string">"http://en.wikipedia.org"</span>+articleUrl)</span><br><span class="line">    bsObj = BeautifulSoup(html)</span><br><span class="line">    <span class="keyword">return</span> bsObj.find(<span class="string">"div"</span>, &#123;<span class="string">"id"</span>:<span class="string">"bodyContent"</span>&#125;).findAll(<span class="string">"a"</span>,href=re.compile(<span class="string">"^(/wiki/)((?!:).)*$"</span>))</span><br><span class="line"></span><br><span class="line">links = getLinks(<span class="string">"/wiki/Kevin_Bacon"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(links) &gt; <span class="number">0</span>:</span><br><span class="line">    newArticle = links[random.randint(<span class="number">0</span>, len(links)<span class="number">-1</span>)].attrs[<span class="string">"href"</span>]</span><br><span class="line">    print(newArticle)</span><br><span class="line">    links = getLinks(newArticle)</span><br></pre></td></tr></table></figure>
<p>定义了 getLinks函数，过滤出指向其他词条的链接。再随机选择一条链接 获取新的页面，如此循环。</p>
<h2 id="采集整个网站"><a href="#采集整个网站" class="headerlink" title="采集整个网站"></a>采集整个网站</h2><blockquote>
<p>url链接去重，打印（收集）需要信息</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pages = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLinks</span><span class="params">(pageUrl)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> pages</span><br><span class="line">    html = urlopen(<span class="string">"http://en.wikipedia.org"</span>+pageUrl) </span><br><span class="line">    bsObj = BeautifulSoup(html)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(bsObj.h1.get_text()) </span><br><span class="line">        print(bsObj.find(id=<span class="string">"mw-content-text"</span>).findAll(<span class="string">"p"</span>)[<span class="number">0</span>])</span><br><span class="line">        print(bsObj.find(id=<span class="string">"ca-edit"</span>).find(<span class="string">"span"</span>).find(<span class="string">"a"</span>).attrs[<span class="string">'href'</span>])</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">"页面缺少一些属性!不过不用担心!"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> bsObj.findAll(<span class="string">"a"</span>, href=re.compile(<span class="string">"^(/wiki/)"</span>)):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'href'</span> <span class="keyword">in</span> link.attrs:</span><br><span class="line">        <span class="keyword">if</span> link.attrs[<span class="string">'href'</span>] <span class="keyword">not</span> <span class="keyword">in</span> pages:</span><br><span class="line">            <span class="comment"># 我们遇到了新页面</span></span><br><span class="line">            newPage = link.attrs[<span class="string">'href'</span>] </span><br><span class="line">            print(<span class="string">"----------------\n"</span>+newPage) </span><br><span class="line">            pages.add(newPage) </span><br><span class="line">            getLinks(newPage)</span><br><span class="line">            </span><br><span class="line">getLinks(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<h2 id="使用Scrapy采集"><a href="#使用Scrapy采集" class="headerlink" title="使用Scrapy采集"></a>使用Scrapy采集</h2><blockquote>
<p>Scrapy 就是一个帮你大幅度降低网页链接查找和识别工作复杂度的 Python 库，它可以 让你轻松地采集一个或多个域名的信息。<br>Scrapy 1.3.0 已经支持 python3.3+了</p>
</blockquote>
<p>官方文档 : <a href="https://docs.scrapy.org/en/latest/" target="_blank" rel="noopener">Scrapy 1.3 documentation</a><br>安装： <code>pip3 install scrapy</code></p>
<blockquote>
<p>Scrapy 创建项目</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">scrapy startproject wikiSpider</span><br></pre></td></tr></table></figure>
<p>执行上面命令后：会生成目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- wikiSpider</span><br><span class="line">	* scrapy.cfg </span><br><span class="line">	- wikiSpider </span><br><span class="line">		- __pycache__</span><br><span class="line">		- spiders</span><br><span class="line">		* __init__.py</span><br><span class="line">		* items.py</span><br><span class="line">		* middlewares.py</span><br><span class="line">		* pipelines.py</span><br><span class="line">		* settings.py</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Scrapy 创建爬虫</p>
</blockquote>
<p><strong>1.</strong> 在items.py中添加一个类</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    title = scrapy.Field()</span><br></pre></td></tr></table></figure>
<p>Scrapy 的每个 Item(条目)对象表示网站上的一个页面。当然，你可以根据需要定义不同的条目(比如url、content、header image等)，但是现在我只演示收集每页的title字段 (field)。</p>
<p><strong>2.</strong> wikiSpider/wikiSpider/spiders/ 文件夹里增加一个 <strong>articleSpider.py</strong> 文件</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Spider</span><br><span class="line"><span class="keyword">from</span> wikiSpider.items <span class="keyword">import</span> Article</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleSpider</span><span class="params">(Spider)</span>:</span></span><br><span class="line">    name=<span class="string">"article"</span></span><br><span class="line">    allowed_domains = [<span class="string">"en.wikipedia.org"</span>]</span><br><span class="line">    start_urls = [<span class="string">"http://en.wikipedia.org/wiki/Main_Page"</span>,<span class="string">"http://en.wikipedia.org/wiki/Python_%28programming_language%29"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        item = Article()</span><br><span class="line">        title = response.xpath(<span class="string">'//h1/text()'</span>)[<span class="number">0</span>].extract()</span><br><span class="line">        print(<span class="string">"Title is: "</span>+title)</span><br><span class="line">        item[<span class="string">'title'</span>] = title</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>
<p>通过运行 <code>scrapy crawl article</code> 可以看到一大堆日志信息 和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title is: Main Page</span><br><span class="line">Title is: Python (programming language)</span><br></pre></td></tr></table></figure>
<h2 id="解析JSON"><a href="#解析JSON" class="headerlink" title="解析JSON"></a>解析JSON</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">jsonString = <span class="string">'&#123;"arrayOfNums":[&#123;"number":0&#125;,&#123;"number":1&#125;,&#123;"number":2&#125;],'</span> \</span><br><span class="line">             <span class="string">'"arrayOfFruits":[&#123;"fruit":"apple"&#125;,&#123;"fruit":"banana"&#125;,&#123;"fruit":"pear"&#125;]&#125;'</span></span><br><span class="line">jsonObj = json.loads(jsonString)</span><br><span class="line">print(jsonObj.get(<span class="string">"arrayOfNums"</span>)) </span><br><span class="line">print(jsonObj.get(<span class="string">"arrayOfNums"</span>)[<span class="number">1</span>]) </span><br><span class="line">print(jsonObj.get(<span class="string">"arrayOfNums"</span>)[<span class="number">1</span>].get(<span class="string">"number"</span>)+jsonObj.get(<span class="string">"arrayOfNums"</span>)[<span class="number">2</span>].get(<span class="string">"number"</span>)) </span><br><span class="line">print(jsonObj.get(<span class="string">"arrayOfFruits"</span>)[<span class="number">2</span>].get(<span class="string">"fruit"</span>))</span><br></pre></td></tr></table></figure>
<h2 id="储存数据"><a href="#储存数据" class="headerlink" title="储存数据"></a>储存数据</h2><blockquote>
<p>使用 <code>urlretrieve</code> 储存到本地</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">downloadDirectory = <span class="string">"downloaded"</span></span><br><span class="line">baseUrl = <span class="string">"http://pythonscraping.com"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAbsoluteURL</span><span class="params">(baseUrl, source)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> source.startswith(<span class="string">"http://www."</span>):</span><br><span class="line">        url = <span class="string">"http://"</span>+source[<span class="number">11</span>:]</span><br><span class="line">    <span class="keyword">elif</span> source.startswith(<span class="string">"http://"</span>):</span><br><span class="line">        url = source</span><br><span class="line">    <span class="keyword">elif</span> source.startswith(<span class="string">"www."</span>):</span><br><span class="line">        url = source[<span class="number">4</span>:]</span><br><span class="line">        url = <span class="string">"http://"</span>+source</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        url = baseUrl+<span class="string">"/"</span>+source</span><br><span class="line">    <span class="keyword">if</span> baseUrl <span class="keyword">not</span> <span class="keyword">in</span> url:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDownloadPath</span><span class="params">(baseUrl, absoluteUrl, downloadDirectory)</span>:</span></span><br><span class="line">    path = absoluteUrl.replace(<span class="string">"www."</span>, <span class="string">""</span>)</span><br><span class="line">    path = path.replace(baseUrl, <span class="string">""</span>)</span><br><span class="line">    path = downloadDirectory+path</span><br><span class="line">    directory = os.path.dirname(path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">        os.makedirs(directory)</span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">"http://www.pythonscraping.com"</span>)</span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line">downloadList = bsObj.findAll(src=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> download <span class="keyword">in</span> downloadList:</span><br><span class="line">    fileUrl = getAbsoluteURL(baseUrl, download[<span class="string">"src"</span>])</span><br><span class="line">    <span class="keyword">if</span> fileUrl <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        print(fileUrl)</span><br><span class="line"></span><br><span class="line">urlretrieve(fileUrl, getDownloadPath(baseUrl, fileUrl, downloadDirectory))</span><br></pre></td></tr></table></figure>
<p>选择首页上所有带 src 属性的标签。然 后对 URL 链接进行清理和标准化，获得文件的绝对路径(而且去掉了外链)。最后，每个文件都会下载到程序所在文件夹的 downloaded 文件里。</p>
<blockquote>
<p>将网页中的表单保存为CSV格式</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = urlopen(<span class="string">"http://en.wikipedia.org/wiki/Comparison_of_text_editors"</span>) </span><br><span class="line">bsObj = BeautifulSoup(html)</span><br><span class="line"><span class="comment"># 主对比表格是当前页面上的第一个表格</span></span><br><span class="line">table = bsObj.findAll(<span class="string">"table"</span>,&#123;<span class="string">"class"</span>:<span class="string">"wikitable"</span>&#125;)[<span class="number">0</span>]</span><br><span class="line">rows = table.findAll(<span class="string">"tr"</span>)</span><br><span class="line"></span><br><span class="line">csvFile = open(<span class="string">"../files/editors.csv"</span>, <span class="string">'wt'</span>, newline=<span class="string">''</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">writer = csv.writer(csvFile)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    csvRow = []</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row.findAll([<span class="string">'td'</span>, <span class="string">'th'</span>]):</span><br><span class="line">        csvRow.append(cell.get_text())</span><br><span class="line">        writer.writerow(csvRow) </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        csvFile.close()</span><br></pre></td></tr></table></figure>
<h1 id="高级数据采集"><a href="#高级数据采集" class="headerlink" title="高级数据采集"></a>高级数据采集</h1><h2 id="POST-与-登录"><a href="#POST-与-登录" class="headerlink" title="POST 与 登录"></a>POST 与 登录</h2><blockquote>
<p>使用第三方库 <a href="http://www.python-requests.org/" target="_blank" rel="noopener">Request</a><br>安装 <code>pip3 install requests</code></p>
</blockquote>
<p>使用：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">params = &#123;<span class="string">'firstname'</span>: <span class="string">'Ryan'</span>, <span class="string">'lastname'</span>: <span class="string">'Mitchell'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"http://pythonscraping.com/files/processing.php"</span>, data=params)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></p>
<h2 id="处理Cookie"><a href="#处理Cookie" class="headerlink" title="处理Cookie"></a>处理Cookie</h2><blockquote>
<p>使用 requests库跟踪cookie</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">'username'</span>: <span class="string">'Ryan'</span>, <span class="string">'password'</span>: <span class="string">'password'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">"http://pythonscraping.com/pages/cookies/welcome.php"</span>, params) </span><br><span class="line">print(<span class="string">"Cookie is set to:"</span>)</span><br><span class="line">print(r.cookies.get_dict())</span><br><span class="line">print(<span class="string">"-----------"</span>)</span><br><span class="line">print(<span class="string">"Going to profile page..."</span>)</span><br><span class="line">r = requests.get(<span class="string">"http://pythonscraping.com/pages/cookies/profile.php"</span>,cookies=r.cookies)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<h2 id="处理Session"><a href="#处理Session" class="headerlink" title="处理Session"></a>处理Session</h2><blockquote>
<p>使用 requests库跟踪session</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">session = requests.Session()</span><br><span class="line">params = &#123;<span class="string">'username'</span>: <span class="string">'username'</span>, <span class="string">'password'</span>: <span class="string">'password'</span>&#125;</span><br><span class="line">s = session.post(<span class="string">"http://pythonscraping.com/pages/cookies/welcome.php"</span>, params) </span><br><span class="line">print(<span class="string">"Cookie is set to:"</span>)</span><br><span class="line">print(s.cookies.get_dict())</span><br><span class="line">print(<span class="string">"-----------"</span>)</span><br><span class="line">print(<span class="string">"Going to profile page..."</span>)</span><br><span class="line">s = session.get(<span class="string">"http://pythonscraping.com/pages/cookies/profile.php"</span>) </span><br><span class="line">print(s.text)</span><br></pre></td></tr></table></figure>
<h2 id="修改header"><a href="#修改header" class="headerlink" title="修改header"></a>修改header</h2><blockquote>
<p>为了让请求更像是浏览器发出的，需要修改请求头</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">headers = &#123;<span class="string">"User-Agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit 537.36 (KHTML, like Gecko) Chrome"</span>,</span><br><span class="line">           <span class="string">"Accept"</span>:<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"</span>&#125;</span><br><span class="line">url = <span class="string">"https://www.whatismybrowser.com/developers/what-http-headers-is-my-browser-sending"</span> </span><br><span class="line">req = session.get(url, headers=headers)</span><br><span class="line">bsObj = BeautifulSoup(req.text)</span><br><span class="line">print(bsObj.find(<span class="string">"table"</span>,&#123;<span class="string">"class"</span>:<span class="string">"table-striped"</span>&#125;).get_text)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>quick-start</category>
        <category>Python爬虫教程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片-ImageIO介绍</title>
    <url>/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-ImageIO%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<blockquote>
<p>介绍下iOS中ImageIO的概览与应用<br><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462-CH201-TPXREF101" target="_blank" rel="noopener">Image I/O Programming Guide</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> ImageIO框架提供了读取与写入图片数据的基本方法，使用它可以直接获取到图片文件的内容数据，ImageIO具有很多特性 <code>Mac平台上最快的图像解码器和编码器</code> <code>逐步加载图像的能力`</code>支持图像元数据<code></code>有效缓存` ImageIO框架中包含6个头文件:</p>
<ol>
<li>ImageIO.CGImageAnimation</li>
<li>ImageIO.CGImageDestination 负责写入图片数据。</li>
<li>ImageIO.CGImageMetadata 图片文件元数据类</li>
<li>ImageIO.CGImageProperties 定义了框架中使用的字符串常量和宏。</li>
<li>ImageIO.CGImageSource 负责读取图片数据。</li>
<li><p>ImageIO.ImageIOBase 预处理逻辑</p>
<a id="more"></a>
</li>
</ol>
<h2 id="获取支持的图片格式"><a href="#获取支持的图片格式" class="headerlink" title="获取支持的图片格式"></a>获取支持的图片格式</h2><p>ImageIO 框架了解大多数常见的图像文件格式，例如JPEG，JPEG2000，RAW，TIFF，BMP和PNG。并非每个平台都支持所有格式<br>通过 CGImageSourceCopyTypeIdentifiers 和 CGImageDestinationCopyTypeIdentifiers 可以看到支持的图片格式。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回Image IO 支持的统一类型标识符（UTI）数组作为图像源。</span></span><br><span class="line">let mySourceTypes = <span class="built_in">CGImageSourceCopyTypeIdentifiers</span>()</span><br><span class="line"><span class="comment">//返回Image IO 支持的统一类型标识符（UTI）的数组作为图像目标。</span></span><br><span class="line">let myDestTypes = <span class="built_in">CGImageDestinationCopyTypeIdentifiers</span>()</span><br></pre></td></tr></table></figure>
<h2 id="基本使用-获取图片-缩略图"><a href="#基本使用-获取图片-缩略图" class="headerlink" title="基本使用|获取图片 缩略图"></a>基本使用|获取图片 缩略图</h2><p>在平时开发中，我们通常使用UIImage来读取图片，UIImage支持的图片包括png与jpg等，但是类似ico图标，UIImage默认是无法显示的，<br>可以通过ImageIO框架来在iOS系统中使用ico图标，示例如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func getImage() -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    guard let url = Bundle.main.url(forResource: <span class="string">"image.ico"</span>, withExtension: <span class="literal">nil</span>) <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//从URL创建图像源。</span></span><br><span class="line">    guard let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//获取图片</span></span><br><span class="line">    guard let cgImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123; <span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    <span class="comment">//获取缩略图</span></span><br><span class="line">    let thumb = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: cgImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取缩略图"><a href="#获取缩略图" class="headerlink" title="获取缩略图"></a>获取缩略图</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func downsample(imageAt imageURL:URL,to pointSize:<span class="built_in">CGSize</span>,scale:<span class="built_in">CGFloat</span>)-&gt;<span class="built_in">UIImage</span>&#123;</span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSouce = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    </span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width,pointSize.height) * scale</span><br><span class="line">    let downsampleOptions =</span><br><span class="line">     [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize:maxDimensionInPixels</span><br><span class="line">     ] as <span class="built_in">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    let downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSouce, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="渐进渲染大图"><a href="#渐进渲染大图" class="headerlink" title="渐进渲染大图"></a>渐进渲染大图</h2><p>渐进式解码（Progressive Decoding），即不需要完整的图像流数据，允许解码部分帧（大部分情况下，会是图像的部分区域），对部分使用了渐进式编码的格式（参考：<a href="https://en.wikipedia.org/wiki/Interlacing_(bitmaps" target="_blank" rel="noopener">渐进式编码</a>)），则更可以解码出相对模糊但完整的图像。比如说，JPEG支持三种方式的渐进式编码，包括Baseline，interlaced，以及progressive</p>
<p>使用ImageIO框架可以实现大图渐进渲染的效果，一般在对大图片进行网络请求时，可以获取一部分数据就加载一部分数据<br>创建一个空的CGImageSource，然后在每次收到数据的时候调用CGImageSourceUpdateData更新imageSource的数据，接着调用CGImageSourceCreateImageAtIndex获取最新的图片即可</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//demo使用计时器模拟</span></span><br><span class="line"><span class="keyword">class</span> ProgressiveLoadViewController : <span class="built_in">UIViewController</span>&#123;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        incrementTimer = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private var data = Data()</span><br><span class="line">    private var progress: Int = <span class="number">0</span></span><br><span class="line">    private var incrementTimer: Timer? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            oldValue?.invalidate()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private var cgImageSource = <span class="built_in">CGImageSourceCreateIncremental</span>(<span class="literal">nil</span>)</span><br><span class="line">    </span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        guard let data = try? Data(contentsOf: URL(string: <span class="string">"some url"</span>)!) <span class="keyword">else</span> &#123;</span><br><span class="line">            print(<span class="string">"failed to load image source"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.data = data</span><br><span class="line">        <span class="keyword">self</span>.progress = <span class="number">0</span></span><br><span class="line">        <span class="comment">//要渐进显示的图片</span></span><br><span class="line">        guard let cgImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(<span class="keyword">self</span>.cgImageSource, <span class="number">0</span>, <span class="literal">nil</span>) <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        let uiImage = <span class="built_in">UIImage</span>(cgImage: cgImage)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func viewWillAppear(_ animated: Bool) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.incrementTimer = Timer.scheduledTimer(timeInterval: <span class="number">0.25</span>, target: <span class="keyword">self</span>,</span><br><span class="line">                                                   selector: <span class="meta">#selector(self.incrementImage), userInfo: nil, repeats: true)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc func incrementImage()&#123;</span><br><span class="line">        <span class="keyword">self</span>.progress += <span class="number">500</span></span><br><span class="line">        let chunk = <span class="keyword">self</span>.data.prefix(<span class="keyword">self</span>.progress)</span><br><span class="line">        <span class="keyword">if</span> chunk.count == <span class="keyword">self</span>.data.count &#123;</span><br><span class="line">            <span class="keyword">self</span>.incrementTimer = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageSourceUpdateData</span>(<span class="keyword">self</span>.cgImageSource, Data(chunk) as <span class="built_in">CFData</span>, chunk.count == <span class="keyword">self</span>.data.count)</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取图像格式元数据"><a href="#读取图像格式元数据" class="headerlink" title="读取图像格式元数据"></a>读取图像格式元数据</h2><p>创建好CGImageSource之后，我们是可以立即解码。但是很多情况下，我们需要获取一些相关的图像信息，包括图像的格式，图像数量，EXIF元数据等。在真正解码之前，我们可以拿到这些数据，进行一些处理，之后再开始解码过程。</p>
<p>其中，这些信息可以直接在CGImageSource上获取：</p>
<ul>
<li>图像格式：CGImageSourceGetType</li>
<li>图像数量（动图）：CGImageSourceGetCount</li>
</ul>
<p>其他的，需要通过获取属性列表来查询。对于图像容器的属性（EXIF等），我们需要使用CGImageSourceCopyProperties即可，然后根据不同的Key去获取对应的信息。</p>
<p>其实苹果还有一套CGImageSourceCopyMetadataAtIndex，对应的数据不是字典，而是一个CGImageMetadata，再通过其他方法去取。这套API使用起来也是可以的，读取数据和前者是完全兼容一致的，优点是能够进行自定义扩展（比如说你有非标准的图像信息想自己添加和删除）。一般来说使用前者就足够了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>方法都会返回一个字典，字典中可能包含如下有意义的键：</span><br><span class="line"></span><br><span class="line"><span class="comment">//TIFF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyTIFFDictionary;</span><br><span class="line">/GIF信息字典</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyGIFDictionary;</span><br><span class="line"><span class="comment">//JFIF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyJFIFDictionary;</span><br><span class="line"><span class="comment">//EXif信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyExifDictionary;</span><br><span class="line"><span class="comment">//PNG信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyPNGDictionary;</span><br><span class="line"><span class="comment">//IPTC信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyIPTCDictionary;</span><br><span class="line"><span class="comment">//GPS信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyGPSDictionary;</span><br><span class="line"><span class="comment">//原始信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyRawDictionary;</span><br><span class="line"><span class="comment">//CIFF信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyCIFFDictionary;</span><br><span class="line"><span class="comment">//佳能相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerCanonDictionary;</span><br><span class="line"><span class="comment">//尼康相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerNikonDictionary;</span><br><span class="line"><span class="comment">//柯尼卡相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerMinoltaDictionary;</span><br><span class="line"><span class="comment">//富士相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerFujiDictionary;</span><br><span class="line"><span class="comment">//奥林巴斯相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerOlympusDictionary;</span><br><span class="line"><span class="comment">//宾得相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerPentaxDictionary;</span><br><span class="line"><span class="comment">//对应Photoshop相片的信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImageProperty8BIMDictionary;</span><br><span class="line"><span class="comment">//NDG信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyDNGDictionary ;</span><br><span class="line"><span class="comment">//ExifAux信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyExifAuxDictionary;</span><br><span class="line"><span class="comment">//OpenEXR信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyOpenEXRDictionary;</span><br><span class="line"><span class="comment">//Apple相机信息字典</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFStringRef</span> kCGImagePropertyMakerAppleDictionary ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="显示GIF"><a href="#显示GIF" class="headerlink" title="显示GIF"></a>显示GIF</h2><ol>
<li>首先使用ImageIO库中的CGImageSource加载Gif文件。</li>
<li>通过CGImageSource获取到Gif文件中的总的帧数，以及每一帧的显示时间。</li>
<li>通过CAKeyframeAnimation来完成Gif动画的播放。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func getGif(url:URL)&#123;</span><br><span class="line">    guard let source = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>) <span class="keyword">else</span> &#123;<span class="keyword">return</span>;&#125;;</span><br><span class="line">    <span class="comment">//获取gif中图片的个数</span></span><br><span class="line">    let count = <span class="built_in">CGImageSourceGetCount</span>(source)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0.</span>..count &#123;</span><br><span class="line">        let image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(source, index, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">//获取图片信息</span></span><br><span class="line">        let info = <span class="built_in">CGImageSourceCopyProperties</span>(source, <span class="literal">nil</span>) as! <span class="built_in">NSDictionary</span></span><br><span class="line">        let width = info[kCGImagePropertyWidth]</span><br><span class="line">        let height = info[kCGImagePropertyHeight]</span><br><span class="line">        let timeDic = info[kCGImagePropertyGIFDictionary]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建动画图片"><a href="#创建动画图片" class="headerlink" title="创建动画图片"></a>创建动画图片</h2><ol>
<li>首先，它创建一对字典来保存动画属性。第一个字典指定动画PNG在停止到最后一帧之前应重复其动画的时间。第二个字典指定序列中每个帧使用的帧延迟。</li>
<li>创建图像目标之后，代码将设置目标图像的文件属性，然后一次添加一个帧。</li>
<li>最后，CGImageDestinationFinalize调用该方法以完成动画PNG。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func createAnimatePng(fileURL:<span class="built_in">CFURL</span>,kUTTypePNG:<span class="built_in">CFString</span>,imageForFrame)&#123;</span><br><span class="line">    let loopCount = <span class="number">1</span></span><br><span class="line">    let frameCount = <span class="number">60</span></span><br><span class="line">     </span><br><span class="line">    var fileProperties = <span class="built_in">NSMutableDictionary</span>()</span><br><span class="line">    fileProperties.setObject(kCGImagePropertyPNGDictionary, forKey: <span class="built_in">NSDictionary</span>(dictionary: [kCGImagePropertyAPNGLoopCount: frameCount]))</span><br><span class="line">     </span><br><span class="line">    var frameProperties = <span class="built_in">NSMutableDictionary</span>()</span><br><span class="line">    frameProperties.setObject(kCGImagePropertyPNGDictionary, forKey: <span class="built_in">NSDictionary</span>(dictionary: [kCGImagePropertyAPNGDelayTime: <span class="number">1.0</span> / Double(frameCount)]))</span><br><span class="line">     </span><br><span class="line">    guard let destination = <span class="built_in">CGImageDestinationCreateWithURL</span>(fileURL, kUTTypePNG, frameCount, <span class="literal">nil</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Provide error handling here.</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">CGImageDestinationSetProperties</span>(destination, fileProperties.copy() as? <span class="built_in">NSDictionary</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;frameCount &#123;</span><br><span class="line">        autoreleasepool &#123;</span><br><span class="line">            let radians = M_PI * <span class="number">2.0</span> * Double(i) / Double(frameCount)</span><br><span class="line">            guard let image = imageForFrame(size: <span class="built_in">CGSize</span>(width: <span class="number">300</span>, height: <span class="number">300</span>)) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGImageDestinationAddImage</span>(destination, image, frameProperties)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> !<span class="built_in">CGImageDestinationFinalize</span>(destination) &#123;</span><br><span class="line">        <span class="comment">// Provide error handling here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图片编码-CGImageDestination"><a href="#图片编码-CGImageDestination" class="headerlink" title="图片编码 | CGImageDestination"></a>图片编码 | CGImageDestination</h2><p>imageIO中使用CGImageDestination对静态图的编码，基本可以分为以下步骤：</p>
<ul>
<li>创建CGImageDestination</li>
<li>添加图像格式元数据（可选）和CGImage</li>
<li>编码得到NSData，清理</li>
</ul>
<h3 id="1-创建CGImageDestination"><a href="#1-创建CGImageDestination" class="headerlink" title="1. 创建CGImageDestination"></a>1. 创建CGImageDestination</h3><p>CGImageDestination的创建也有三个接口，你需要提供一个输出的目标来输出解码后的数据。同时，由于编码需要提供文件格式，你需要指明对应编码的文件格式，用的是UTI Type。对于静态图来说，第三个参数的数量都写1即可。</p>
<ul>
<li>CGImageDestinationCreateWithData：指定一个可变二进制数据作为输出</li>
<li>CGImageDestinationCreateWithURL：指定一个文件路径作为输出</li>
<li>CGImageDestinationCreateWithDataConsumer：指定一个DataConsumer作为输出</li>
</ul>
<h3 id="2-添加图像格式元数据（可选）和CGImage"><a href="#2-添加图像格式元数据（可选）和CGImage" class="headerlink" title="2. 添加图像格式元数据（可选）和CGImage"></a>2. 添加图像格式元数据（可选）和CGImage</h3><p>接下来就是添加图像了，由于CGImage只是包含基本的图像信息，很多额外信息比如说EXIF都已经丢失了，如果我们需要，可以添加对应的元信息。不像解码那样提供了两个API分别获取元信息和图像。使用的接口是CGImageDestinationAddImage。</p>
<p>当然，如果有自定义的元信息，可以通过另外的CGImageDestinationAddImageAndMetadata来添加CGImageMetadata，这个上面解码也说到过，这里就不解释了。</p>
<p>此外，还有一个ImageIO最强大的功能，叫做CGImageDestinationAddImageFromSource（这个东西可以媲美vImageConvert_AnyToAny，后续教程会谈到），这个能够从一个任意的CGImageSource，添加一个图像帧到任意一个CGImageDestination。这个一般的用途，就是专门给图像转换器用的，比如说从图像格式A，转换到图像格式B。我们不需要先解码到A的UIImage，再通过编码到B的NSData，直接在中间就进行了转换。能够极大地提升转换效率（Image/IO底层就是通过vImage，传的是Bitmap的引用，没有额外的消耗）。不过这篇教程侧重于Image/IO的编码和解码，转换可以自行参考处理，不再详细说明了。</p>
<h3 id="3-编码得到NSData，清理"><a href="#3-编码得到NSData，清理" class="headerlink" title="3. 编码得到NSData，清理"></a>3. 编码得到NSData，清理</h3><p>当添加完成所有需要编码的CGImage之后，最后一步，就是进行编码，得到图像格式的数据。这里直接用一个方法CGImageDestinationFinalize即可，编码得到的数据，会写入最早初始化时提供的Data或者DataConsumer。</p>
]]></content>
      <categories>
        <category>iOS图片</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片-位图信息与图片解码</title>
    <url>/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E4%BD%8D%E5%9B%BE%E4%BF%A1%E6%81%AF%E4%B8%8E%E5%9B%BE%E7%89%87%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>介绍下几种iOS中位图信息 与相关解压缩<br>ref <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="noopener">谈谈 iOS 中图片的解压缩</a><br>ref <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007533-SW1" target="_blank" rel="noopener">Quartz 2D Programming Guide</a></p>
</blockquote>
<p>我们从网络下载或者从本地磁盘加载一张图片到屏幕上显示，要经过图片的解码过程，为什么呢？因为我们一般的图片格式例如 JPEG，PNG都是经过压缩后的图片，而显示在屏幕上的图片叫做位图(bitmap)，所谓的解码就是把压缩后的图片变成位图。</p>
<p>为什么非要解码成位图才能显示呢？因为位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，就可以在屏幕上渲染整张图片了。</p>
<p>那我们为什么还需要不同格式的各种图片呢？直接全部用位图不就好了？那不就不需要每次解码了？那些JPEG以及PNG等其实都是图像的压缩格式，我们都知道压缩的意思就是减小空间，所以我们可以想到，使用这些格式的原因就是位图实在太大了。</p>
<h2 id="图片解压后的数据变化"><a href="#图片解压后的数据变化" class="headerlink" title="图片解压后的数据变化"></a>图片解压后的数据变化</h2><a id="more"></a>
<p>我们来使用这张图片和以下代码做例子：</p>
<p><img src="/res/iOSImg/testImg2.png" style="background-color: rgba(0,0,300,.5)"><br>该图片的二进制信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452  .PNG........IHDR</span><br><span class="line">00000010: 0000 0022 0000 0022 0803 0000 000d 99fb  ...&quot;...&quot;........</span><br><span class="line">00000020: f000 0000 5d50 4c54 4500 0000 ffff ffff  ....]PLTE.......</span><br><span class="line">00000030: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000040: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000050: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000060: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000070: ffff ffff ffff ffff ffff ffff ffff ffff  ................</span><br><span class="line">00000080: ffff ffff ffff 512a fbe5 0000 001e 7452  ......Q*......tR</span><br><span class="line">00000090: 4e53 001c b890 7103 faa9 580d f7c8 09f0  NS....q...X.....</span><br><span class="line">000000a0: be42 1685 78e2 d4c5 b1a1 604d 492d 1e0f  .B..x.....`MI-..</span><br><span class="line">000000b0: 5dbe 24b2 0000 0084 4944 4154 38cb edcf  ].$.....IDAT8...</span><br><span class="line">000000c0: cb0a c240 1044 d1d2 38ad 8e19 4de2 fb55  ...@.D..8...M..U</span><br><span class="line">000000d0: ffff 99d2 4d70 971a 5097 de5d c381 a630  ....Mp..P..]...0</span><br><span class="line">000000e0: d113 952e 7b96 be55 a2a1 b76d b538 981b  ....&#123;..U...m.8..</span><br><span class="line">000000f0: 2516 d865 374a 6034 428c a611 228c 3127  %..e7J`4B...&quot;.1&apos;</span><br><span class="line">00000100: 21bc 23f9 d062 4596 a485 9143 552c d35f  !.#..bE....CU,._</span><br><span class="line">00000110: 7c27 faaa 4856 1358 939b f7d1 e510 9298  |&apos;..HV.X........</span><br><span class="line">00000120: 0b49 70bf 2548 127d 4aca 7cba d335 46cb  .Ip.%H.&#125;J.|..5F.</span><br><span class="line">00000130: 0a80 4193 73bc 9a89 3afc a817 5dd5 1a7c  ..A.s...:...]..|</span><br><span class="line">00000140: 84ac 48f9 0000 0000 4945 4e44 ae42 6082  ..H.....IEND.B`.</span><br></pre></td></tr></table></figure>
<p>获取图片解压信息的代码为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * path = [[<span class="built_in">NSBundle</span> mainBundle]pathForResource:<span class="string">@"testImg2"</span> ofType:<span class="string">@"png"</span>];</span><br><span class="line"><span class="built_in">NSURL</span> * url = [<span class="built_in">NSURL</span> fileURLWithPath:path];</span><br><span class="line"><span class="built_in">CGImageSourceRef</span> myImageSource = <span class="built_in">CGImageSourceCreateWithURL</span>((<span class="built_in">CFURLRef</span>)url, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CGImageRef</span> myImage = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(myImageSource,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CFRelease</span>(myImageSource);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFDataRef</span> rawData = <span class="built_in">CGDataProviderCopyData</span>(<span class="built_in">CGImageGetDataProvider</span>(myImage));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"rawData %@"</span>,rawData);</span><br></pre></td></tr></table></figure>
<p>这张图片像素尺寸为34x34,文件大小为 336Byte ；而获取到图片原始像素数据rawData，大小为4624byte。以下为rawData信息 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">00000000 ffffff90 ffffffff ffffffff ffffffff ffffff71 00000000 ffffff42 fffffff7 </span><br><span class="line">ffffffff ffffffff ffffffbe ffffff09 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 ffffff90 ffffffff </span><br><span class="line">ffffffff ffffffff ffffff71 00000000 00000000 00000000 ffffff42 fffffff7 ffffffff </span><br><span class="line">ffffffff ffffffbe ffffff09 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 ffffff90 ffffffff ffffffff ffffffff ffffff71 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 ffffff42 fffffff7 ffffffff ffffffff </span><br><span class="line">ffffff90 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>也就是说，这张PNG 图片解压缩后的大小是 4624byte ，是原始文件大小的 4.27 倍。那么这个4624byte是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>
<p><strong><em>解压缩后的图片大小 = 图片的像素宽 34 </em> 图片的像素高 34 <em> 每个像素所占的字节数 4</em></strong></p>
<p>我们常见接触到的图片格式， JPEG 还是 PNG 图片，都是一种压缩的<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html" target="_blank" rel="noopener">位图图形格式</a>。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作。</p>
<h2 id="位图信息"><a href="#位图信息" class="headerlink" title="位图信息"></a>位图信息</h2><p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html" target="_blank" rel="noopener">Bitmap Images and Image Masks</a>中是这么定义的：</p>
<blockquote>
<p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.<br>Each sample in a bitmap contains one or more color components in a specified color space, plus one additional component that specifies the alpha value to indicate transparency. Each component can be from 1 to as many as 32 bits. In Mac OS X, Quartz also provides support for floating-point components. The supported formats in Mac OS X and iOS are described in “Pixel formats supported for bitmap graphics contexts”. ColorSync provides color space support for bitmap images.</p>
</blockquote>
<p>Quartz在创建位图图像（CGImageRef）时使用以下信息：</p>
<ul>
<li><em>data source</em> 位图数据源，可以是Quartz数据提供程序或Quartz图像源。</li>
<li><em>Pixel Format</em> 像素格式，包括每个组件的位数，每个像素的位数和每行的字节数。</li>
<li><em>Color Spaces and Bitmap Layout</em> 对于图像，颜色空间和位图布局（颜色空间和位图布局）信息用于描述alpha的位置以及位图是否使用浮点值。</li>
<li><em>Decode Array</em> 可选的解码数组。</li>
<li>插值设置，它是一个布尔值，它指定在调整图像大小时，Quartz是否应应用插值算法。</li>
<li>一个渲染意图，指定如何映射位于图形上下文的目标颜色空间内的颜色。</li>
<li>图像尺寸。</li>
</ul>
<h3 id="解码数组-Decode-Array"><a href="#解码数组-Decode-Array" class="headerlink" title="解码数组 Decode Array"></a>解码数组 Decode Array</h3><p>解码数组将图像颜色值映射到其他颜色值，这对于诸如使图像去饱和或反转颜色之类的任务很有用。该数组包含每个颜色分量的一对数字。Quartz渲染图像时，它将应用线性变换将原始分量值映射到适合目标色彩空间的指定范围内的相对数字。例如，RGB颜色空间中图像的解码数组包含六个条目，每个红色，绿色和蓝色分量一对。</p>
<h3 id="像素格式Pixel-Format"><a href="#像素格式Pixel-Format" class="headerlink" title="像素格式Pixel Format"></a>像素格式Pixel Format</h3><p>像素格式包含以下信息：</p>
<ul>
<li><em>Bits per component</em>每个分量的位数，即像素中每个单独颜色分量的位数。对于图像掩模，此值是源像素中有效掩模位的数量。例如，如果源图像是8位掩码，则每个组件指定8位。</li>
<li><em>Bits per pixel</em>每个像素的位数，即源像素的位数。该值必须至少是每个组件的位数乘以每个像素的组件数。</li>
<li><em>Bytes per row</em>每行字节数。图像中每水平行的字节数。</li>
</ul>
<h3 id="颜色与颜色空间-Color-and-Color-Spaces"><a href="#颜色与颜色空间-Color-and-Color-Spaces" class="headerlink" title="颜色与颜色空间 Color and Color Spaces"></a>颜色与颜色空间 Color and Color Spaces</h3><p><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101" target="_blank" rel="noopener">Color and Color Spaces</a>中说明了Quartz中的颜色由一组值表示。如果没有颜色空间指示如何解释颜色信息，则这些值将毫无意义。例如，表4-1中的值全部代表全强度的蓝色。但是，如果不知道颜色空间或每种颜色空间的允许值范围，就无法知道每组值代表哪种颜色。</p>
<p>表4-1   不同颜色空间中的颜色值</p>
<table>
<thead>
<tr>
<th style="text-align:left">values</th>
<th style="text-align:center">color space</th>
<th style="text-align:right">compoents</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">240 degrees, 100%, 100%</td>
<td style="text-align:center">HSB</td>
<td style="text-align:right">Hue, saturation, brightness</td>
</tr>
<tr>
<td style="text-align:left">0, 0, 1</td>
<td style="text-align:center">RGB</td>
<td style="text-align:right">Red, green, blue</td>
</tr>
<tr>
<td style="text-align:left">1, 1, 0, 0</td>
<td style="text-align:center">CMYK</td>
<td style="text-align:right">Cyan, magenta, yellow, black</td>
</tr>
<tr>
<td style="text-align:left">1, 0, 0</td>
<td style="text-align:center">BGR</td>
<td style="text-align:right">Blue, green, red</td>
</tr>
</tbody>
</table>
<p>如果提供错误的色彩空间，则可能会出现很大的差异，如图4-1所示。尽管绿色在BGR和RGB颜色空间中的解释相同，但是红色和蓝色值却被翻转了。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/color_profiles.gif" alt></p>
<h3 id="位图布局-Bitmap-Layout"><a href="#位图布局-Bitmap-Layout" class="headerlink" title="位图布局 Bitmap Layout"></a>位图布局 Bitmap Layout</h3><p>想确保 Quartz 能够正确地解析像素格式中各个bit所代表的含义，我们还需要提供位图的布局信息 <code>CGBitmapInfo</code> ：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, <span class="built_in">CGBitmapInfo</span>) &#123;</span><br><span class="line">    kCGBitmapAlphaInfoMask = <span class="number">0x1F</span>,</span><br><span class="line"></span><br><span class="line">    kCGBitmapFloatInfoMask = <span class="number">0xF00</span>,</span><br><span class="line">    kCGBitmapFloatComponents = (<span class="number">1</span> &lt;&lt; <span class="number">8</span>),</span><br><span class="line"></span><br><span class="line">    kCGBitmapByteOrderMask     = kCGImageByteOrderMask,</span><br><span class="line">    kCGBitmapByteOrderDefault  = kCGImageByteOrderDefault,</span><br><span class="line">    kCGBitmapByteOrder16Little = kCGImageByteOrder16Little,</span><br><span class="line">    kCGBitmapByteOrder32Little = kCGImageByteOrder32Little,</span><br><span class="line">    kCGBitmapByteOrder16Big    = kCGImageByteOrder16Big,</span><br><span class="line">    kCGBitmapByteOrder32Big    = kCGImageByteOrder32Big</span><br><span class="line">&#125; <span class="built_in">CG_AVAILABLE_STARTING</span>(<span class="number">10.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p>它主要提供了三个方面的布局信息：</p>
<ul>
<li>alpha 的信息 CGImageAlphaInfo；</li>
<li>颜色分量是否为浮点数；</li>
<li>像素格式的字节顺序 Byte Ordering。</li>
</ul>
<h4 id="透明信息-CGImageAlphaInfo"><a href="#透明信息-CGImageAlphaInfo" class="headerlink" title="透明信息 CGImageAlphaInfo"></a>透明信息 CGImageAlphaInfo</h4><p>其中，alpha 的信息由枚举值 CGImageAlphaInfo 来表示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageAlphaInfo</span>) &#123;</span><br><span class="line">    kCGImageAlphaNone,               <span class="comment">/* For example, RGB. */</span></span><br><span class="line">    kCGImageAlphaPremultipliedLast,  <span class="comment">/* For example, premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaPremultipliedFirst, <span class="comment">/* For example, premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaLast,               <span class="comment">/* For example, non-premultiplied RGBA */</span></span><br><span class="line">    kCGImageAlphaFirst,              <span class="comment">/* For example, non-premultiplied ARGB */</span></span><br><span class="line">    kCGImageAlphaNoneSkipLast,       <span class="comment">/* For example, RBGX. */</span></span><br><span class="line">    kCGImageAlphaNoneSkipFirst,      <span class="comment">/* For example, XRGB. */</span></span><br><span class="line">    kCGImageAlphaOnly                <span class="comment">/* No color data, alpha data only */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：</p>
<ul>
<li>是否包含 alpha ；</li>
<li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的最低有效位，比如 RGBA ，还是最高有效位，比如 ARGB ；</li>
<li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。</li>
</ul>
<h4 id="字节顺序-CGImageByteOrderInfo"><a href="#字节顺序-CGImageByteOrderInfo" class="headerlink" title="字节顺序 CGImageByteOrderInfo"></a>字节顺序 CGImageByteOrderInfo</h4><p>字节的排列方式有两个通用规则。例如，一个多位的整数，按照存储地址从低到高排序的字节中，如果该整数的最低有效字节（类似于最低有效位）在最高有效字节的前面，则称小端序；反之则称大端序。</p>
<p><a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH" target="_blank" rel="noopener">字节顺序</a>的信息由枚举值 CGImageByteOrderInfo 来表示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_ENUM</span>(uint32_t, <span class="built_in">CGImageByteOrderInfo</span>) &#123;</span><br><span class="line">    kCGImageByteOrderMask     = <span class="number">0x7000</span>,</span><br><span class="line">    kCGImageByteOrder16Little = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Little = (<span class="number">2</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder16Big    = (<span class="number">3</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    kCGImageByteOrder32Big    = (<span class="number">4</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">&#125; <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_12, __IPHONE_10_0);</span><br></pre></td></tr></table></figure>
<p>它主要提供了两个方面的字节顺序信息：</p>
<ul>
<li>小端序还是大端序；</li>
<li>数据以 16 位还是 32 位为单位。</li>
</ul>
<p>下图表示了 Quartz 2D中CMYK和RGB颜色空间的32位和16位像素格式<br><img src="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Art/colorformatrgba32.gif" alt></p>
<h3 id="支持的像素格式"><a href="#支持的像素格式" class="headerlink" title="支持的像素格式"></a>支持的像素格式</h3><p>下表表示了位图图形上下文支持的像素格式，关联的色彩空间 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB" target="_blank" rel="noopener">Supported Pixel Formats</a>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">cs</th>
<th style="text-align:center">Pixel format and bitmap information constant</th>
<th style="text-align:right">Availability</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Null</td>
<td style="text-align:center">8 bpp, 8 bpc, kCGImageAlphaOnly</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">Gray</td>
<td style="text-align:center">8 bpp, 8 bpc,kCGImageAlphaNone</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">Gray</td>
<td style="text-align:center">8 bpp, 8 bpc,kCGImageAlphaOnly</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">Gray</td>
<td style="text-align:center">16 bpp, 16 bpc, kCGImageAlphaNone</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">Gray</td>
<td style="text-align:center">32 bpp, 32 bpc, kCGImageAlphaNone或kCGBitmapFloatComponents`</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">16 bpp, 5 bpc, kCGImageAlphaNoneSkipFirst</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNoneSkipFirst</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNoneSkipLast</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaPremultipliedFirst</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaPremultipliedLast</td>
<td style="text-align:right">Mac OS X, iOS</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaPremultipliedLast</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaNoneSkipLast</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaNoneSkipLast 或kCGBitmapFloatComponents</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">RGB</td>
<td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaPremultipliedLast 或kCGBitmapFloatComponents</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">CMYK</td>
<td style="text-align:center">32 bpp, 8 bpc, kCGImageAlphaNone</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">CMYK</td>
<td style="text-align:center">64 bpp, 16 bpc, kCGImageAlphaNone</td>
<td style="text-align:right">Mac OS X</td>
</tr>
<tr>
<td style="text-align:left">CMYK</td>
<td style="text-align:center">128 bpp, 32 bpc, kCGImageAlphaNone 或kCGBitmapFloatComponents</td>
<td style="text-align:right">Mac OS X</td>
</tr>
</tbody>
</table>
<p>对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间</p>
<h2 id="CGBitmapContextCreate"><a href="#CGBitmapContextCreate" class="headerlink" title="CGBitmapContextCreate"></a>CGBitmapContextCreate</h2><p>上面说了这么多参数，那么那个函数会用到呢？答案是 <code>CGBitmapContextCreate</code> :</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a bitmap context. The context draws into a bitmap which is `width'</span></span><br><span class="line"><span class="comment">   pixels wide and `height' pixels high. The number of components for each</span></span><br><span class="line"><span class="comment">   pixel is specified by `space', which may also specify a destination color</span></span><br><span class="line"><span class="comment">   profile. The number of bits for each component of a pixel is specified by</span></span><br><span class="line"><span class="comment">   `bitsPerComponent'. The number of bytes per pixel is equal to</span></span><br><span class="line"><span class="comment">   `(bitsPerComponent * number of components + 7)/8'. Each row of the bitmap</span></span><br><span class="line"><span class="comment">   consists of `bytesPerRow' bytes, which must be at least `width * bytes</span></span><br><span class="line"><span class="comment">   per pixel' bytes; in addition, `bytesPerRow' must be an integer multiple</span></span><br><span class="line"><span class="comment">   of the number of bytes per pixel. `data', if non-NULL, points to a block</span></span><br><span class="line"><span class="comment">   of memory at least `bytesPerRow * height' bytes. If `data' is NULL, the</span></span><br><span class="line"><span class="comment">   data for context is allocated automatically and freed when the context is</span></span><br><span class="line"><span class="comment">   deallocated. `bitmapInfo' specifies whether the bitmap should contain an</span></span><br><span class="line"><span class="comment">   alpha channel and how it's to be generated, along with whether the</span></span><br><span class="line"><span class="comment">   components are floating-point or integer. */</span></span><br><span class="line"><span class="built_in">CG_EXTERN</span> <span class="built_in">CGContextRef</span> __<span class="keyword">nullable</span> <span class="built_in">CGBitmapContextCreate</span>(<span class="keyword">void</span> * __<span class="keyword">nullable</span> data,</span><br><span class="line">    size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> cg_nullable space, uint32_t bitmapInfo)</span><br><span class="line">    <span class="built_in">CG_AVAILABLE_STARTING</span>(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure>
<p>顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 width 像素，高 height 像素的位图。各参数使用如下：</p>
<ul>
<li>data ：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow * height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；</li>
<li>width 和 height ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li>
<li>bitsPerComponent ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li>
<li>bytesPerPixel：表示一个像素点有多少个字节组成，上面的方法注释中提到了一个公式 <code>(bitsPerComponent * number of components + 7)/8</code>，即一个像素点的字节数量与表示当前图像的颜色的颜色分量数量和每个分量的位数有关</li>
<li>bytesPerRow ：位图的每一行使用的字节数，大小至少为 width * bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化</li>
<li>space ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li>
<li>bitmapInfo ：就是我们前面提到的位图的布局信息。</li>
</ul>
<p>文章开头说 <code>解压缩后的图片大小 = 图片的像素宽 34 * 图片的像素高 34 * 每个像素所占的字节数4</code> ; 我们的手机一般支持 RGB 颜色空间，现在就是知道了 RGB 颜色空间中，实际上是有 4 个分量，所以我们可以算出 bytesPerPixel = (8 * 4 + 7)/8 = 4B。所以我们现在知道为什么最开始的时候我们计算位图的大小的时候，每个像素的大小我们使用的值是 4B 了。事实上不同的颜色空间下，上面这些值都是不同的，但是一般在手机上，我们使用 RGB 颜色空间，所以差不多就是上面的值。</p>
<h3 id="YYImage中使用"><a href="#YYImage中使用" class="headerlink" title="YYImage中使用"></a>YYImage中使用</h3><p>现在来看下YYImage中的解码代码 ，先使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；再用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；最后使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> YYCGImageCreateDecodedCopy(<span class="built_in">CGImageRef</span> imageRef, <span class="built_in">BOOL</span> decodeForDisplay) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (decodeForDisplay) &#123; <span class="comment">//decode with redraw (may lose some precision)</span></span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef) &amp; kCGBitmapAlphaInfoMask;</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (alphaInfo == kCGImageAlphaPremultipliedLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alphaInfo == kCGImageAlphaLast ||</span><br><span class="line">            alphaInfo == kCGImageAlphaFirst) &#123;</span><br><span class="line">            hasAlpha = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BGRA8888 (premultiplied) or BGRX8888</span></span><br><span class="line">        <span class="comment">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span></span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef); <span class="comment">// decode</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CFRelease</span>(context);</span><br><span class="line">        <span class="keyword">return</span> newImage;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImage中使用"><a href="#SDWebImage中使用" class="headerlink" title="SDWebImage中使用"></a>SDWebImage中使用</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">UIImage</span> shouldDecodeImage:image]) &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// autorelease the bitmap context and all vars to help system to free memory when there are memory warning.</span></span><br><span class="line">    <span class="comment">// on iOS7, do not forget to call [[SDImageCache sharedImageCache] clearMemory];</span></span><br><span class="line">    <span class="keyword">@autoreleasepool</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = [<span class="built_in">UIImage</span> colorSpaceForImageRef:imageRef];</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</span><br><span class="line">        size_t bytesPerRow = kBytesPerPixel * width;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></span><br><span class="line">        <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></span><br><span class="line">        <span class="comment">// to create bitmap graphics contexts without alpha info.</span></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     bytesPerRow,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     kCGBitmapByteOrderDefault|kCGImageAlphaNoneSkipLast);</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Draw the image into the context and retrieve the new bitmap image without alpha</span></span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [<span class="built_in">UIImage</span> imageWithCGImage:imageRefWithoutAlpha</span><br><span class="line">                                                         scale:image.scale</span><br><span class="line">                                                   orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)shouldDecodeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="comment">// Prevent "CGBitmapContextCreateImage: invalid context 0x0" error</span></span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not decode animated images</span></span><br><span class="line">    <span class="keyword">if</span> (image.images != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageAlphaInfo</span> alpha = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</span><br><span class="line">    <span class="built_in">BOOL</span> anyAlpha = (alpha == kCGImageAlphaFirst ||</span><br><span class="line">                     alpha == kCGImageAlphaLast ||</span><br><span class="line">                     alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">                     alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">    <span class="comment">// do not decode images with alpha</span></span><br><span class="line">    <span class="keyword">if</span> (anyAlpha) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDWebImage 中和其他不一样的地方，就是如果一张图片有 alpha 分量，那就直接返回原始图片，不再进行解码操作。我猜测作者这样写，是不是因为觉得对于有 alpha 分量的图片，因为上下文创建中那些参数的缘故，解码之后可能会与原始图像有偏差，干脆就不解码了。</p>
<p>SDWebImage 在解码操作外面包了 autoreleasepool，这样在大量图片需要解码的时候，可以使得局部变量尽早释放掉，不会造成内存峰值过高。其他创建上下文，然后调用 CGContextDrawImage，再调用CGBitmapContextCreateImage获取创建后的位图，和 YYImage 基本一样，就是个别参数设置不同。</p>
]]></content>
      <categories>
        <category>iOS图片</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片-像素操作</title>
    <url>/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E5%83%8F%E7%B4%A0%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>介绍下常见的几种对图片的像素级操作<br>1.修改颜色 2. 颜色空间变化 3.lsb 隐藏信息 4. 颜色混合  5. 马赛克</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 <a href="../iOS图片-位图信息与图片解码/">iOS图片-位图信息与图片解码</a> 中介绍了位图信息中像素 颜色空间等概念。这次来实践一下如何对图片的像素进行操作。位图又被叫做点阵图像，也就是说位图包含了一大堆的像素点信息，这些像素点就是该图片中的点，有了图片中每个像素点的信息，我们就知道如何对图片进行像素级操作了。</p>
<h2 id="将一张图片修改为蓝色"><a href="#将一张图片修改为蓝色" class="headerlink" title="将一张图片修改为蓝色"></a>将一张图片修改为蓝色</h2><p>由于在iOS开发中使用的位图大部分是32位RGBA模式，所以我们先说下这种模式的简单图像处理。<br>首先我们需要知道什么是32位RGBA模式的位图。32位就表示一个这种模式位图的一个像素所占内存为32位，也就是4个字节的长度。R、G、B、A分别代表red，green，blue和alpha，也就是颜色组成的三原色与透明度值。RGBA每一个占用一个字节的内存。<br>知道了上面这些，我们就有了思路：通过改变每一个像素中的RGBA值来进行一些位图图像的处理了。</p>
 <a id="more"></a>
<p>示例代码 效果如下: </p>
<p>将原图片 <img src="/res/iOSImg/Share.png" alt> 转换为蓝色图片<br><img src="/res/iOSImg/sample1ResultImg.png" alt></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1 将一张图片变为蓝色</span></span><br><span class="line"><span class="built_in">UIImage</span>* sampleImg1 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"share.png"</span>];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* sample1ResultImg = [<span class="keyword">self</span>.class sample1With:sampleImg1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"示例1 将一张图片变为蓝色 END"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span>*)sample1With:(<span class="built_in">UIImage</span>*)originImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图 像素rgba信息</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"><span class="comment">//            NSLog(@"r %d,g %d,b %d,a %d",thisR,thisG,thisB,thisA);</span></span><br><span class="line">            <span class="keyword">if</span>(thisA)&#123;<span class="comment">//透明不处理 其他变为蓝色</span></span><br><span class="line">                thisR = <span class="number">0</span>;</span><br><span class="line">                thisG = <span class="number">0</span>;</span><br><span class="line">                thisB = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="像素格式色彩空间变为灰色"><a href="#像素格式色彩空间变为灰色" class="headerlink" title="像素格式色彩空间变为灰色"></a>像素格式色彩空间变为灰色</h2><p>iOS 支持的组合不多 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB" target="_blank" rel="noopener">Supported Pixel Formats</a></p>
<p>这里尝试将像素格式色彩空间变为灰色 示例代码 效果如下: </p>
<p>将原图片  <img src="/res/iOSImg/rgb_cs.png" style="width:80%"> 转换为灰色颜色空间图片 <img src="/res/iOSImg/grey_cs.png" style="width:80%"></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例2 像素格式 颜色空间变为灰色</span></span><br><span class="line"><span class="built_in">UIImage</span>* sampleImg2 = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"channel.png"</span>];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">UIImage</span>* sample1ResultImg = [<span class="keyword">self</span>.class sample2With:sampleImg2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"示例2 颜色空间变化 END"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...其他同上例</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceGray</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaOnly);</span><br><span class="line"><span class="comment">//去掉像素处理部分</span></span><br></pre></td></tr></table></figure>
<h2 id="LSB方式隐藏二维码到一张图片"><a href="#LSB方式隐藏二维码到一张图片" class="headerlink" title="LSB方式隐藏二维码到一张图片"></a>LSB方式隐藏二维码到一张图片</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D" target="_blank" rel="noopener">LSB</a>，最低有效位，英文是Least Significant Bit 。我们知道图像像素一般是由RGB三原色（即红绿蓝）组成的，每一种颜色占用8位，0x00~0xFF，即一共有256种颜色，一共包含了256的3次方的颜色，颜色太多，而人的肉眼能区分的只有其中一小部分，这导致了当我们修改RGB颜色分量中最低的二进制位的时候，我们的肉眼是区分不出来的。</p>
<p>鉴于LSB想法，一张普通的二维码图片只有黑色和白色。那么对于RGBA的图片 可以修改R的最低位。0表示白色 1表示黑色，这样处理后肉眼看不出原图修改的痕迹。</p>
<p>示例代码 效果如下: </p>
<p>左图是原图 右图是经过LSB操作的图，肉眼完全看不出区别</p>
<p><img src="/res/iOSImg/LSB.png" alt></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例3 在一张图片中使用lsb方式隐藏二维码 。</span></span><br><span class="line"><span class="comment">//例子里简单处理了 原图和二维码大小相同</span></span><br><span class="line"><span class="built_in">UIImage</span>* oriImg = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"channel.png"</span>];</span><br><span class="line"><span class="built_in">UIImage</span>* qrImg = [<span class="keyword">self</span>.class createQRForAlreadySpliceString:<span class="string">@"一些信息"</span> size:<span class="built_in">CGSizeMake</span>(<span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//将二维码图片信息藏入原图 得到result</span></span><br><span class="line">    <span class="built_in">UIImage</span>* result = [<span class="keyword">self</span> handleImage:oriImg hideQrImage:qrImg];</span><br><span class="line">    <span class="comment">//从result中解析得到二维码</span></span><br><span class="line">    <span class="built_in">UIImage</span>* qrResult = [<span class="keyword">self</span> handleHideImage:result];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"end"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 图片处理 隐藏二维码图片</span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)handleImage:(<span class="built_in">UIImage</span>*)originImg hideQrImage:(<span class="built_in">UIImage</span>*)qrImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line">    <span class="built_in">UInt32</span> * inputQRPixels;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRef</span> inputQRCGImage = [qrImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRWidth = <span class="built_in">CGImageGetWidth</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRHeight = <span class="built_in">CGImageGetHeight</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputQRBytesPerRow = bytesPerPixel * inputQRWidth;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    inputQRPixels = (<span class="built_in">UInt32</span> *)calloc(inputQRHeight * inputQRWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGContextRef</span> qrcontext = <span class="built_in">CGBitmapContextCreate</span>(inputQRPixels, inputQRWidth, inputQRHeight,</span><br><span class="line">                                                 bitsPerComponent, inputQRBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(qrcontext, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputQRWidth, inputQRHeight), inputQRCGImage);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"><span class="comment">//            NSLog(@"r %d,g %d,b %d,a %d",thisR,thisG,thisB,thisA);</span></span><br><span class="line">            <span class="comment">//二维码</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentQRPixel = inputQRPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> qrcolor = *currentQRPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> qrthisR,qrthisG,qrthisB,qrthisA;</span><br><span class="line">            qrthisR=R(qrcolor);</span><br><span class="line">            qrthisG=G(qrcolor);</span><br><span class="line">            qrthisB=B(qrcolor);</span><br><span class="line">            qrthisA=A(qrcolor);</span><br><span class="line">            <span class="comment">//透明度0信息会丢失</span></span><br><span class="line">            <span class="keyword">if</span>(thisA == <span class="number">0</span>)&#123;</span><br><span class="line">                thisA = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//像素最低位处理</span></span><br><span class="line">            <span class="keyword">if</span>(qrthisR &lt; <span class="number">128</span>)&#123;<span class="comment">//二维码白色 设置最低位为0</span></span><br><span class="line">                thisR ^= (thisR &amp; ( <span class="number">1</span> &lt;&lt; <span class="number">0</span>) ) ^ (<span class="number">0</span> &lt;&lt; <span class="number">0</span>) ;</span><br><span class="line"><span class="comment">//                thisA = 255;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//二维码黑色 设置最低位为1</span></span><br><span class="line">                thisR ^= (thisR &amp; ( <span class="number">1</span> &lt;&lt; <span class="number">0</span>) ) ^ (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputQRCGImage);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(qrcontext);</span><br><span class="line">    free(inputQRPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 图片处理 解析二维码</span></span><br><span class="line">- (<span class="built_in">UIImage</span>*)handleHideImage:(<span class="built_in">UIImage</span>*)originImg</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">NSUInteger</span> bytesPerPixel = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">NSUInteger</span> bitsPerComponent = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义最高32位整形指针 *inputPixels</span></span><br><span class="line">    <span class="built_in">UInt32</span> * inputPixels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换图片为CGImageRef,获取参数：长宽高，每个像素的字节数（4），每个R的比特数</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> inputCGImage = [originImg <span class="built_in">CGImage</span>];</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputWidth = <span class="built_in">CGImageGetWidth</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputHeight = <span class="built_in">CGImageGetHeight</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">NSUInteger</span> inputBytesPerRow = bytesPerPixel * inputWidth;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开辟内存区域,指向首像素地址</span></span><br><span class="line">    inputPixels = (<span class="built_in">UInt32</span> *)calloc(inputHeight * inputWidth, <span class="keyword">sizeof</span>(<span class="built_in">UInt32</span>));</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据指针，前面的参数，创建像素层</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(inputPixels, inputWidth, inputHeight,</span><br><span class="line">                                                 bitsPerComponent, inputBytesPerRow, colorSpace,</span><br><span class="line">                                                 kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//根据目前像素在界面绘制图像</span></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, inputWidth, inputHeight), inputCGImage);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">            <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">            thisR=R(color);</span><br><span class="line">            thisG=G(color);</span><br><span class="line">            thisB=B(color);</span><br><span class="line">            thisA=A(color);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//像素最低位处理</span></span><br><span class="line">            <span class="keyword">int</span> tag = (thisR &gt;&gt; <span class="number">0</span>) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tag == <span class="number">0</span>)&#123;<span class="comment">//最低位为0 白色</span></span><br><span class="line">                thisR=<span class="number">255</span>;</span><br><span class="line">                thisG=<span class="number">255</span>;</span><br><span class="line">                thisB=<span class="number">255</span>;</span><br><span class="line">                thisA=<span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//最低位为1 黑色</span></span><br><span class="line">                thisR=<span class="number">0</span>;</span><br><span class="line">                thisG=<span class="number">0</span>;</span><br><span class="line">                thisB=<span class="number">0</span>;</span><br><span class="line">                thisA=<span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *currentPixel = RGBAMake(thisR, thisG, thisB, thisA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新图</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> newCGImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="built_in">UIImage</span> * processedImage = [<span class="built_in">UIImage</span> imageWithCGImage:newCGImage];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(inputCGImage);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    free(inputPixels);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然LSB的方式也能隐藏文字等其他信息。与之类似的想法还有 可以根据容差进行信息的隐藏。</p>
<p>若是有两张图片，则对两张图片的每一个像素点进行对比，设置一个容差的阈值α，超出这个阈值的像素点RGB值设置为(255,255,255),若是没超过阈值，则设置该像素点的RGB值为(0,0,0)。因此，通过调整不同的α值，可以使对比生成的图片呈现不同的画面。比如两张图完全一样，设置阈值α为任何值，最后得到的对比图都只会是全黑。若两张图每一个像素点都不同，阈值α设置为1，则对比图将是全白。如果将隐藏信息附加到某些像素点上，这时调整阈值α即可看到隐藏信息。</p>
<h3 id="JPEG压缩"><a href="#JPEG压缩" class="headerlink" title="JPEG压缩"></a>JPEG压缩</h3><p>目前例子中有个比较大的问题就是，经过LSB操作后的图片是需要无损的才能 解析出数据来。假设图片经过JPEG压缩后 如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将二维码图片信息藏入原图 得到result</span></span><br><span class="line"><span class="built_in">UIImage</span>* result = [<span class="keyword">self</span> handleImage:oriImg hideQrImage:qrImg];</span><br><span class="line"><span class="built_in">NSData</span>* resultData = <span class="built_in">UIImageJPEGRepresentation</span>(result, <span class="number">0.9</span>);</span><br><span class="line">result = [<span class="built_in">UIImage</span> imageWithData:resultData];</span><br><span class="line"><span class="comment">//从result中解析得到二维码</span></span><br><span class="line"><span class="built_in">UIImage</span>* qrResult = [<span class="keyword">self</span> handleHideImage:result];</span><br></pre></td></tr></table></figure>
<p>则qrResult会得到如下图：</p>
<p><img src="/res/iOSImg/qrResult_1.png" alt></p>
<p>这是由于JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，例子中最低位信息其实已经被改变。</p>
<h2 id="混色模式"><a href="#混色模式" class="headerlink" title="混色模式"></a>混色模式</h2><p>在PS 的混色模式中我们可以看到可以选项，混合模式的基本原理就是取A层任意一个像素a [R1, G1, B1]，与B层对应位置的像素b [R2, G2, B2] 进行数学运算，得到c [R3, G3, B3]。有兴趣可以看下 <a href="https://zhuanlan.zhihu.com/p/23905865" target="_blank" rel="noopener">一篇文章彻底搞清PS混合模式的原理</a></p>
<p>基于这种想法 我们可以模拟下PS的混合模式：</p>
<p><img src="/res/iOSImg/colorMix.png" alt></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">                <span class="built_in">UInt32</span> *currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line">                <span class="built_in">UInt32</span> color = *currentPixel;</span><br><span class="line">                <span class="built_in">UInt32</span> thisR,thisG,thisB,thisA;</span><br><span class="line">                <span class="comment">// 这里直接移位获得RBGA的值,以及输出写的非常好！</span></span><br><span class="line">                thisR = R(color);</span><br><span class="line">                thisG = G(color);</span><br><span class="line">                thisB = B(color);</span><br><span class="line">                thisA = A(color);</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">UInt32</span> newR,newG,newB;</span><br><span class="line">                newR = [<span class="keyword">self</span> SoftLight:thisR];</span><br><span class="line">                newG = [<span class="keyword">self</span> SoftLight:thisG];</span><br><span class="line">                newB = [<span class="keyword">self</span> SoftLight:thisB];</span><br><span class="line">                </span><br><span class="line">                *currentPixel = RGBAMake(newR,</span><br><span class="line">                                         newG,</span><br><span class="line">                                         newB,</span><br><span class="line">                                         thisA);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>Color Burn 颜色加深：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)ColorBurn:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//    C=A-(A反相×B反相)/B</span></span><br><span class="line"><span class="comment">//    如果上层越暗，则下层获取的光越少，加深效果越明显。</span></span><br><span class="line"><span class="comment">//    【如果上层为全黑色，则下层颜色值不是255的像素全变成0】，</span></span><br><span class="line"><span class="comment">//    如果上层为全白色，则根本不会影响下层。</span></span><br><span class="line"><span class="comment">//    结果最亮的地方不会高于下层的像素值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    resultValue = originValue - (<span class="number">255</span> - originValue) * (<span class="number">255</span> - bValue) / bValue;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Color Dodge 颜色减淡：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)ColorDodge:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//C=A+(A×B)/B反相</span></span><br><span class="line"><span class="comment">//该模式和上一个模式刚好相反。</span></span><br><span class="line"><span class="comment">//该模式下，上层的亮度决定了下层的暴露程度。</span></span><br><span class="line"><span class="comment">//如果上层越亮，下层获取的光越多，也就是越亮。</span></span><br><span class="line"><span class="comment">//如果上层是纯黑色，也就是没有亮度，则根本不会影响下层，</span></span><br><span class="line"><span class="comment">//【如果上层是纯白色，则下层颜色值不是0的像素全变成255】。</span></span><br><span class="line"><span class="comment">//结果最黑的地方不会低于下层的像素值。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    resultValue = originValue + originValue * bValue / (<span class="number">255</span> - bValue);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hard Light 强光：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">int</span>)HardLight:(<span class="keyword">int</span>)originValue &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//B&lt;=128则 C=(A×B)/128</span></span><br><span class="line"><span class="comment">//B&gt;128则 C=255-(A反相×B反相)/128</span></span><br><span class="line"><span class="comment">//该模式完全相对应于Overlay（叠加）模式下，两个图层进行次序交换的情况。</span></span><br><span class="line"><span class="comment">//如过上层的颜色高于50%灰，则下层越亮，反之越暗。</span></span><br><span class="line"><span class="comment">//【如果将上层图层设为叠加，下层设为强光，则改变图层顺序不影响结果。】</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bValue = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">int</span> resultValue = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(bValue &lt;= <span class="number">128</span>)&#123;</span><br><span class="line">        resultValue =   originValue * bValue / <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        resultValue = <span class="number">255</span> - (<span class="number">255</span> - originValue) * (<span class="number">255</span> - bValue) / <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (resultValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resultValue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        resultValue = <span class="number">255</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现一篇文章 <a href="https://juejin.im/post/5cd17612f265da037a3d0183" target="_blank" rel="noopener">iOS——隐形水印的实现和『颜色加深』算法</a> 文中说用 颜色加深来显示隐形水印，但是我换了几张图片实践了一下 效果不理想。有兴趣的同学可以自己实践下。</p>
<h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>简单马赛克核心算法的大概原理就是把某一个点的颜色赋值给它周围的指定区域，这个区域大小可以我们自己来定义。</p>
<p>按照这种想法可以做到：</p>
<p><img src="/res/iOSImg/msk.png" alt></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">//像素处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inputHeight; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inputWidth; i++) &#123;</span><br><span class="line">            <span class="comment">//原图 像素rgba信息</span></span><br><span class="line">            <span class="built_in">UInt32</span> * currentPixel = inputPixels + (j * inputWidth) + i;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">            <span class="keyword">float</span> markP = <span class="number">10</span>;<span class="comment">//10x10区域</span></span><br><span class="line">            <span class="built_in">NSUInteger</span> centerX = <span class="number">0</span> , centerY = <span class="number">0</span>;</span><br><span class="line">            centerX =  floor(i/markP)*markP + <span class="number">0.5</span>*markP;</span><br><span class="line">            centerX = centerX &gt;= (inputWidth<span class="number">-1</span>) ? (inputWidth<span class="number">-1</span>) : centerX;</span><br><span class="line">            centerY =  floor(j/markP)*markP + <span class="number">0.5</span>*markP;</span><br><span class="line">            centerY = centerY &gt;= (inputHeight<span class="number">-1</span>) ? (inputHeight<span class="number">-1</span>) : centerY;</span><br><span class="line">            <span class="built_in">UInt32</span> * centerPixel = inputPixels + (centerY * inputWidth) + centerX;</span><br><span class="line">            <span class="built_in">UInt32</span> centerColor = *centerPixel;</span><br><span class="line">            <span class="built_in">UInt32</span> centerR,centerG,centerB,centerA;</span><br><span class="line">            centerR=R(centerColor);</span><br><span class="line">            centerG=G(centerColor);</span><br><span class="line">            centerB=B(centerColor);</span><br><span class="line">            centerA=A(centerColor);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            *currentPixel = RGBAMake(centerR, centerG, centerB, centerA);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<h2 id="提取主色调"><a href="#提取主色调" class="headerlink" title="提取主色调"></a>提取主色调</h2><p>ref:<br><a href="https://github.com/tangdiforx/iOSPalette" target="_blank" rel="noopener">iOS-palette</a><br><a href="https://developer.android.com/reference/android/support/v7/palette/package-summary" target="_blank" rel="noopener">android-palette</a><br><a href="https://github.com/google/palette.js" target="_blank" rel="noopener">js-palette</a></p>
<p>遍历一遍图片的所有像素信息，然后统计一下哪个RGB值最多，不就是主色调嘛？但是人眼和冷冰冰的数据还是存在差异的。 Palette通过饱和度筛选 颜色区域解决颜色分散来选出主色调。参考<a href="https://www.jianshu.com/p/01df6010dded" target="_blank" rel="noopener">iOS图片精确提取主色调算法iOS-Palette</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/5806025-9188b291498651e7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/720/format/webp" alt></p>
]]></content>
      <categories>
        <category>iOS图片</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片-图片缩略方法</title>
    <url>/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E5%9B%BE%E7%89%87%E7%BC%A9%E7%95%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>介绍下在iOS中的多种图片缩略方式<br>ref <a href="https://nshipster.com/image-resizing/" target="_blank" rel="noopener">https://nshipster.com/image-resizing/</a></p>
</blockquote>
<p>在<code>UIKit CoreGraphics ImageIO CoreImage vImage</code>多种缩略方法中 Core Image表现最差。Core Graphics 和 Image I/O最好。</p>
<p>实际上，在苹果官方在 <a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1" target="_blank" rel="noopener">Performance Best Practices section of the Core Image Programming Guide</a> 部分中特别推荐使用Core Graphics或Image I / O功能预先裁剪或缩小图像。</p>
<a id="more"></a>
<h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p>UIGraphicsBeginImageContextWithOptions &amp; UIImage -drawInRect:</p>
<p>用于图像大小调整的最高级API可以在UIKit框架中找到。给定一个UIImage，可以使用临时图形上下文来渲染缩放版本。这种方式最简</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func uikit_resize(oriImg:<span class="built_in">UIImage</span>?,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    let hasAlpha = <span class="literal">false</span></span><br><span class="line">    let scale: <span class="built_in">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     创建一个图片类型的上下文。调用UIGraphicsBeginImageContextWithOptions函数就可获得用来处理图片的图形上下文。利用该上下文，你就可以在其上进行绘图，并生成图片</span></span><br><span class="line"><span class="comment">     size：表示所要创建的图片的尺寸</span></span><br><span class="line"><span class="comment">     opaque：表示这个图层是否完全透明，如果图形完全不用透明最好设置为YES以优化位图的存储，这样可以让图层在渲染的时候效率更高</span></span><br><span class="line"><span class="comment">     scale：指定生成图片的缩放因子，这个缩放因子与UIImage的scale属性所指的含义是一致的。传入0则表示让图片的缩放因子根据屏幕的分辨率而变化，所以我们得到的图片不管是在单分辨率还是视网膜屏上看起来都会很好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</span><br><span class="line">    oriImg!.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    let resizedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    <span class="keyword">return</span> resizedImage!</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in iOS 10 UIGraphicsImageRenderer</span></span><br><span class="line"><span class="comment">//    let render  = UIGraphicsImageRenderer(size: size)</span></span><br><span class="line"><span class="comment">//    return render.image(actions: &#123; (context) in</span></span><br><span class="line"><span class="comment">//        oriImg?.draw(in: CGRect(origin: .zero, size: size))</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CoreGraphics"><a href="#CoreGraphics" class="headerlink" title="CoreGraphics"></a>CoreGraphics</h3><p> CGBitmapContextCreate &amp; CGContextDrawImage</p>
<p> CoreGraphics / Quartz 2D提供了一套较低级别的API，允许进行更高级的配置。 给定一个CGImage，使用临时位图上下文来渲染缩放后的图像。<br> 使用CoreGraphics图像的质量与UIKit图像相同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func coreGraphics_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>)-&gt;<span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    let bitsPerComponent = cgImage.bitsPerComponent</span><br><span class="line">    let bytesPerRow = cgImage.bytesPerRow</span><br><span class="line">    let colorSpace = cgImage.colorSpace</span><br><span class="line">    let bitmapInfo = cgImage.bitmapInfo</span><br><span class="line">    </span><br><span class="line">    let context = <span class="built_in">CGContext</span>(data: <span class="literal">nil</span>,</span><br><span class="line">                                  width: Int(size.width),</span><br><span class="line">                                  height: Int(size.height),</span><br><span class="line">                                  bitsPerComponent: bitsPerComponent,</span><br><span class="line">                                  bytesPerRow: bytesPerRow,</span><br><span class="line">                                  space: colorSpace!,</span><br><span class="line">                                  bitmapInfo: bitmapInfo.rawValue)</span><br><span class="line">    </span><br><span class="line">    context?.interpolationQuality = .high</span><br><span class="line">    </span><br><span class="line">    context?.draw(cgImage, <span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    guard let resizedImage = context?.makeImage() <span class="keyword">else</span>&#123;<span class="keyword">return</span> <span class="literal">nil</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: resizedImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ImageIO"><a href="#ImageIO" class="headerlink" title="ImageIO"></a>ImageIO</h3><p> CGImageSourceCreateThumbnailAtIndex</p>
<p> Image I / O是一个功能强大但鲜为人知的用于处理图像的框架。 独立于Core Graphics，它可以在许多不同格式之间读取和写入，访问照片元数据以及执行常见的图像处理操作。 这个库提供了该平台上最快的图像编码器和解码器，具有先进的缓存机制，甚至可以逐步加载图像</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func imageIO_resize(url:URL,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    let options: [<span class="built_in">CFString</span>: Any] = [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageIfAbsent: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately: <span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize: max(size.width, size.height)</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    guard let imageSource = <span class="built_in">CGImageSourceCreateWithURL</span>(url as <span class="built_in">NSURL</span>, <span class="literal">nil</span>),</span><br><span class="line">        let image = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSource, <span class="number">0</span>, options as <span class="built_in">CFDictionary</span>)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CoreImage"><a href="#CoreImage" class="headerlink" title="CoreImage"></a>CoreImage</h3><p> 里面提供了强大高效的图像处理功能，用来对基于像素的图像进行操作与分析。IOS提供了很多强大的滤镜(Filter)，这些Filter提供了各种各样的效果，并且还可以通过滤镜链将各种效果的Filter叠加起来，形成强大的自定义效果，如果你对该效果不满意，还可以子类化滤镜。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let sharedContext = <span class="built_in">CIContext</span>(options: [.useSoftwareRenderer : <span class="literal">false</span>])</span><br><span class="line">func coreImage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    let scale = (Double)(size.width) / (Double)(oriImg.size.width)</span><br><span class="line">    </span><br><span class="line">    let image = <span class="built_in">CIImage</span>(cgImage: cgImage)</span><br><span class="line">    </span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</span><br><span class="line">    filter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">    filter?.setValue(<span class="built_in">NSNumber</span>(value:scale), forKey: kCIInputScaleKey)</span><br><span class="line">    filter?.setValue(<span class="number">1.0</span>, forKey:kCIInputAspectRatioKey)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    guard let outputCIImage = filter?.outputImage,</span><br><span class="line">        let outputCGImage = sharedContext.createCGImage(outputCIImage,</span><br><span class="line">                                                        from: outputCIImage.extent)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vImage"><a href="#vImage" class="headerlink" title="vImage"></a>vImage</h3><p> 使用CPU的矢量处理器处理大图像。 强大的图像处理功能，包括Core Graphics和Core Video互操作，格式转换和图像处理。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func vimage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    var format = vImage_CGImageFormat(bitsPerComponent: <span class="number">8</span>, bitsPerPixel: <span class="number">32</span>, colorSpace: <span class="literal">nil</span>,</span><br><span class="line">                                      bitmapInfo: <span class="built_in">CGBitmapInfo</span>(rawValue: <span class="built_in">CGImageAlphaInfo</span>.first.rawValue),</span><br><span class="line">                                      version: <span class="number">0</span>, decode: <span class="literal">nil</span>, renderingIntent: .defaultIntent)</span><br><span class="line">    </span><br><span class="line">    var sourceBuffer = vImage_Buffer()</span><br><span class="line">    defer &#123;</span><br><span class="line">        free(sourceBuffer.data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var error = vImageBuffer_InitWithCGImage(&amp;sourceBuffer, &amp;format, <span class="literal">nil</span>, cgImage, numericCast(kvImageNoFlags))</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a destination buffer</span></span><br><span class="line">    let scale = oriImg.scale</span><br><span class="line">    let destWidth = Int(size.width)</span><br><span class="line">    let destHeight = Int(size.height)</span><br><span class="line">    let bytesPerPixel = cgImage.bitsPerPixel / <span class="number">8</span></span><br><span class="line">    let destBytesPerRow = destWidth * bytesPerPixel</span><br><span class="line">    </span><br><span class="line">    let destData = UnsafeMutablePointer&lt;<span class="built_in">UInt8</span>&gt;.allocate(capacity: destHeight * destBytesPerRow)</span><br><span class="line">    defer &#123;        </span><br><span class="line">        destData.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    var destBuffer = vImage_Buffer(data: destData, height: vImagePixelCount(destHeight), width: vImagePixelCount(destWidth), rowBytes: destBytesPerRow)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// scale the image</span></span><br><span class="line">    error = vImageScale_ARGB8888(&amp;sourceBuffer, &amp;destBuffer, <span class="literal">nil</span>, numericCast(kvImageHighQualityResampling))</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a CGImage from vImage_Buffer</span></span><br><span class="line">    var destCGImage = vImageCreateCGImageFromBuffer(&amp;destBuffer, &amp;format, <span class="literal">nil</span>, <span class="literal">nil</span>, numericCast(kvImageNoFlags), &amp;error)?.takeRetainedValue()</span><br><span class="line">    guard error == kvImageNoError <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create a UIImage</span></span><br><span class="line">    let resizedImage = destCGImage.flatMap &#123;</span><br><span class="line">        <span class="built_in">UIImage</span>(cgImage: $<span class="number">0</span>, scale: <span class="number">0.0</span>, orientation: oriImg.imageOrientation)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    destCGImage = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> resizedImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS图片</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS图片-最佳实践</title>
    <url>/quick-start/%E5%9B%BE%E7%89%87/iOS%E5%9B%BE%E7%89%87-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>介绍下 wwdc 2018 Image and Graphics Best Practices 中图片处理解压相关知识点<br>ref: <a href="https://developer.apple.com/videos/play/wwdc2018/219" target="_blank" rel="noopener">Image and Graphics Best Practices</a></p>
</blockquote>
<h2 id="图片处理过程"><a href="#图片处理过程" class="headerlink" title="图片处理过程"></a>图片处理过程</h2><p>一张图片从磁盘中显示到屏幕上过程大致如下：从磁盘加载原始压缩的图片信息、解码二进制图片数据为位图、渲染图片最终绘制到屏幕上。</p>
<!-- ![](/res/imgBestP/imgBestP1.png) -->
<p><img src="/res/imgBestP/imgBestP1.png" width="80%"></p>
<p>在实际的渲染过程中，UIImage负责解压Data Buffer内容并申请buffer（Image Buffer）存储解压后的图片信息，然后UIImageView负责将Image Buffer 拷贝至 framebuffer，用于给显示硬件提供颜色信息。</p>
<p>解压过程是一个大量占用CPU资源的工作，因此UIImage 会retain存储解压后信息的Image Buffer以便给重复的渲染工作提供信息，Image Buffer与图片的实际尺寸有关（理论值为height <em> width </em> 4 bytes），与图片文件大小无关。若是在TableView等列表中连续加载多张图片，便会引发连续的大块内存分配，这将对Memory和CPU带来沉重的负担。</p>
<a id="more"></a>
<h3 id="Data-Buffer-Image-Buffer-Frame-Buffer"><a href="#Data-Buffer-Image-Buffer-Frame-Buffer" class="headerlink" title="Data Buffer / Image Buffer / Frame Buffer"></a>Data Buffer / Image Buffer / Frame Buffer</h3><p>图片处理过程中会产生三种buffer</p>
<h4 id="Data-Buffer"><a href="#Data-Buffer" class="headerlink" title="Data Buffer"></a>Data Buffer</h4><!-- ![](/res/imgBestP/imgBestP2.png) -->
<p><img src="/res/imgBestP/imgBestP2.png" width="80%"><br>Data Buffer存储了图片的元数据，我们常见的图片格式，jpeg，png等都是压缩图片格式。Data Buffer的内存大小就是源图片在磁盘中的大小。</p>
<h4 id="Image-Buffer"><a href="#Image-Buffer" class="headerlink" title="Image Buffer"></a>Image Buffer</h4><!-- ![](/res/imgBestP/imgBestP3.png) -->
<p><img src="/res/imgBestP/imgBestP3.png" width="80%"><br>Image Buffer存储的就是图片解码后的像素数据，也就是我们常说的位图。 Buffer中每一个元素描述的一个像素的颜色信息，buffer的size和图片的size成正相关关系。</p>
<h4 id="Frame-Buffer"><a href="#Frame-Buffer" class="headerlink" title="Frame Buffer"></a>Frame Buffer</h4><!-- ![](/res/imgBestP/imgBestP4.png) -->
<p><img src="/res/imgBestP/imgBestP3.png" width="80%"></p>
<p>Frame Buffer 存储了app每帧的实际输出。在应用程序更新图层时，UIKit将window及其subviews渲染至framebuffer，这个framebuffer提供每个像素的信息以供显示硬件定时读取，读取的频率一般为60Hz，但在ipad上可提升至120Hz。</p>
<h3 id="加载和解压"><a href="#加载和解压" class="headerlink" title="加载和解压"></a>加载和解压</h3><p><img src="/res/imgBestP/imgBestP5.png" alt></p>
<p>一般使用imageNamed:或者imageWithData:从内存中加载图片生成UIImage的实例，此刻图片并不会解压，当 RunLoop 准备处理图片显示的事务（CATransaction）时，才进行解压，而这个解压过程是在主线程中的，这是导致卡顿的重要因素。</p>
<p>解码后的图片内存占用会比原图大小大很多。ImageBuffer按照每个像素RGBA四个字节大小，一张1080p的图片解码后的位图大小是1920 <em> 1080 </em> 4 / 1024 / 1024，约7.9mb，而原图假设是jpg，压缩比1比20，大约350kb，可见解码后的内存占用是相当大的</p>
<h4 id="imageNamed-方法"><a href="#imageNamed-方法" class="headerlink" title="imageNamed: 方法"></a>imageNamed: 方法</h4><p>通过 imageNamed 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存去。</p>
<p>值得注意的是，这些缓存都是全局的，并不会因为当前UIImage实例的释放而清除，在收到内存警告或者 APP 第一次进入后台才有可能会清除，而这个清除的时机和内容是系统决定的，我们无法干涉。</p>
<h4 id="imageWithData-方法"><a href="#imageWithData-方法" class="headerlink" title="imageWithData: 方法"></a>imageWithData: 方法</h4><p>通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 CGImageSourceCreateWithData() 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。</p>
<p><strong>两种加载方式的区别</strong> 从上面的分析可知，imageNamed:使用时会产生全局的内存占用，但是第二次使用同一张图片时性能很好；imageWithData:不会有全局的内存占用，但对于同一张图片每次加载和解压都会“从头开始”。由此可见，imageNamed:适合“小”且“使用频繁”的图片，imageWithData:适合“大”且“低频使用”的图片。</p>
<h4 id="怎么能避免缓存呢？"><a href="#怎么能避免缓存呢？" class="headerlink" title="怎么能避免缓存呢？"></a>怎么能避免缓存呢？</h4><ol>
<li>手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。</li>
<li>把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="大图使用缩略图"><a href="#大图使用缩略图" class="headerlink" title="大图使用缩略图"></a>大图使用缩略图</h3><p>值得注意的是，可能业务中需要载入一张很大的图片。这时，若还使用常规的方式加载会占用过多的内存；况且，若图片的像素过大（目前主流 iOS 设备最高支持 4096 x 4096 纹理尺寸），在显示的时候 CPU 和 GPU 都会消耗额外的资源来处理图片。可以采用imageIO api来生成缩略图</p>
<p><img src="/res/imgBestP/imgBestP6.png" alt></p>
<p>具体代码如下，指定显示区域大小</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func downsample(imageAt imageURL:URL,to pointSize:<span class="built_in">CGSize</span>,scale:<span class="built_in">CGFloat</span>)-&gt;<span class="built_in">UIImage</span>&#123;</span><br><span class="line"><span class="comment">//设置kCGImageSourceShouldCache为false，避免缓存解码后的数据，64位设置上默认是开启缓存的</span></span><br><span class="line">    let imageSourceOptions = [kCGImageSourceShouldCache:<span class="literal">false</span>] as <span class="built_in">CFDictionary</span></span><br><span class="line">    let imageSouce = <span class="built_in">CGImageSourceCreateWithURL</span>(imageURL as <span class="built_in">CFURL</span>, imageSourceOptions)!</span><br><span class="line">    </span><br><span class="line">    let maxDimensionInPixels = max(pointSize.width,pointSize.height) * scale</span><br><span class="line"><span class="comment">//设置kCGImageSourceShouldCacheImmediately为true，避免在需要渲染的时候才做解码，默认选项是false    </span></span><br><span class="line">    let downsampleOptions =</span><br><span class="line">     [</span><br><span class="line">        kCGImageSourceCreateThumbnailFromImageAlways:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceShouldCacheImmediately:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceCreateThumbnailWithTransform:<span class="literal">true</span>,</span><br><span class="line">        kCGImageSourceThumbnailMaxPixelSize:maxDimensionInPixels</span><br><span class="line">     ] as <span class="built_in">CFDictionary</span></span><br><span class="line">    </span><br><span class="line">    let downsampledImage = <span class="built_in">CGImageSourceCreateThumbnailAtIndex</span>(imageSouce, <span class="number">0</span>, downsampleOptions)!</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: downsampledImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他缩略方法可以看<a href="../iOS图片-图片缩略方法">iOS图片-图片缩略方法</a></p>
<h3 id="大图使用CATiledLayer"><a href="#大图使用CATiledLayer" class="headerlink" title="大图使用CATiledLayer"></a>大图使用CATiledLayer</h3><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</p>
<p>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是20482048，或40964096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</p>
<p>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIScrollView</span> *scrollView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">//add the tiled layer</span></span><br><span class="line">    <span class="built_in">CATiledLayer</span> *tileLayer = [<span class="built_in">CATiledLayer</span> layer];￼</span><br><span class="line">    tileLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">2048</span>);</span><br><span class="line">    tileLayer.delegate = <span class="keyword">self</span>; [<span class="keyword">self</span>.scrollView.layer addSublayer:tileLayer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//configure the scroll view</span></span><br><span class="line">    <span class="keyword">self</span>.scrollView.contentSize = tileLayer.frame.size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw layer</span></span><br><span class="line">    [tileLayer setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CATiledLayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//determine tile coordinate</span></span><br><span class="line">    <span class="built_in">CGRect</span> bounds = <span class="built_in">CGContextGetClipBoundingBox</span>(ctx);</span><br><span class="line">    <span class="built_in">NSInteger</span> x = floor(bounds.origin.x / layer.tileSize.width);</span><br><span class="line">    <span class="built_in">NSInteger</span> y = floor(bounds.origin.y / layer.tileSize.height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//load tile image</span></span><br><span class="line">    <span class="built_in">NSString</span> *imageName = [<span class="built_in">NSString</span> stringWithFormat: <span class="string">@"Snowman_%02i_%02i"</span>, x, y];</span><br><span class="line">    <span class="built_in">NSString</span> *imagePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:imageName ofType:<span class="string">@"jpg"</span>];</span><br><span class="line">    <span class="built_in">UIImage</span> *tileImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:imagePath];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//draw tile</span></span><br><span class="line">    <span class="built_in">UIGraphicsPushContext</span>(ctx);</span><br><span class="line">    [tileImage drawInRect:bounds];</span><br><span class="line">    <span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="异步加载解压"><a href="#异步加载解压" class="headerlink" title="异步加载解压"></a>异步加载解压</h3><p>对于加载过程，若文件过大或加载频繁影响了帧率（比如列表展示大图），可以使用异步方式加载图片，减少主线程的压力,解压是耗时的，而系统默认是在主线程执行，所以业界通常有一种做法是，异步强制解压，也就是在异步线程主动将二进制图片数据解压成位图数据，使用CGBitmapContextCreate(…)系列方法就能实现。代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let serialQueue = DispatchQueue(label: &quot;Decode queue&quot;)</span><br><span class="line">func collectionView(_ collectionView:UICollectionView,prefetcgItemAt indexPaths:[IndexPath])&#123;</span><br><span class="line">    //异步解压 生成缩略图</span><br><span class="line">    for indexPath in indexPaths&#123;</span><br><span class="line">        serialQueue.async &#123;</span><br><span class="line">            let downsampledImage = downsample(images[IndexPath])</span><br><span class="line">            DispatchQueue.main.async &#123;self.update(at:IndexPath.with:downsampledImage)&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合理使用draw方法"><a href="#合理使用draw方法" class="headerlink" title="合理使用draw方法"></a>合理使用<code>draw</code>方法</h3><p>重载<code>draw</code>方法会导致内存爆涨。原因如下：</p>
<p><img src="/res/imgBestP/imgBestP7.png" alt></p>
<p>一旦你实现了<em>CALayerDelegate</em>协议中的<code>-drawLayer:inContext:</code>方法或者UIView中的<code>-drawRect:</code>方法（其实就是前者的包装方法），CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境(Backing Store)，为绘制寄宿图做准备，它作为ctx参数传入。图层就创建了一个绘制上下文(Backing Store)，这个上下文需要的内存可从这个公式得出：图层宽 <em> 图层高</em> 4 字节，宽高的单位均为像素。以iphone6为例，750 <em> 1134 </em> 4 字节 ≈ 3.4 Mb 。</p>
<p>总结下这种使用drawRect绘制方案的问题</p>
<ol>
<li>Backing Store的创建造成了不必要的内存开销</li>
<li>UIImage先绘制到Backing Store，再渲染到frameBuffer，中间多了一层内存拷贝</li>
<li>背景颜色不需要绘制到Backing Store，直接使用BackGroundColor绘制到FrameBuffer</li>
</ol>
<p>所以，正确的实现姿势是将这个大的view拆分成小的subview逐个实现。</p>
<h3 id="推荐使用Image-Assets"><a href="#推荐使用Image-Assets" class="headerlink" title="推荐使用Image Assets"></a>推荐使用Image Assets</h3><p>基于名称和特效优化了查找效率，更快的查找图片<br>运行时，对内存的管理也有优化<br>App Slicing，app安装包瘦身。iOS 9 后会从 Image Assets 中保留设备支持的图片 （2x 或者 3x）<br>iOS 11 后的 Preserve Vector Data。支持矢量图的功能，放大也不会失真</p>
<h3 id="Advanced-Image-Effects"><a href="#Advanced-Image-Effects" class="headerlink" title="Advanced Image Effects"></a>Advanced Image Effects</h3><p>对于图片的实时处理推荐使用CoreImage框架。<br>例如将一张图片的灰度值进行调整这样的操作，有滴小伙伴可能使用CoreGraphics获取图像的每个像素点数据，然后改变灰度值，最终生成目标图标，这种做法将大量gpu擅长的工作放在了cpu上处理，合理的做法是: 使用CoreImage的滤镜filter或者metal，OpenGL的shader，让图像处理的工作交给GPU去做。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let sharedContext = <span class="built_in">CIContext</span>(options: [.useSoftwareRenderer : <span class="literal">false</span>])</span><br><span class="line">func coreImage_resize(oriImg:<span class="built_in">UIImage</span>,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>? &#123;</span><br><span class="line">    </span><br><span class="line">    guard  let cgImage = oriImg.cgImage <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    let scale = (Double)(size.width) / (Double)(oriImg.size.width)</span><br><span class="line">    let image = <span class="built_in">CIImage</span>(cgImage: cgImage)</span><br><span class="line">    </span><br><span class="line">    let filter = <span class="built_in">CIFilter</span>(name: <span class="string">"CILanczosScaleTransform"</span>)</span><br><span class="line">    filter?.setValue(image, forKey: kCIInputImageKey)</span><br><span class="line">    filter?.setValue(<span class="built_in">NSNumber</span>(value:scale), forKey: kCIInputScaleKey)</span><br><span class="line">    filter?.setValue(<span class="number">1.0</span>, forKey:kCIInputAspectRatioKey)</span><br><span class="line">    </span><br><span class="line">    guard let outputCIImage = filter?.outputImage,</span><br><span class="line">        let outputCGImage = sharedContext.createCGImage(outputCIImage,</span><br><span class="line">                                                        from: outputCIImage.extent)</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIImage</span>(cgImage: outputCGImage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Drawing-Off-Screen"><a href="#Drawing-Off-Screen" class="headerlink" title="Drawing Off-Screen"></a>Drawing Off-Screen</h3><p>对于需要离屏渲染的场景推荐使用UIGraphicsImageRenderer替代UIGraphicsBeginImageContext，性能更好，并且支持广色域。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">func uikit_resize(oriImg:<span class="built_in">UIImage</span>?,size:<span class="built_in">CGSize</span>) -&gt; <span class="built_in">UIImage</span>?&#123;</span><br><span class="line">    let hasAlpha = <span class="literal">false</span></span><br><span class="line">    let scale: <span class="built_in">CGFloat</span> = <span class="number">0.0</span> <span class="comment">// Automatically use scale factor of main screen</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, !hasAlpha, scale)</span><br><span class="line">    oriImg!.draw(<span class="keyword">in</span>: <span class="built_in">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">    </span><br><span class="line">    let resizedImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>()</span><br><span class="line">    <span class="keyword">return</span> resizedImage!</span><br><span class="line"></span><br><span class="line">    <span class="comment">//in iOS 10 UIGraphicsImageRenderer</span></span><br><span class="line"><span class="comment">//    let render  = UIGraphicsImageRenderer(size: size)</span></span><br><span class="line"><span class="comment">//    return render.image(actions: &#123; (context) in</span></span><br><span class="line"><span class="comment">//        oriImg?.draw(in: CGRect(origin: .zero, size: size))</span></span><br><span class="line"><span class="comment">//    &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS图片</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>图片</tag>
      </tags>
  </entry>
</search>
